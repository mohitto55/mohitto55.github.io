<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-09T22:01:35+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mohitto55 Note</title><subtitle>모히또의 노트</subtitle><author><name>Mohitto55</name></author><entry><title type="html">[VScode] Snippet을 이용해 템플릿 사용하기</title><link href="http://localhost:4000/vscode/VSCode-Snippets/" rel="alternate" type="text/html" title="[VScode] Snippet을 이용해 템플릿 사용하기" /><published>2024-03-09T00:00:00+09:00</published><updated>2024-03-09T00:00:00+09:00</updated><id>http://localhost:4000/vscode/VSCode%20Snippets</id><content type="html" xml:base="http://localhost:4000/vscode/VSCode-Snippets/"><![CDATA[<h2 id="snippet">Snippet</h2>
<blockquote>
  <p>스니펫(snippet)은 재사용 가능한 소스 코드, 기계어, 텍스트의 작은 부분을 일컫는 프로그래밍 용어이다. 사용자가 루틴 편집 조작 중 반복 타이핑을 회피할 수 있게 도와준다.
-<a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%8B%88%ED%8E%AB">Wikipedia</a></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">snippet</code>이란 <strong>작은 코드 조각</strong>을 뜻하는 말로 자주 쓰는 코드를 하나의 템플릿으로 만들어 반복작업을 줄일 수 있게 해주는 기능을 말한다.</p>

<p>대부분의 텍스트 편집기, IDE는 이런 <code class="language-plaintext highlighter-rouge">snipet</code> 기능을 지원하며 VScode또한 마찬가지다.</p>

<h2 id="vscode에서-snippet-사용하기">VScode에서 Snippet 사용하기</h2>
<h3 id="1-snippet-파일-열기">1. Snippet 파일 열기</h3>
<p><code class="language-plaintext highlighter-rouge">snippet</code>을 작성하기 위해선 먼저 <code class="language-plaintext highlighter-rouge">snippet</code>코드를 관리하는 <code class="language-plaintext highlighter-rouge">JSON</code>파일을 열어야 한다. 파일을 열기위한 방법은 두가지가 있다.</p>

<hr />

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/63414c56-30f2-4f78-9818-b1f4fa30e2d2" alt="image" /></p>

<p><strong>1. File-&gt;Preferences-&gt;Configure User Snippets</strong></p>

<p><strong>2. Setting-&gt;User Snippets</strong></p>

<hr />

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/b3df2470-fc19-45ba-bca8-60f4c685993a" alt="image" /></p>

<p>위 두가지 방법 중 하나를 실행하면 화면 상단에 커맨드창이 나올것이다. 필요한 <code class="language-plaintext highlighter-rouge">snipet</code> 파일을 열고 없으면 <code class="language-plaintext highlighter-rouge">New Global Snippets file</code>을 눌러 파일이름을 설정 한 후 연다.</p>

<hr />
<h3 id="2-내용-작성하기">2. 내용 작성하기</h3>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
	</span><span class="nl">"snippet-name"</span><span class="p">:{</span><span class="w">
		</span><span class="nl">"prefix"</span><span class="p">:</span><span class="w"> </span><span class="s2">"blog-template"</span><span class="p">,</span><span class="w">
		</span><span class="nl">"body"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
		</span><span class="s2">"---"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"title : '[] '"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"category: "</span><span class="p">,</span><span class="w">
		</span><span class="s2">"tags: []"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"---"</span><span class="p">,</span><span class="w">
		</span><span class="s2">""</span><span class="p">,</span><span class="w">
		</span><span class="s2">""</span><span class="p">,</span><span class="w">
		</span><span class="s2">""</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;div class='Reference'&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;div class='callout-header'&gt; &lt;/div&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;p&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;a href=''&gt;&lt;/a&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;/p&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;/div&gt;"</span><span class="w">
	</span><span class="p">],</span><span class="w">
		</span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Blog Template"</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>소스는 다음 규격을 맞춰 작성하면 된다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이름</th>
      <th><center>설명</center></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">snippet-name</td>
      <td>- snippet의 이름<br />- description이 설정 되있지 않으면 Intellisense에서 해당 이름이 표시된다.</td>
    </tr>
    <tr>
      <td style="text-align: center">prefix</td>
      <td>- 자동완성시 불러올 키워드</td>
    </tr>
    <tr>
      <td style="text-align: center">body</td>
      <td>- 자동완성시 불러올 내용<br />- 줄이 여러개일 경우 ,(comma)를 이용해 줄 바꿈을 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">description</td>
      <td>- prefix 작성 시 Intellisense에서 표시 될 설명이다.</td>
    </tr>
  </tbody>
</table>

<hr />
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/c15bcda9-d6d5-4340-a7e4-992411b7f4d6" alt="Honeycam" /><em>snippet을 활용해 생산성을 높일 수 있다</em></p>

<p><code class="language-plaintext highlighter-rouge">snippet</code>이 적용이 되면 위와 같이 작동한다. 단 몇 타자 만으로 긴 코드를 빠르게 작성할 수 있다.</p>

<h2 id="snippet-적용이-안될-경우">Snippet 적용이 안될 경우</h2>
<p>설정을 완벽하게 했음에도 불구하고 Intellisense가 작동하지 않는 경우가 있다. 그럴경우 <code class="language-plaintext highlighter-rouge">setting.json</code>에서 <code class="language-plaintext highlighter-rouge">editor.quickSuggestions</code>을 true로 설정해줘야 한다.</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/53927eaa-961c-4f7a-8006-13142db2a248" alt="image" /><em>View-&gt;Command palette OR Ctrl+Shift+p</em></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"[markdown]"</span><span class="p">:{</span><span class="w">
     </span><span class="nl">"editor.quickSuggestions"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>커맨드 창을 열어 <code class="language-plaintext highlighter-rouge">Open User Setting(JSON)</code>을 적고 위 소스를 넣어주면 된다.</p>

<div class="callout-info-expanded">
<div class="callout-header">setting.json과 quickSuggestions</div>
<p>
setting.json은 작업중인 프로젝트의 셋팅값을 설정하는 파일이고 quickSuggestions 설정은 자동 완성 활성화 여부를 결정하는 값이다.
</p>
</div>

<h2 id="snippet-변수">Snippet 변수</h2>
<p><code class="language-plaintext highlighter-rouge">snippet</code>은 여러 변수 값을 지원한다. <code class="language-plaintext highlighter-rouge">$name</code> or <code class="language-plaintext highlighter-rouge">${name:default}</code> 같은 문구를 사용 함으로써 파일의 이름이나 내용을 불러올 수 있다. 자세한 내용은 <a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">공식문서</a>에서 확인하기 바란다.</p>

<hr />

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://velog.io/@humblego42/VSCode%EC%97%90%EC%84%9C-Snippet-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0">vVSCode에서 Snippet 활용하기</a>
<a href="https://junu-k.medium.com/vscode-%EA%BF%80%ED%8C%81-1-%EB%82%98%EB%A7%8C%EC%9D%98-%EC%8A%A4%EB%8B%88%ED%8E%AB-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-28b6044a77d3">vscode 꿀팁: 나만의 스니펫 사용하기</a>
<a href="https://gnews365.tistory.com/entry/vscode-settingjson-%EC%97%90-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4-%EC%BD%94%EB%93%9C">vscode setting.json 에 들어가기</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="vscode" /><category term="Vscode" /><category term="Snippet" /><category term="Template" /><category term="템플릿" /><category term="스니펫" /><category term="IDE" /><summary type="html"><![CDATA[Snippet 스니펫(snippet)은 재사용 가능한 소스 코드, 기계어, 텍스트의 작은 부분을 일컫는 프로그래밍 용어이다. 사용자가 루틴 편집 조작 중 반복 타이핑을 회피할 수 있게 도와준다. -Wikipedia]]></summary></entry><entry><title type="html">[Git Blog] 마크다운으로 이미지 캡션 추가하기</title><link href="http://localhost:4000/gitblog/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%BA%A1%EC%85%98/" rel="alternate" type="text/html" title="[Git Blog] 마크다운으로 이미지 캡션 추가하기" /><published>2024-03-09T00:00:00+09:00</published><updated>2024-03-09T00:00:00+09:00</updated><id>http://localhost:4000/gitblog/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%20%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EC%BA%A1%EC%85%98</id><content type="html" xml:base="http://localhost:4000/gitblog/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%BA%A1%EC%85%98/"><![CDATA[<h2 id="이미지-캡션">이미지 캡션</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/4f373422-5831-4b69-8cd3-cef821f8f859" alt="image" /><em>이미지 아래 회색 글씨</em>
캡션이란 위와 같이 이미지 아래 작은 글씨로 이미지에 대한 설명 글을 뜻한다. 한 문장으로 이미지에 대한 설명을 간략히 보여주기에 글을 이해하는데 도움을 주는 기능이다.</p>

<hr />
<h3 id="markdown-이미지">Markdown 이미지</h3>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">![</span><span class="nv">이름</span><span class="p">](</span><span class="sx">링크</span><span class="p">)</span>
</code></pre></div></div>

<p>minimal-mistake 블로그 글을 쓸 때 이미지 표시를 주로 마크다운 기능을 이용해서 작성하는데 아쉽게도 마크다운에선 캡션 기능을 지원하고 있지 않다.</p>

<p><strong>css</strong>를 이용하면 구현이 되지만 <strong>html</strong>태그를 작성해야 하기에 어떻게든 마크다운 만으로 캡션기능을 넣고 싶어 이것 저것 찾아봤다.</p>

<hr />

<h3 id="markdown-이미지-캡션-사용법">Markdown 이미지 캡션 사용법</h3>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">![</span><span class="nv">이름</span><span class="p">](</span><span class="sx">링크</span><span class="p">)</span><span class="ge">*캡션내용*</span>
</code></pre></div></div>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/429cfcbd-d2e3-464b-84c3-7f6affb15c4d" alt="image" class="width-half" /><em>em 태그가 만들어진다</em>
html태그를 쓰지 않으면서 마크다운 만으로 캡션을 넣는 방법이 있다. 마크다운 이미지 링크 바로 뒤에 <em>Italics</em>글씨체로 바꿔주는 ** 문법을 넣는다.</p>

<p>해당 문법은 블로그 페이지가 생성될 시 em태그로 변환되어 지는데 css에서 <strong>em</strong>태그 속성을 변경하는 방식으로 캡션 기능을 만든다.</p>

<hr />
<h4 id="css-추가">CSS 추가</h4>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span> <span class="o">+</span> <span class="nt">em</span> <span class="p">{</span>
    <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
    <span class="nl">text-align</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
    <span class="nl">text-emphasis</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">_sass/_page.scss</code>로가서 위 소스를 추가해주면 된다.
이는 img 뒤에 올 em태그의 속성을 변경하는 css로 캡션과 같이 이미지 아래에 글씨가 오게 설정한다.</p>

<p>해당 소스를 그대로 사용하면 em태그로 인해 글씨체가 기울어져 있을 것이다. 일반 글씨체로 바꾸고 싶고 작게 보이게 하고 싶다면 아래 내용을 추가한다.</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span> <span class="o">+</span> <span class="nt">em</span> <span class="p">{</span>
    <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
    <span class="nl">text-align</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
    <span class="nl">text-emphasis</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
    <span class="nl">font-size</span><span class="p">:</span> <span class="m">0.8em</span><span class="p">;</span> <span class="err">//글씨</span> <span class="err">크기를</span> <span class="err">줄인다</span>
    <span class="nl">font-style</span><span class="p">:</span> <span class="nb">normal</span><span class="p">;</span> <span class="err">//Italics글씨체가</span> <span class="err">아닌</span> <span class="err">일반</span> <span class="err">글씨체</span>
    <span class="nl">color</span><span class="p">:</span> <span class="n">rgba</span><span class="p">(</span><span class="err">$</span><span class="n">text-color</span><span class="p">,</span> <span class="m">0.75</span><span class="p">);</span> <span class="err">//폰트색의</span> <span class="err">투명도를</span> <span class="err">낮춘다</span>
  <span class="p">}</span>
</code></pre></div></div>

<hr />
<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://62che.com/blog/vuepress/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%97%90-%EC%BA%A1%EC%85%98-%EB%8B%AC%EA%B8%B0.html#%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%86%E1%85%A9%E1%84%8B%E1%85%A3%E1%86%BC">https://62che.com/blog/vuepress/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%97%90-%EC%BA%A1%EC%85%98-%EB%8B%AC%EA%B8%B0.html#%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%86%E1%85%A9%E1%84%8B%E1%85%A3%E1%86%BC</a>
<a href="https://yoophi.github.io/logs/vuepress/image-caption.html">https://yoophi.github.io/logs/vuepress/image-caption.html</a>
<a href="https://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll">https://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="gitblog" /><category term="Git" /><category term="Blog" /><category term="minimal-mistake" /><category term="Jekyll" /><category term="Markdown" /><category term="Caption" /><category term="마크다운" /><category term="캡션" /><summary type="html"><![CDATA[이미지 캡션 이미지 아래 회색 글씨 캡션이란 위와 같이 이미지 아래 작은 글씨로 이미지에 대한 설명 글을 뜻한다. 한 문장으로 이미지에 대한 설명을 간략히 보여주기에 글을 이해하는데 도움을 주는 기능이다.]]></summary></entry><entry><title type="html">[C++] 백준 12865번-평범한 배낭</title><link href="http://localhost:4000/boj/BOJ-12865%EB%B2%88/" rel="alternate" type="text/html" title="[C++] 백준 12865번-평범한 배낭" /><published>2024-03-06T00:00:00+09:00</published><updated>2024-03-06T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ%2012865%EB%B2%88</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-12865%EB%B2%88/"><![CDATA[<p><a href="https://www.acmicpc.net/problem/12865">BOJ 12865-평범한 배낭</a></p>

<h2 id="문제">문제</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/a44cd234-e6ab-416d-ba26-dc7cc217c050" alt="image" /></p>

<div class="code-block1">
예제 입력
<div class="language-cpp highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code>4 7
6 13
4 8
3 6
5 12</code></pre></div></div></div>

<div class="code-block2">
에제 출력
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>14</code></pre></div></div></div>

<h2 id="풀이">풀이</h2>
<p>DP를 이용하는 <strong>냅색(Knapsack)</strong>문제다.</p>
<ul>
  <li>물건을 넣는 경우와 안넣는 경우 두가지에 대한 모든 경우의 수 중 무게가 k보다 안 높고 value가 가장 높은 경우를 구한다.</li>
  <li>필요없는 경우의 수를 제외하기 위해 flag[무게 합][탐색 중인 배낭 Index]의 값에 가장 높은 value값을 저장하고 만약 이 값보다 낮으면 탐색을 중단한다.</li>
</ul>

<h2 id="소스코드">소스코드</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"bits/stdc++.h"</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">weight</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">value</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">100001</span><span class="p">][</span><span class="mi">101</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">DP</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">flag</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">+</span> <span class="n">weight</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">v</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]));</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">DP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Mohitto55</name></author><category term="boj" /><category term="boj" /><category term="백준" /><category term="solved" /><category term="문제풀이 12865번" /><category term="Knapsack" /><category term="Dynamic Programming" /><category term="DP" /><category term="C++" /><category term="배낭문제" /><summary type="html"><![CDATA[BOJ 12865-평범한 배낭]]></summary></entry><entry><title type="html">[Algorithm] Dynamic Programming(동적 계획법) 설명</title><link href="http://localhost:4000/algorithm/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95-%EC%84%A4%EB%AA%85/" rel="alternate" type="text/html" title="[Algorithm] Dynamic Programming(동적 계획법) 설명" /><published>2024-03-06T00:00:00+09:00</published><updated>2024-03-06T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95%20%EC%84%A4%EB%AA%85</id><content type="html" xml:base="http://localhost:4000/algorithm/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95-%EC%84%A4%EB%AA%85/"><![CDATA[<h2 id="dynamic-programming">Dynamic Programming</h2>
<p>다이나믹 프로그래밍이란 복잡한 문제를 여러개의 작은 문제로 나누고 값을 저장하여 푸는 <strong>방법</strong>을 말한다. 일반적으로 재귀 함수를 통해 이전 함수의 결과 값을 이용해 문제를 풀어나간다.</p>

<h2 id="동적계획법-사용하는-이유">동적계획법 사용하는 이유</h2>
<p>동적계획법은 재귀(Naive Recursion)함수와 비슷하다. 일반적인 재귀 함수는 같은 조건의 작은 문제들이 여러번 반복되어서 효율성이 낮다. 가장 대표적인 문제 중 하나인 <strong>피보나치 수열</strong>을 예시로 들어보자면</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/ba0e9997-bbd3-4b81-aa69-10f8870712ce" alt="image" /></p>

<p>피보나치의 점화식은 <code class="language-plaintext highlighter-rouge">f(n) = f(n-1)+f(n-2)</code> 이다.  만약 <code class="language-plaintext highlighter-rouge">f(n-1)</code>과 <code class="language-plaintext highlighter-rouge">f(n-2)</code> 함수를 각각 호출할 시 겹치는 식이 많아 지는 것을 볼 수 있다. n이 크면 클 수록 겹치는 식이 기하급수적으로 늘어날 것이 분명하다. 이렇듯 재귀함수는 문제의 크기가 클수록 효율성이 매우 떨어진다.</p>

<p>동적계획법은 재귀함수하지만 이미 한번 구한 결과 값을 저장하고 다음에 같은 조건의 식이 발생하면 저장해 놓은 값을 재사용함으로 써 불필요한 연산을 줄여 속도를 매우 높일 수 있다.</p>

<h2 id="사용조건">사용조건</h2>
<h3 id="overlapping-subproblems겹치는-부분-구조">Overlapping Subproblems(겹치는 부분 구조)</h3>
<p>DP는 기본적으로 <strong>겹치는 문제</strong>가 발생할 시에 사용할 수 있다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/ba0e9997-bbd3-4b81-aa69-10f8870712ce" alt="image" /></p>

<p>피보나치 수열과 같이 겹치는 식의 경우 값을 저장했다가 다음번에 같은 식이 발생하면 다시 재사용한다.</p>

<hr />
<h3 id="optimal-substructure최적-부분-구조">Optimal Substructure(최적 부분 구조)</h3>
<p>부분 문제의 최적의 결과 값이 전체 문제의 <strong>최적의 결과</strong>를 낼 수 있는 경우를 뜻한다. 이러한 구조를 가진다면 문제는 여러 작은 부분 문제로 나뉠 수 있고 <strong>작은 문제의 값을 이용해 큰 문제의 값</strong>도 구할 수 있다.</p>

<p>피보나치 수열도 이런 최적 부분 구조를 지녔는데 <code class="language-plaintext highlighter-rouge">f(n) = f(n-1)+f(n-2)</code> 와 같이 작은 부분인 <code class="language-plaintext highlighter-rouge">f(n-1</code>)와 <code class="language-plaintext highlighter-rouge">f(n-2)</code>를 이용해 <code class="language-plaintext highlighter-rouge">f(n)</code>을 구할 수 있다.</p>

<h2 id="dp-적용하기">DP 적용하기</h2>
<h3 id="1-dp문제인지-확인하기">1. DP문제인지 확인하기</h3>
<p>dp를 사용하기 위해선 당연하게도 해당 문제가 DP를 이용하는 문제인지 파악 해야 한다.</p>

<p>파악하는 방법은 위에서 말했던 대로 <strong>큰 문제를 작은 문제로</strong> 나눌 수 있는지 확인하고 작은 문제의 결과 값이 큰 문제의 <strong>최적 값</strong>을 낼 수 있는지 확인한다.</p>

<h3 id="2-점화식-파악하기">2. 점화식 파악하기</h3>
<p>DP문제임을 확인 했다면 <font color="dodgerred">점화식</font>을 알아야 한다.
점화식이란 DP문제를 푸는데 사용하는 재귀식을 말한다. 즉 하위 문제와 상위 문제식간의 상관 관계를 뜻한다.</p>

<p>점화식을 구하는 것이 DP문제의 핵심으로 이를 구해야 재귀 함수를 구현할 수 있다. 점화식은 문제마다 다르기에 문제에 맞는 점화식을 찾아야한다.</p>

<h3 id="3-memoization-방법-구상하기">3. Memoization 방법 구상하기</h3>
<p>점화식을 이용해 구현한 함수의 값을 저장할 방법을 구상 해야 한다. 이렇게 작은 문제에서 사용한 값을 다음에도 쓰기 위해 저장하는 방법을 <strong>Memoization</strong>이라고 한다.</p>

<p>배열에 값을 저장하고 후에 사용하는 문제에서 같은 조건의 문제가 이미 있었을 경우 저장된 값을 불러와 재사용 해야한다.</p>

<h3 id="4-기저-상태-확인하기">4. 기저 상태 확인하기</h3>
<p>가장 많이 실수 하는 부분 중 하나다. 더 이상 쪼갤 수 없는 문제 즉 <font color="dodgerred">가장 작은 문제</font>의 경우의 상황을 확인 해야 한다.</p>

<p>예를 들어 가장 작은 상태일 경우에만 특정 값을 반환하는 등 조건 식을 만드는데 문제의 상황에 따라 다르다.</p>

<p>힘들게 점화식을 풀어도 미처 생각지도 못한 부분에서 오류가 발생할 수 있으니 <strong>여러 경우의 수</strong>들을 생각하며 조건을 알아야 한다.</p>

<h3 id="5-구현하기">5. 구현하기</h3>
<p>마지막으로 구상한 내용들을 토대로 코드를 작성하면 된다.</p>

<h2 id="사용방법">사용방법</h2>
<h3 id="bottom-up-방식---반복문">Bottom-Up 방식 - 반복문</h3>
<p>작은 문제를 계산하고 그 값들을 누적 해서 큰 값을 구하는 방식이다. 결과 값을 저장하는 배열 dp가 있다고 했을 때 작은 문제에서 사용하던 결과 값을 저장해 놓은 다음 큰 문제에서 하위 문제에서 저장한 값을 가져다 사용한다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/87fc9c70-0db4-4a97-8645-07b84905467b" alt="image" /></p>

<p>이 방식을 <strong>Tabulation</strong> 방식이라고 하는 이유는 반복문을 통해 테이블의 처음부터 끝까지 채우는 과정을 <strong>table-filling</strong> 이라고 부르기 때문이다.</p>

<p>결과 값을 저장하고 기억한다는 점에선 Memoization과 비슷하다.</p>

<hr />
<h3 id="top-down-방식---재귀">Top-Down 방식 - 재귀</h3>
<p>n값을 구하기 위해 가장 작은 문제인 기저 상태에서 시작하는 대신 가장 큰 문제인 <code class="language-plaintext highlighter-rouge">dp[n]</code>부터 시작하는 방식을 말하며, 내려갈 식까지 간 후 결과 값을 반환하는 방식으로 <strong>재귀</strong>를 통해 푸는 방식이다.</p>

<p>이전에 계산을 완료 했을 경우 저장 된 값을 불려와 이용하는 Memoization 방식을 쓴다.</p>

<h2 id="분할정복divide-and-conquer과의-차이점">분할정복(Divide and Conquer)과의 차이점</h2>
<ul>
  <li>분할 정복과 큰 문제를 작은 문제로 나눠 계산하는 방식을 같다.</li>
  <li>그러나 하위 문제 중복 여부에 따라 다르다
    <ul>
      <li>분할 정복은 하위 문제가 중복이 일어나지 않을 때 사용</li>
      <li>DP는 하위 문제가 <strong>중복</strong>이 될 경우에 사용</li>
    </ul>
  </li>
</ul>

<h2 id="관련-문제">관련 문제</h2>

<ul>
  <li>
    <p><a href="https://www.acmicpc.net/problem/1003">1003번: 피보나치 함수</a> - 기본적인 피보나치 함수</p>
  </li>
  <li>
    <p><a href="https://www.acmicpc.net/problem/1149">1149번: RGB거리</a> - 조금 더 복잡한 DP 문제</p>
  </li>
  <li>
    <p><a href="https://www.acmicpc.net/problem/12865">12865번: 평범한 배낭</a> - 대표적인 DP 문제중 하나인 냅색(Knapsack) 문제</p>
  </li>
  <li>
    <p><a href="https://www.acmicpc.net/problem/2098">2098번: 외판원 순회</a> - 유명한 DP문제중 하나인 TSP 문제</p>
  </li>
</ul>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95">https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95</a>
<a href="https://80000coding.oopy.io/60c3d4d3-f569-4b47-bdde-9a65d30f3bc5">https://80000coding.oopy.io/60c3d4d3-f569-4b47-bdde-9a65d30f3bc5</a>
<a href="https://syujisu.tistory.com/entry/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-Dynamic-Programming%EA%B3%BC-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-Divide-and-Conquer-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">https://syujisu.tistory.com/entry/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-Dynamic-Programming%EA%B3%BC-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-Divide-and-Conquer-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="algorithm" /><category term="Algorithm" /><category term="DP" /><category term="Danamic Programming" /><summary type="html"><![CDATA[Dynamic Programming 다이나믹 프로그래밍이란 복잡한 문제를 여러개의 작은 문제로 나누고 값을 저장하여 푸는 방법을 말한다. 일반적으로 재귀 함수를 통해 이전 함수의 결과 값을 이용해 문제를 풀어나간다.]]></summary></entry><entry><title type="html">[C++] 백준 2629번-양팔저울</title><link href="http://localhost:4000/boj/BOJ-2629%EB%B2%88/" rel="alternate" type="text/html" title="[C++] 백준 2629번-양팔저울" /><published>2024-03-06T00:00:00+09:00</published><updated>2024-03-06T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ%202629%EB%B2%88</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2629%EB%B2%88/"><![CDATA[<p><a href="https://www.acmicpc.net/problem/2629">BOJ 2629-양팔저울</a></p>

<h2 id="문제">문제</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/b8f27588-2419-4e33-b6a8-55f07c43faea" alt="image" /></p>

<div class="code-block1">
예제 입력1
<div class="language-cpp highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code>2
1 4
2
3 2</code></pre></div></div></div>

<div class="code-block2">
에제 출력1
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>Y N</code></pre></div></div></div>

<div class="code-block1">
예제 입력2
<div class="language-cpp highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code>4
2 3 3 3
3
1 4 10</code></pre></div></div></div>

<div class="code-block2">
에제 출력2
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>Y Y N</code></pre></div></div></div>

<h2 id="풀이">풀이</h2>
<p>DP를 사용하여 푸는 문제다.</p>
<ul>
  <li>구슬의 무게 + 왼쪽 추의 무게합 = 우측 추의 무게 합 이 성립될 경우 Y를 출력하라는 문제이다.</li>
  <li>그렇기에 <strong>구슬 무게 = 우측 추의 무게합 - 왼쪽 추의 무게합</strong>이 점화식이다.</li>
  <li>추를 놓는 모든 경우의 수 중 <strong>우측 추의 무게합 - 왼쪽 추의 무게합</strong>이 존재 할 경우 해당 무게와 같은 무게인 구슬이 있으면 해당 구슬은 Y를 출력할 수 있다.</li>
  <li>모든 경우의 수를 탐색할 경우 시간 초과가 발생할 수 있으므로 flag[무게합][i번 째 추]에 체크해서 중복되는 경우는 넘기도록 한다.</li>
</ul>

<h2 id="소스코드">소스코드</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"bits/stdc++.h"</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">weights</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">beads</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">answer</span><span class="p">[</span><span class="mi">50001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">50001</span><span class="p">][</span><span class="mi">600</span><span class="p">];</span>


<span class="kt">int</span> <span class="nf">DP</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">50000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">answer</span><span class="p">[</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">flag</span><span class="p">[</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">weights</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">beads</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">answer</span><span class="p">[</span><span class="n">DP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">answer</span><span class="p">[</span><span class="n">beads</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Y "</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"N "</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Mohitto55</name></author><category term="boj" /><category term="boj" /><category term="백준" /><category term="solved" /><category term="문제풀이 2629번" /><category term="Dynamic Programming" /><category term="DP" /><summary type="html"><![CDATA[BOJ 2629-양팔저울]]></summary></entry><entry><title type="html">[UE5] Modifires로 여러 값 반환하기</title><link href="http://localhost:4000/ue5/UE5-Unhanced-Input-IMC-%EC%84%B8%EB%B6%80%EC%84%A4%EC%A0%95/" rel="alternate" type="text/html" title="[UE5] Modifires로 여러 값 반환하기" /><published>2024-03-04T00:00:00+09:00</published><updated>2024-03-04T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20Unhanced%20Input%20IMC%20%EC%84%B8%EB%B6%80%EC%84%A4%EC%A0%95</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-Unhanced-Input-IMC-%EC%84%B8%EB%B6%80%EC%84%A4%EC%A0%95/"><![CDATA[<h2 id="enhancedinput">EnhancedInput</h2>
<p>언리얼엔진5은 기존 InputSystem을 대체하는 Enhanced Input을 이용해 더 확장성 높고 사용하기 편한 입력 시스템을 만들었다. 이 시스템 중 <code class="language-plaintext highlighter-rouge">Input Mapping Context</code>는 하나 이상의 <code class="language-plaintext highlighter-rouge">Input Action</code>을 트리거 할 수 있게 해준다.</p>

<h3 id="mapping-context-설정">Mapping Context 설정</h3>
<p><code class="language-plaintext highlighter-rouge">Mapping Context</code>가 하는 일을 나열해 보자면</p>
<ul>
  <li>키 등록 - 어떤 키를 입력해야 <code class="language-plaintext highlighter-rouge">InputAction</code>이 실행되는지 설정</li>
  <li><code class="language-plaintext highlighter-rouge">Trigger</code> - 특정 키를 홀딩 등 키입력 조건을 설정</li>
  <li><code class="language-plaintext highlighter-rouge">Modifiers</code> - 반환 되는 값을 수정</li>
</ul>

<h2 id="하나의-액션으로-여러값-반환">하나의 액션으로 여러값 반환</h2>
<p>하나의 동작을 하는데 여러 종류의 반환 값이 필요한 경우가 있다. 예를 들면 <strong>이동</strong>이 있을 것이다. 이동은 상하좌우 총 <strong>4가지</strong> 종류의 행동을 할 수 있기에 4종류의 반환 값이 필요하다. 만약 InputAction을 4개를 만들어 각각 하나의 키를 맵핑 하는 방식으로 이동을 구현 한다면 상당히 번거로울 것이다.</p>

<p>하지만 <code class="language-plaintext highlighter-rouge">Modifiers</code>를 이용하면 하나의 <code class="language-plaintext highlighter-rouge">InputAction</code>으로 여러 값을 반환할 수 있다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">키</th>
      <th style="text-align: center">원하는 값</th>
      <th style="text-align: center">Modifire</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">w</td>
      <td style="text-align: center">(0, 1)</td>
      <td style="text-align: center">Swizzle Input Axis Values</td>
    </tr>
    <tr>
      <td style="text-align: center">A</td>
      <td style="text-align: center">(-1,0)</td>
      <td style="text-align: center">Negate</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">(0, -1)</td>
      <td style="text-align: center">Negate, Swizzle Input Axis Values</td>
    </tr>
    <tr>
      <td style="text-align: center">D</td>
      <td style="text-align: center">(1, 0)</td>
      <td style="text-align: center">None</td>
    </tr>
  </tbody>
</table>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/e65b77fc-c37f-487d-bb1f-74cd250c576d" alt="image" /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://docs.unrealengine.com/5.0/ko/enhanced-input-in-unreal-engine/">https://docs.unrealengine.com/5.0/ko/enhanced-input-in-unreal-engine/</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="Unrealengine5" /><category term="UE5" /><category term="EnhancedInput" /><category term="언리얼엔진5" /><summary type="html"><![CDATA[EnhancedInput 언리얼엔진5은 기존 InputSystem을 대체하는 Enhanced Input을 이용해 더 확장성 높고 사용하기 편한 입력 시스템을 만들었다. 이 시스템 중 Input Mapping Context는 하나 이상의 Input Action을 트리거 할 수 있게 해준다.]]></summary></entry><entry><title type="html">[Git] 100MB이상 커밋하기 Git-LFS</title><link href="http://localhost:4000/git/Git-LFS%EC%82%AC%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="[Git] 100MB이상 커밋하기 Git-LFS" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/git/Git%20LFS%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/git/Git-LFS%EC%82%AC%EC%9A%A9%EB%B2%95/"><![CDATA[<h2 id="문제-발생">문제 발생</h2>
<p>Github로 수정 내용을 저장소에 올리는 과정에서 특정 파일의 크기가 100MB가 넘어가면 Git에서 commit을 reject한다. 이를 해결 하기 위해선 100MB가 넘어가는 파일을 커밋하는 과정에서 <strong>제외</strong>하거나 <code class="language-plaintext highlighter-rouge">Git LFS</code>를 사용해야 한다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/d780856e-da75-4942-856c-fe6b9299c5ce" alt="image" /></p>

<h2 id="git-lfs">Git LFS</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/063e1bdd-53e2-4d4c-96a9-b65cddbac7b5" alt="image" /></p>

<p>LFS로 관리 받는 파일은 실제 리포지토리가 아닌 다른 저장소로 옮겨지고 실제 리포지토리는 메타데이터를 통해 다른 저장소에 있는 파일을 가리키는 방식으로 대용량 파일을 관리한다.</p>

<p>관리하는 파일 하나당 최대 크기가 있다. 해당 크기는 사용하는 GitHub Product에 따라 다르다.</p>

<table>
  <thead>
    <tr>
      <th>Product</th>
      <th>최대 파일 크기</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GitHub Free</td>
      <td>2GB</td>
    </tr>
    <tr>
      <td>GitHub Pro</td>
      <td>2GB</td>
    </tr>
    <tr>
      <td>GitHub Team</td>
      <td>4GB</td>
    </tr>
    <tr>
      <td>GitHub Enterprise Cloud</td>
      <td>5GB</td>
    </tr>
  </tbody>
</table>

<h2 id="사용법">사용법</h2>
<h3 id="1-관리파일-설정">1. 관리파일 설정</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git lfs install
$ git lfs track "파일명"
$ git lfs track "*.png"
</code></pre></div></div>
<p>lfs를 다운 받고 추적하려는 파일을 설정한다.</p>

<h3 id="2-gitattribute-파일-커밋">2. .gitattribute 파일 커밋</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git add .gitattribute
$ git commit -m "Add gitattribute"
$ git push -u origin main
</code></pre></div></div>
<p>파일을 track하면 <code class="language-plaintext highlighter-rouge">.gitattribute</code>라는 파일이 생성된다. 이 또한 커밋을 해줘야한다.</p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://oneseat.tistory.com/entry/Github%EC%97%90-100MB%EA%B0%80-%EB%84%98%EB%8A%94-%ED%8C%8C%EC%9D%BC%EC%9D%84-%EC%B6%94%EA%B0%80%ED%95%A0-%EB%95%8C-%EC%83%9D%EA%B8%B0%EB%8A%94-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0">https://oneseat.tistory.com/</a>
<a href="https://github.com/git-lfs/git-lfs">https://github.com/git-lfs/git-lfs</a>
<a href="https://docs.github.com/ko/repositories/working-with-files/managing-large-files/about-git-large-file-storage">https://docs.github.com/ko/repositories/working-with-files/managing-large-files/about-git-large-file-storage</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="git" /><category term="Git" /><category term="LFS" /><category term="Github" /><summary type="html"><![CDATA[문제 발생 Github로 수정 내용을 저장소에 올리는 과정에서 특정 파일의 크기가 100MB가 넘어가면 Git에서 commit을 reject한다. 이를 해결 하기 위해선 100MB가 넘어가는 파일을 커밋하는 과정에서 제외하거나 Git LFS를 사용해야 한다.]]></summary></entry><entry><title type="html">[CS] 짧은 순회 평가(Short circuit evaluation)</title><link href="http://localhost:4000/computerscience/CS-%EC%A7%A7%EC%9D%80-%EC%88%9C%ED%9A%8C-%ED%8F%89%EA%B0%80/" rel="alternate" type="text/html" title="[CS] 짧은 순회 평가(Short circuit evaluation)" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/CS%20%EC%A7%A7%EC%9D%80%20%EC%88%9C%ED%9A%8C%20%ED%8F%89%EA%B0%80</id><content type="html" xml:base="http://localhost:4000/computerscience/CS-%EC%A7%A7%EC%9D%80-%EC%88%9C%ED%9A%8C-%ED%8F%89%EA%B0%80/"><![CDATA[<h2 id="short-circuit-evaluation">Short circuit evaluation</h2>
<p>논리연산을 할 때 왼쪽 식부터 차례대로 논리평가를 하다가 만약 결과가 false일 경우 우측에 있는 식을 검증하지 않고 끝나는 것을 뜻한다. 왜 이런 것이 있을까 생각해보면 답은 간단하다. 이미 논리연산의 결과가 나왔기에 남은 논리평가를 실행할 이유가 없기 때문이다.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">){}</span>
</code></pre></div></div>
<p>v의 length가 0일경우 만약 우측 논리 평가를 한다면 에러가 나올 테지만 v[0]이 0일 경우 false가 되고 <strong>AND(&amp;&amp;)연산자</strong>라 우측이 true,false 뭐가 되든 false일 테니 우측은 볼필요 없기에 <strong>생략</strong>한다.</p>

<p>이렇듯 뒤의 계산의 결과 값이 어떻든 이미 값이 정해져서 논리평가를 생략하는 것이 <strong>짧은 순회 평가</strong>다.</p>

<hr />
<h3 id="발생하는-경우">발생하는 경우</h3>
<ul>
  <li>false <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> <font color="dodgerred">true or false</font></li>
  <li>true <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> true or false</li>
  <li>false <code class="language-plaintext highlighter-rouge">||</code> true or false</li>
  <li>true <code class="language-plaintext highlighter-rouge">||</code> <font color="dodgerred">true or false</font></li>
</ul>

<p>빨간색 포인트가 생략되는 부분이다.</p>

<div class="callout-warning-expanded">
<div class="callout-header">주의사항</div>
<p>
만약 생략되는 구간에 command 함수가 들어가면 함수가 실행이 되지 않아 로직이 깨지는 side effect가 생길 수 있다. 이런 경우는 if 문 안이 아닌 밖에서 따로 실행 해줘야 한다.
</p>
</div>
<hr />

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">https://en.wikipedia.org/wiki/Short-circuit_evaluation</a>
<a href="https://80000coding.oopy.io/2283e1be-93c5-4f00-ac7a-83bcb7dcad0d">https://80000coding.oopy.io/2283e1be-93c5-4f00-ac7a-83bcb7dcad0d</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="computerscience" /><category term="CS" /><category term="Short circuit evaluation" /><category term="짧은 순회 평가" /><summary type="html"><![CDATA[Short circuit evaluation 논리연산을 할 때 왼쪽 식부터 차례대로 논리평가를 하다가 만약 결과가 false일 경우 우측에 있는 식을 검증하지 않고 끝나는 것을 뜻한다. 왜 이런 것이 있을까 생각해보면 답은 간단하다. 이미 논리연산의 결과가 나왔기에 남은 논리평가를 실행할 이유가 없기 때문이다. if(v[0] != 0 &amp;&amp; v[3] == 5){} v의 length가 0일경우 만약 우측 논리 평가를 한다면 에러가 나올 테지만 v[0]이 0일 경우 false가 되고 AND(&amp;&amp;)연산자라 우측이 true,false 뭐가 되든 false일 테니 우측은 볼필요 없기에 생략한다.]]></summary></entry><entry><title type="html">[C++] 전방선언(Forward Declaration)</title><link href="http://localhost:4000/cpp/CPP-%EC%A0%84%EB%B0%A9%EC%84%A0%EC%96%B8/" rel="alternate" type="text/html" title="[C++] 전방선언(Forward Declaration)" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/cpp/CPP%20%EC%A0%84%EB%B0%A9%EC%84%A0%EC%96%B8</id><content type="html" xml:base="http://localhost:4000/cpp/CPP-%EC%A0%84%EB%B0%A9%EC%84%A0%EC%96%B8/"><![CDATA[<h2 id="전방선언">전방선언</h2>
<p>식별자를 정의하기 전 미리 식별자를 <strong>컴파일러</strong>에 알리는 것을 뜻한다.
원래는 식별자를 사용하기 위해선 정의된 헤더를 불러와야 하지만 전방선언(forward declaratioin)을 이용해 헤더를 선언하지 않아도 사용할 수 있다.</p>

<h2 id="사용법">사용법</h2>
<h3 id="클래스-타입-전방선언">클래스 타입 전방선언</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyObject</span><span class="p">;</span> <span class="c1">// 타입 전방선언</span>

<span class="n">MyObject</span><span class="o">*</span> <span class="n">ob1</span><span class="p">;</span>
</code></pre></div></div>
<p>타입이 클래스임을 알리는 전방선언(forward declaratioin)이다. 이렇게 헤더를 선언하지 않고 사용하는 것 이여서 <strong>포인터 객체</strong>만 이용 가능하다. 직접적인 함수를 이용하려 할 시 오류가 발생한다. 위에 이미 전방선언을 했다면 후에 같은 타입 클래스를 사용하면 전방선언을 해주지 않아도 된다.</p>

<ul>
  <li>헤더를 불러오는 시간이 줄어든다.
    <ul>
      <li>컴파일 단계에선 헤더 선언시 주석을 포함한 모드 코드를 불러옴</li>
    </ul>
  </li>
  <li>의존성이 줄어든다</li>
</ul>

<hr />
<h3 id="함수-전방선언">함수 전방선언</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// 함수 전방선언</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>만약 함수 전방선언을 하지 않고 코드를 실행할 시 main에서 add 함수를 실행하려 할 때 add 함수가 declaration 되어 있지 않다고 오류가 나올 것이다. 이는 C++가 위에서 부터 아래로 한줄 씩 코드를 읽는 <strong>컴파일 언어</strong>이기 때문에 발생하는 것인데 add함수는 아래에 정의(difinition)되어 있지만 main에서 사용할 때 까지 add 함수를 발견하지 못해서 발생하는 문제다.</p>

<p>그렇기에 위와 같이 전방선언을 통해서 컴파일러에 미리 알려주면 컴파일이 완료된다.</p>

<h2 id="summary">Summary</h2>
<ul>
  <li>타입 전방선언
    <ul>
      <li>헤더를 생략해 컴파일 속도 향상</li>
      <li>헤더 의존성 감소</li>
      <li>타입을 직접 사용하지 않는 경우에만 사용</li>
    </ul>
  </li>
  <li>함수 전방선언
    <ul>
      <li>함수를 미리 선언해 선언 위치에 따른 컴파일 오류 해결</li>
    </ul>
  </li>
</ul>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://boycoding.tistory.com/143">https://boycoding.tistory.com/143</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="cpp" /><category term="C++" /><category term="Forward Declaration" /><category term="전방선언" /><summary type="html"><![CDATA[전방선언 식별자를 정의하기 전 미리 식별자를 컴파일러에 알리는 것을 뜻한다. 원래는 식별자를 사용하기 위해선 정의된 헤더를 불러와야 하지만 전방선언(forward declaratioin)을 이용해 헤더를 선언하지 않아도 사용할 수 있다.]]></summary></entry><entry><title type="html">[C++] 백준 2665번-미로만들기</title><link href="http://localhost:4000/boj/BOJ-2665%EB%B2%88/" rel="alternate" type="text/html" title="[C++] 백준 2665번-미로만들기" /><published>2024-03-01T00:00:00+09:00</published><updated>2024-03-01T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ%202665%EB%B2%88</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2665%EB%B2%88/"><![CDATA[<p><a href="https://www.acmicpc.net/problem/2665">BOJ 2665-미로만들기</a></p>

<h2 id="문제">문제</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/9ade69c5-a7c6-407b-9652-6d181e5f0bd3" alt="image" /></p>

<div class="code-block1">
예제 입력
<div class="language-cpp highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code>8
11100110
11010010
10011010
11101100
01000111
00110001
11011000
11000111</code></pre></div></div></div>

<div class="code-block2">
에제 출력
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>2</code></pre></div></div></div>

<h2 id="풀이">풀이</h2>
<p>BFS를 사용하여 풀었다.</p>
<ol>
  <li>board의 맵을 저장하고 flag는 방문 시 가장 적은 횟수로 벽을 부셨던 경우다.</li>
  <li>queue에 좌표(x,y)와 부순 횟수(c)를 담는다.</li>
  <li>queue를 탐색하고 현재 탐색 노드의 flag값보다 c가 크면 다음으로 넘어간다.</li>
  <li>도착지점이면 답을 갱신한다.</li>
  <li>주변 4개의 타일을 큐에 삽입한다.</li>
</ol>

<h2 id="소스코드">소스코드</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"bits/stdc++.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define MAX 10000000
</span>
<span class="kt">int</span> <span class="n">dx</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">dy</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span> <span class="p">};</span>

<span class="kt">int</span> <span class="n">board</span><span class="p">[</span><span class="mi">51</span><span class="p">][</span><span class="mi">51</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">51</span><span class="p">][</span><span class="mi">51</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">InMap</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">BFS</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">queue</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span> <span class="p">});</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
		<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
		<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>

		<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InMap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="n">answer</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="n">flag</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">answer</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="kt">int</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span> <span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">c</span> <span class="p">});</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">answer</span> <span class="o">==</span> <span class="n">MAX</span><span class="p">)</span>
		<span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">board</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="sc">'0'</span><span class="p">);</span>
			<span class="n">flag</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">BFS</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Mohitto55</name></author><category term="boj" /><category term="boj" /><category term="백준" /><category term="solved" /><category term="문제풀이 2665번" /><summary type="html"><![CDATA[BOJ 2665-미로만들기]]></summary></entry></feed>