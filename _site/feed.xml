<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-07-08T23:30:11+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mohitto55 Note</title><subtitle>모히또의 노트</subtitle><author><name>Mohitto55</name></author><entry><title type="html">[Network] REST와 REST API</title><link href="http://localhost:4000/network/NETWORK-REST%EC%99%80-REST-API/" rel="alternate" type="text/html" title="[Network] REST와 REST API" /><published>2025-07-08T00:00:00+09:00</published><updated>2025-07-08T00:00:00+09:00</updated><id>http://localhost:4000/network/%5BNETWORK%5DREST%EC%99%80%20REST%20API</id><content type="html" xml:base="http://localhost:4000/network/NETWORK-REST%EC%99%80-REST-API/"><![CDATA[<h1 id="rest">REST</h1>

<ul>
  <li>Representational State Transfer의 약자로 소프트웨어 프로그램 아키텍처 중 하나입니다.</li>
  <li>자원을 이름으로 구분하여 자원의 상태를 주고 받는 방식을 말합니다.</li>
</ul>

<h2 id="rest의-구성-3가지">REST의 구성 3가지</h2>

<ul>
  <li><strong>자원(Resource)</strong>: 웹에서 다루는 대상 데이터 (예: 사용자, 게시글, 상품 등)을 HTTP URI를 통해 를 명시합니다.
    <ul>
      <li>ex) <a href="https://api.example.com/users/123">https://api.example.com/users/123</a></li>
    </ul>
  </li>
  <li><strong>HTTP Method:</strong> POST, GET, PUT, DELETE, PATCH등 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미합니다.</li>
  <li><strong>메세지</strong>: 클라이언트가 서버에 요청하거나, 서버가 클라이언트에 응답할 때 주고받는 <strong>데이터(payload)</strong> 를 의미합니다.
    <ul>
      <li>보통 JSON이나 XML 형태로 보내는 내용입니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="crud-operation이란">CRUD Operation이란</h3>

<p>CRUD는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말로 REST에서의 CRUD Operation 동작 예시는 다음과 같다.</p>

<blockquote>
  <p>Create : 데이터 생성(POST)<br />
Read : 데이터 조회(GET)<br />
Update : 데이터 수정(PUT, PATCH)<br />
Delete : 데이터 삭제(DELETE)</p>
</blockquote>

<h2 id="rest-특징">REST 특징</h2>

<ul>
  <li><strong>Stateless</strong>
    <ul>
      <li>각 요청은 독립적이고, 서버는 이전 요청 상태를 기억하지 않습니다. (이전 상태를 저장하지 않습니다.)</li>
    </ul>
  </li>
  <li><strong>일관된 인터페이스</strong>
    <ul>
      <li>URL을 활용해 자원을 명시합니다.</li>
      <li>CRUD로 행위를 표현합니다.</li>
    </ul>
  </li>
  <li><strong>계층화된 시스템 (Layered System)</strong>
    <ul>
      <li>클라이언트는 중간 서버(예: 프록시, 로드 밸런서)를 인식하지 못합니다.</li>
      <li>구조를 여러 계층으로 나눠 확장성과 보안 향상합니다.</li>
    </ul>
  </li>
  <li><strong>온디멘드 코드</strong>
    <ul>
      <li>서버가 클라이언트에게 실행 가능한 코드를 전달 가능합니다.</li>
    </ul>
  </li>
</ul>

<h1 id="rest-api">REST API</h1>

<p>REST 아키텍처를 따르는 API입니다. 즉, 웹 주소(URL)로 특정 데이터를 가리키고, HTTP 메서드(GET, POST 등)를 써서 그 데이터에 대해 필요한 작업을 요청하는 방식입니다.</p>

<hr />

<h3 id="rest-api-장점">REST API 장점</h3>
<ul>
  <li>직관적이라 누구나 쉽게 이해하고 사용할 수 있습니다. URL만 보면 어디에 무슨 데이터가 있는지 알 수 있고, HTTP 메서드도 조회는 GET, 생성은 POST로 명확히 정해져 있습니다.</li>
  <li>클라이언트와 서버 역할이 분리되어 따로 개발하거나 수정해도 문제가 생기지 않습니다.</li>
  <li>큰 서비스에도 확장성이 좋고 유지보수가 편합니다.</li>
  <li>표준화되어 있어서 모바일, 웹, 다른 서버와도 쉽게 연결할 수 있습니다.</li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://kks2140501.tistory.com/48">https://kks2140501.tistory.com/48</a>
<a href="https://aws.amazon.com/ko/what-is/restful-api/">https://aws.amazon.com/ko/what-is/restful-api/</a>
<a href="https://creamilk88.tistory.com/184">https://creamilk88.tistory.com/184</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="network" /><category term="Network" /><category term="TCPIP" /><category term="REST" /><category term="REST API" /><category term="API" /><summary type="html"><![CDATA[REST]]></summary></entry><entry><title type="html">[UE5] Async Loading Widget 만드는 과정</title><link href="http://localhost:4000/ue5/UE5-Loading-Widget-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%B3%B5%EC%82%AC%EB%B3%B8/" rel="alternate" type="text/html" title="[UE5] Async Loading Widget 만드는 과정" /><published>2025-05-23T00:00:00+09:00</published><updated>2025-05-23T00:00:00+09:00</updated><id>http://localhost:4000/ue5/%5BUE5%5D%20Loading%20Widget%20%EB%A7%8C%EB%93%9C%EB%8A%94%20%EB%B0%A9%EB%B2%95%20-%20%EB%B3%B5%EC%82%AC%EB%B3%B8</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-Loading-Widget-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%B3%B5%EC%82%AC%EB%B3%B8/"><![CDATA[<p>게임에서 로딩화면이란 정말 중요하다. 화면전환시 플레이어가 어색함없이<br />
언리얼엔진에서 레벨을 이동할땐 OpenLevel 함수를 사용한다. 사용하면 다른 레벨로 이동하지만 이동하는 과정에서 끊김 현상이 발생한다. 이런 끊김 현상이 느껴지지 않도록 만들어야한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">static</span> <span class="n">ENGINE_API</span> <span class="kt">void</span> <span class="nf">OpenLevelBySoftObjectPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">UObject</span><span class="o">*</span> <span class="n">WorldContextObject</span><span class="p">,</span> <span class="k">const</span> <span class="n">TSoftObjectPtr</span><span class="o">&lt;</span><span class="n">UWorld</span><span class="o">&gt;</span> <span class="n">Level</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bAbsolute</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">FString</span> <span class="n">Options</span> <span class="o">=</span> <span class="n">FString</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">""</span><span class="p">)));</span>
</code></pre></div></div>

<h2 id="목표">목표</h2>
<p>1.페이드 인, 아웃으로 부드러운 로딩 화면 재생<br />
2.비동기적으로 레벨의 완전한 로딩 타이밍 확인<br />
3.완전히 다른 레벨 이동시 로딩화면 유지</p>

<hr />

<p>검색을 통해 알아보니 로딩화면을 만드는데는 크게 두가지 방식이 있었다.</p>
<ol>
  <li>로딩 위젯 생성 후 OpenLevel 시작</li>
  <li>LoadStreamLevel로 서브 레벨로딩과 완료되면 로딩 위젯 제거</li>
</ol>

<p>1번의 경우 페이드 인아웃 애니메이션이 없이 이미지가 바로 생겻다 사라진다. 그리고 이전 레벨에서 생성한 위젯이 이동한 레벨에서 보이지 않는다.<br />
2번은 비동기적으로 레벨이 완전히 로드되는 타이밍은 알 수 있지만 서브레벨을 불러오는 방식에서만 유효하고 타이틀레벨, 게임레벨 같이 완전히 다른 레벨에선 적용되지 않는다.</p>

<p>결국 OpenLevel함수를 사용해야 하므로 레벨 로드시 위젯이 사라지지 않게하고 레벨이 완전히 로드되었을때 로딩 위젯의 종료 애니메이션을 실행시킨다.</p>

<h3 id="위젯이-사라지는-조건">위젯이 사라지는 조건</h3>
<p>위젯은 GetWorld()를 통해 나오는 Level이 사라지면 자신도 사라진다.<br />
Widget의 GetWrold는 보통의 경우 CreateWidget으로 생성할 때 지정한 out의 GetWorld와 같다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UWorld</span><span class="o">*</span> <span class="n">UUserWidget</span><span class="o">::</span><span class="n">GetWorld</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">UWorld</span><span class="o">*</span> <span class="n">LastWorld</span> <span class="o">=</span> <span class="n">CachedWorld</span><span class="p">.</span><span class="n">Get</span><span class="p">()</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">LastWorld</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">HasAllFlags</span><span class="p">(</span><span class="n">RF_ClassDefaultObject</span><span class="p">)</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// If we are a CDO, we must return nullptr instead of calling Outer-&gt;GetWorld() to fool UObject::ImplementsGetWorld.</span>
		<span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Use the Player Context's world, if a specific player context is given, otherwise fall back to</span>
	<span class="c1">// following the outer chain.</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">PlayerContext</span><span class="p">.</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">UWorld</span><span class="o">*</span> <span class="n">World</span> <span class="o">=</span> <span class="n">PlayerContext</span><span class="p">.</span><span class="n">GetWorld</span><span class="p">()</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">CachedWorld</span> <span class="o">=</span> <span class="n">World</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">World</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Could be a GameInstance, could be World, could also be a WidgetTree, so we're just going to follow</span>
	<span class="c1">// the outer chain to find the world we're in.</span>
	<span class="n">UObject</span><span class="o">*</span> <span class="n">Outer</span> <span class="o">=</span> <span class="n">GetOuter</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span> <span class="n">Outer</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">UWorld</span><span class="o">*</span> <span class="n">World</span> <span class="o">=</span> <span class="n">Outer</span><span class="o">-&gt;</span><span class="n">GetWorld</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">World</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">CachedWorld</span> <span class="o">=</span> <span class="n">World</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">World</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">Outer</span> <span class="o">=</span> <span class="n">Outer</span><span class="o">-&gt;</span><span class="n">GetOuter</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>그렇다면 적절한 OwingObject의 클래스는 어떻게 정할까? CreateWidget 함수를 보면 알 수 있다. `static_assert(TIsDerivedFrom&lt;TPointedToType<OwnerType>
 .. 하는 부분을 보면 UWidget, UWidgetTree, APlayerController, UGameInstance, UWorld 가 Outer로 지정가능하다. 레벨이 이동해도 사라지지 않는 UGameInstance가 적절하다.</OwnerType></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">WidgetT</span> <span class="o">=</span> <span class="n">UUserWidget</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OwnerType</span> <span class="o">=</span> <span class="n">UObject</span><span class="p">&gt;</span>
<span class="n">WidgetT</span><span class="o">*</span> <span class="nf">CreateWidget</span><span class="p">(</span><span class="n">OwnerType</span> <span class="n">OwningObject</span><span class="p">,</span> <span class="n">TSubclassOf</span><span class="o">&lt;</span><span class="n">UUserWidget</span><span class="o">&gt;</span> <span class="n">UserWidgetClass</span> <span class="o">=</span> <span class="n">WidgetT</span><span class="o">::</span><span class="n">StaticClass</span><span class="p">(),</span> <span class="n">FName</span> <span class="n">WidgetName</span> <span class="o">=</span> <span class="n">NAME_None</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static_assert</span><span class="p">(</span><span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">WidgetT</span><span class="p">,</span> <span class="n">UUserWidget</span><span class="o">&gt;::</span><span class="n">IsDerived</span><span class="p">,</span> <span class="s">"CreateWidget can only be used to create UserWidget instances. If creating a UWidget, use WidgetTree::ConstructWidget."</span><span class="p">);</span>
	
	<span class="k">static_assert</span><span class="p">(</span><span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UWidget</span><span class="o">&gt;::</span><span class="n">IsDerived</span>
		<span class="o">||</span> <span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UWidgetTree</span><span class="o">&gt;::</span><span class="n">IsDerived</span>
		<span class="o">||</span> <span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">APlayerController</span><span class="o">&gt;::</span><span class="n">IsDerived</span>
		<span class="o">||</span> <span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UGameInstance</span><span class="o">&gt;::</span><span class="n">IsDerived</span>
		<span class="o">||</span> <span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UWorld</span><span class="o">&gt;::</span><span class="n">IsDerived</span><span class="p">,</span> <span class="s">"The given OwningObject is not of a supported type for use with CreateWidget."</span><span class="p">);</span>

	<span class="n">SCOPE_CYCLE_COUNTER</span><span class="p">(</span><span class="n">STAT_CreateWidget</span><span class="p">);</span>
	<span class="n">FScopeCycleCounterUObject</span> <span class="n">WidgetObjectCycleCounter</span><span class="p">(</span><span class="n">UserWidgetClass</span><span class="p">,</span> <span class="n">GET_STATID</span><span class="p">(</span><span class="n">STAT_CreateWidget</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">OwningObject</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">WidgetT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UUserWidget</span><span class="o">::</span><span class="n">CreateWidgetInstance</span><span class="p">(</span><span class="o">*</span><span class="n">OwningObject</span><span class="p">,</span> <span class="n">UserWidgetClass</span><span class="p">,</span> <span class="n">WidgetName</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">LoadWidget</span> <span class="o">=</span> <span class="n">CreateWidget</span><span class="o">&lt;</span><span class="n">ULoadingWidget</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetGameInstance</span><span class="p">(),</span> <span class="n">ScenarioSetting</span><span class="p">.</span><span class="n">LoadingWidgetRef</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="오프레벨-타이밍-잡기">오프레벨 타이밍 잡기</h2>
<p>레벨 이동시 로딩 위젯의 종료 애니메이션을 실행시킬 타이밍은 레벨이 완전히 로드됐을때 하면 된다. 이 타이밍에 실행되는 전역 델리게이트들이 존재한다.</p>

<p>그것들 중에서 이 조건에 맞는 델리게이트를 선택할 것이다.</p>
<ol>
  <li>Subsystem의 Initlization보다 빨라야한다.</li>
  <li>Widget의 Contrturc보다 느려야한다.<br />
 2-1. Widget Blueprint에서 수정해야 하기 때문이다.</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FCoreUObjectDelegates</span><span class="o">::</span><span class="n">PostLoadMapWithWorld</span><span class="p">.</span><span class="n">AddUObject</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnPostLoadMap</span><span class="p">);</span>
<span class="n">FWorldDelegates</span><span class="o">::</span><span class="n">OnPostWorldInitialization</span><span class="p">.</span><span class="n">AddUObject</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnPostWorldInitialization</span><span class="p">);</span>
<span class="n">FWorldDelegates</span><span class="o">::</span><span class="n">OnWorldInitializedActors</span><span class="p">.</span><span class="n">AddUObject</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnWorldInitializedActors</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="subsytem의-init-시작">Subsytem의 Init 시작</h3>
<p>PostLoadMapWithWorld 만 탐지 되지 않았다.<br />
<img src="https://github.com/user-attachments/assets/1c7f69c0-c447-4c3d-8e13-6b3cb691650c" alt="Image" /></p>

<h3 id="open-level-후">Open Level 후</h3>
<p>PostLoadMapWithWorld , OnWorldInitializedActors가  Construct 뒤에 실행된다.<br />
<img src="https://github.com/user-attachments/assets/ce5e5a6b-4b81-4f0a-9f17-3a82ece790db" alt="Image" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">FSubsystemCollectionBase</span><span class="o">&amp;</span> <span class="n">Collection</span><span class="p">)</span>
        <span class="n">LoadWidget</span> <span class="o">=</span> <span class="n">CreateWidget</span><span class="o">&lt;</span><span class="n">ULoadingWidget</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetGameInstance</span><span class="p">(),</span> <span class="n">ScenarioSetting</span><span class="p">.</span><span class="n">LoadingWidgetRef</span><span class="p">);</span>
        <span class="n">FCoreUObjectDelegates</span><span class="o">::</span><span class="n">PostLoadMapWithWorld</span><span class="p">.</span><span class="n">AddUObject</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnPostLoadMap</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnPostLoadMap</span><span class="p">(</span><span class="n">UWorld</span><span class="o">*</span> <span class="n">World</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LoadWidget</span><span class="o">-&gt;</span><span class="n">AddToViewport</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">LoadWidget</span><span class="o">-&gt;</span><span class="n">DeactivateSequence</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>
<p>
모션매칭을 이용한 애니메이션 제작은 기존 방식과 큰 차이가 있다. 모션 매칭의 주요 특징으로는 다음과 같다.<br />
<font color="dodgerred">1. 데이터 기반 접근</font>: 모션 매칭은 대규모의 캡처된 애니메이션 데이터베이스를 활용합니다.<br />
<font color="dodgerred">2. 실시간 검색</font>: 게임 내 캐릭터의 현재 모션 정보를 키로 사용하여 데이터베이스에서 가장 적합한 애니메이션을 실시간으로 검색합니다.<br />
<font color="dodgerred">3. 자연스러운 전환</font>: 복잡한 로직 없이도 다양한 애니메이션 클립 간의 자연스러운 전환이 가능합니다.<br />
<font color="dodgerred">4. 확장성</font>: 애니메이션 기능을 위한 확장 가능한 프레임워크를 제공합니다.<br />
</p>

<p><br /><br />
기존에는 특정 조건에 맞는 애니메이션을 하나하나 직접 설정해줘야 했지만 모션 매칭은 데이터 기반으로 현재 상태에서 가장 적합한 애니메이션을 자연스럽게 자동으로 설정해준다.</p>

<p><br /></p>
<h1 id="모션매칭-사전준비">모션매칭 사전준비</h1>
<h2 id="플러그인-설치">플러그인 설치</h2>
<ul>
  <li>아래 두 플러그인 설치하고 다시 시작한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/dbc4cc87-7a25-4b1d-ba26-266c97506563" alt="image" /><br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/7e725cda-a1ba-4064-a128-da6e780383ce" alt="image" /></li>
</ul>

<h2 id="애니메이션-시퀀스들-준비하기">애니메이션 시퀀스들 준비하기</h2>
<h3 id="모션-매칭-스키마-생성">모션 매칭 스키마 생성</h3>
<ul>
  <li>접두사는 PSS_</li>
  <li>각도 회전 값등 변수 설정하는 애셋이다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/331aea83-d937-4559-845f-ecc26b726c6c" alt="image" /></li>
</ul>

<hr />

<h3 id="database-생성">Database 생성</h3>
<ul>
  <li>
    <p>모션 매칭에 사용될 애니메이션들을 담는 데이터를 생성한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/6c101550-6a54-4a12-a0b9-da28e1352eeb" alt="image" /></p>
  </li>
  <li>적용할 스키마를 선택한다.</li>
  <li>접두사는 PSD_<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/04961922-19f6-47d4-88e8-5692eacf7047" alt="image" /></li>
</ul>

<hr />

<h4 id="psddatabase-화면">PSD(Database) 화면</h4>
<ul>
  <li>이제 여기에 사용할 애니메이션을 드래그 하면된다.</li>
  <li>그전에 <strong>루트모션</strong>을 사용 중인지 확인 해야한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/896d1c75-1c1b-4a07-b845-d8cf73b2a123" alt="image" /></li>
</ul>

<hr />

<h4 id="애니메이션-한번에-수정하기">애니메이션 한번에 수정하기</h4>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/5e49972c-c46e-436e-90dd-29f8af77b1ee" alt="image" /></p>

<ul>
  <li>컨트롤 a를 눌러 모두 선택후 EnableRootMotion을 활성화 한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/e10b9b6c-489e-4f8f-af60-5610d371c867" alt="image" /></li>
</ul>

<hr />

<h4 id="locomotion-psd-생성하기">Locomotion PSD 생성하기</h4>
<ul>
  <li>DB에서 애니메이션을 넣는다.</li>
  <li>각각 상하좌우 방향으로 시작, 진행 중, 멈출 때 해당하는 Walk 모션을 넣어준다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/36724702-59f2-4684-a817-0ae49418333f" alt="image" /></li>
</ul>

<p><br /></p>

<h1 id="모션매칭-활용하기">모션매칭 활용하기</h1>
<h2 id="abp-설정하기">ABP 설정하기</h2>
<ul>
  <li>Motion Matching 노드를 불러와 모션매칭 DataBase를 가져온다.</li>
  <li>그리고 현재 애니메이션에서 추적하기 위해 Trajectory(궤적)을 불러와야 한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/6c49c019-d49b-4f55-af2a-4ab987c59842" alt="image" /></li>
</ul>

<hr />

<h3 id="trajectory-컴포넌트-설치하기">Trajectory 컴포넌트 설치하기</h3>
<ul>
  <li>ABP를 사용할 BP에서 <code class="language-plaintext highlighter-rouge">Character Trajectory</code> 컴포넌트를 부착한다.</li>
</ul>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/31db32d6-577e-49b2-9075-bc079c638a43" alt="image" /></p>

<hr />

<h3 id="trajectory-정보-가져오기">Trajectory 정보 가져오기</h3>
<ul>
  <li>ABP와 BP의 Trajectory를 연결해야한다.</li>
  <li>그렇기 위해선 ABP의 EventGraph에서 자신을 사용하는 BP를 가져와야 한다.</li>
  <li>
    <p>자신을 사용중인 Actor를 가져와 그 액터 BP를 변수로 설정한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/128cb3a3-5f92-4268-a926-57aeb39bb0dd" alt="image" /></p>
  </li>
  <li>
    <p>변수화한 Owner Actor를 불러와 Trajectory를 매 프레임마다 변수화 시킨다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/c697f497-df56-46d3-bed8-1bb8e34fdb2f" alt="image" /></p>
  </li>
  <li>그리고 다시 AnimGraph로 돌아가서 Trajectory를 설정해준다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/a5b14922-a3a4-4367-b352-58a285a1615d" alt="image" /></li>
</ul>

<h2 id="디버깅-궤적-확인">디버깅 궤적 확인</h2>
<ul>
  <li>콘솔창에 <code class="language-plaintext highlighter-rouge">a.CharacterTrajectory.Debug 1</code> 을 하면 궤적이 보인다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/592c0d2d-152c-4334-864a-909b3613afec" alt="image" /></li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://www.youtube.com/watch?v=4ag7fSlEeKA">https://www.youtube.com/watch?v=4ag7fSlEeKA</a>
<a href="https://www.youtube.com/watch?v=S4aBd64t-hY&amp;ab_channel=GorkaGames">https://www.youtube.com/watch?v=S4aBd64t-hY&amp;ab_channel=GorkaGames</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="UnrealEngine" /><category term="Loading" /><category term="UserWidget" /><category term="Widget" /><summary type="html"><![CDATA[게임에서 로딩화면이란 정말 중요하다. 화면전환시 플레이어가 어색함없이 언리얼엔진에서 레벨을 이동할땐 OpenLevel 함수를 사용한다. 사용하면 다른 레벨로 이동하지만 이동하는 과정에서 끊김 현상이 발생한다. 이런 끊김 현상이 느껴지지 않도록 만들어야한다.]]></summary></entry><entry><title type="html">[UE5] Async Loading Widget 만드는 과정</title><link href="http://localhost:4000/ue5/UE5-Loading-Widget-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95/" rel="alternate" type="text/html" title="[UE5] Async Loading Widget 만드는 과정" /><published>2025-05-23T00:00:00+09:00</published><updated>2025-05-23T00:00:00+09:00</updated><id>http://localhost:4000/ue5/%5BUE5%5D%20Loading%20Widget%20%EB%A7%8C%EB%93%9C%EB%8A%94%20%EB%B0%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-Loading-Widget-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95/"><![CDATA[<p>게임에서 로딩화면이란 정말 중요하다. 화면전환시 플레이어가 어색함없이<br />
언리얼엔진에서 레벨을 이동할땐 OpenLevel 함수를 사용한다. 사용하면 다른 레벨로 이동하지만 이동하는 과정에서 끊김 현상이 발생한다. 이런 끊김 현상이 느껴지지 않도록 만들어야한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">static</span> <span class="n">ENGINE_API</span> <span class="kt">void</span> <span class="nf">OpenLevelBySoftObjectPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">UObject</span><span class="o">*</span> <span class="n">WorldContextObject</span><span class="p">,</span> <span class="k">const</span> <span class="n">TSoftObjectPtr</span><span class="o">&lt;</span><span class="n">UWorld</span><span class="o">&gt;</span> <span class="n">Level</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bAbsolute</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">FString</span> <span class="n">Options</span> <span class="o">=</span> <span class="n">FString</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">""</span><span class="p">)));</span>
</code></pre></div></div>

<h2 id="목표">목표</h2>
<p>1.페이드 인, 아웃으로 부드러운 로딩 화면 재생<br />
2.비동기적으로 레벨의 완전한 로딩 타이밍 확인<br />
3.완전히 다른 레벨 이동시 로딩화면 유지</p>

<hr />

<p>검색을 통해 알아보니 로딩화면을 만드는데는 크게 두가지 방식이 있었다.</p>
<ol>
  <li>로딩 위젯 생성 후 OpenLevel 시작</li>
  <li>LoadStreamLevel로 서브 레벨로딩과 완료되면 로딩 위젯 제거</li>
</ol>

<p>1번의 경우 페이드 인아웃 애니메이션이 없이 이미지가 바로 생겻다 사라진다. 그리고 이전 레벨에서 생성한 위젯이 이동한 레벨에서 보이지 않는다.<br />
2번은 비동기적으로 레벨이 완전히 로드되는 타이밍은 알 수 있지만 서브레벨을 불러오는 방식에서만 유효하고 타이틀레벨, 게임레벨 같이 완전히 다른 레벨에선 적용되지 않는다.</p>

<p>결국 OpenLevel함수를 사용해야 하므로 레벨 로드시 위젯이 사라지지 않게하고 레벨이 완전히 로드되었을때 로딩 위젯의 종료 애니메이션을 실행시킨다.</p>

<h3 id="위젯이-사라지는-조건">위젯이 사라지는 조건</h3>
<p>위젯은 GetWorld()를 통해 나오는 Level이 사라지면 자신도 사라진다.<br />
Widget의 GetWrold는 보통의 경우 CreateWidget으로 생성할 때 지정한 out의 GetWorld와 같다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UWorld</span><span class="o">*</span> <span class="n">UUserWidget</span><span class="o">::</span><span class="n">GetWorld</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">UWorld</span><span class="o">*</span> <span class="n">LastWorld</span> <span class="o">=</span> <span class="n">CachedWorld</span><span class="p">.</span><span class="n">Get</span><span class="p">()</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">LastWorld</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">HasAllFlags</span><span class="p">(</span><span class="n">RF_ClassDefaultObject</span><span class="p">)</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// If we are a CDO, we must return nullptr instead of calling Outer-&gt;GetWorld() to fool UObject::ImplementsGetWorld.</span>
		<span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Use the Player Context's world, if a specific player context is given, otherwise fall back to</span>
	<span class="c1">// following the outer chain.</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">PlayerContext</span><span class="p">.</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">UWorld</span><span class="o">*</span> <span class="n">World</span> <span class="o">=</span> <span class="n">PlayerContext</span><span class="p">.</span><span class="n">GetWorld</span><span class="p">()</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">CachedWorld</span> <span class="o">=</span> <span class="n">World</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">World</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Could be a GameInstance, could be World, could also be a WidgetTree, so we're just going to follow</span>
	<span class="c1">// the outer chain to find the world we're in.</span>
	<span class="n">UObject</span><span class="o">*</span> <span class="n">Outer</span> <span class="o">=</span> <span class="n">GetOuter</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span> <span class="n">Outer</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">UWorld</span><span class="o">*</span> <span class="n">World</span> <span class="o">=</span> <span class="n">Outer</span><span class="o">-&gt;</span><span class="n">GetWorld</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">World</span> <span class="p">)</span>
		<span class="p">{</span>
			<span class="n">CachedWorld</span> <span class="o">=</span> <span class="n">World</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">World</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">Outer</span> <span class="o">=</span> <span class="n">Outer</span><span class="o">-&gt;</span><span class="n">GetOuter</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>그렇다면 적절한 OwingObject의 클래스는 어떻게 정할까? CreateWidget 함수를 보면 알 수 있다. `static_assert(TIsDerivedFrom&lt;TPointedToType<OwnerType>
 .. 하는 부분을 보면 UWidget, UWidgetTree, APlayerController, UGameInstance, UWorld 가 Outer로 지정가능하다. 레벨이 이동해도 사라지지 않는 UGameInstance가 적절하다.</OwnerType></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">WidgetT</span> <span class="o">=</span> <span class="n">UUserWidget</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OwnerType</span> <span class="o">=</span> <span class="n">UObject</span><span class="p">&gt;</span>
<span class="n">WidgetT</span><span class="o">*</span> <span class="nf">CreateWidget</span><span class="p">(</span><span class="n">OwnerType</span> <span class="n">OwningObject</span><span class="p">,</span> <span class="n">TSubclassOf</span><span class="o">&lt;</span><span class="n">UUserWidget</span><span class="o">&gt;</span> <span class="n">UserWidgetClass</span> <span class="o">=</span> <span class="n">WidgetT</span><span class="o">::</span><span class="n">StaticClass</span><span class="p">(),</span> <span class="n">FName</span> <span class="n">WidgetName</span> <span class="o">=</span> <span class="n">NAME_None</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static_assert</span><span class="p">(</span><span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">WidgetT</span><span class="p">,</span> <span class="n">UUserWidget</span><span class="o">&gt;::</span><span class="n">IsDerived</span><span class="p">,</span> <span class="s">"CreateWidget can only be used to create UserWidget instances. If creating a UWidget, use WidgetTree::ConstructWidget."</span><span class="p">);</span>
	
	<span class="k">static_assert</span><span class="p">(</span><span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UWidget</span><span class="o">&gt;::</span><span class="n">IsDerived</span>
		<span class="o">||</span> <span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UWidgetTree</span><span class="o">&gt;::</span><span class="n">IsDerived</span>
		<span class="o">||</span> <span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">APlayerController</span><span class="o">&gt;::</span><span class="n">IsDerived</span>
		<span class="o">||</span> <span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UGameInstance</span><span class="o">&gt;::</span><span class="n">IsDerived</span>
		<span class="o">||</span> <span class="n">TIsDerivedFrom</span><span class="o">&lt;</span><span class="n">TPointedToType</span><span class="o">&lt;</span><span class="n">OwnerType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UWorld</span><span class="o">&gt;::</span><span class="n">IsDerived</span><span class="p">,</span> <span class="s">"The given OwningObject is not of a supported type for use with CreateWidget."</span><span class="p">);</span>

	<span class="n">SCOPE_CYCLE_COUNTER</span><span class="p">(</span><span class="n">STAT_CreateWidget</span><span class="p">);</span>
	<span class="n">FScopeCycleCounterUObject</span> <span class="n">WidgetObjectCycleCounter</span><span class="p">(</span><span class="n">UserWidgetClass</span><span class="p">,</span> <span class="n">GET_STATID</span><span class="p">(</span><span class="n">STAT_CreateWidget</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">OwningObject</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">WidgetT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UUserWidget</span><span class="o">::</span><span class="n">CreateWidgetInstance</span><span class="p">(</span><span class="o">*</span><span class="n">OwningObject</span><span class="p">,</span> <span class="n">UserWidgetClass</span><span class="p">,</span> <span class="n">WidgetName</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">LoadWidget</span> <span class="o">=</span> <span class="n">CreateWidget</span><span class="o">&lt;</span><span class="n">ULoadingWidget</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetGameInstance</span><span class="p">(),</span> <span class="n">ScenarioSetting</span><span class="p">.</span><span class="n">LoadingWidgetRef</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="오프레벨-타이밍-잡기">오프레벨 타이밍 잡기</h2>
<p>레벨 이동시 로딩 위젯의 종료 애니메이션을 실행시킬 타이밍은 레벨이 완전히 로드됐을때 하면 된다. 이 타이밍에 실행되는 전역 델리게이트들이 존재한다.</p>

<p>그것들 중에서 이 조건에 맞는 델리게이트를 선택할 것이다.</p>
<ol>
  <li>Subsystem의 Initlization보다 빨라야한다.</li>
  <li>Widget의 Contrturc보다 느려야한다.<br />
 2-1. Widget Blueprint에서 수정해야 하기 때문이다.</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FCoreUObjectDelegates</span><span class="o">::</span><span class="n">PostLoadMapWithWorld</span><span class="p">.</span><span class="n">AddUObject</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnPostLoadMap</span><span class="p">);</span>
<span class="n">FWorldDelegates</span><span class="o">::</span><span class="n">OnPostWorldInitialization</span><span class="p">.</span><span class="n">AddUObject</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnPostWorldInitialization</span><span class="p">);</span>
<span class="n">FWorldDelegates</span><span class="o">::</span><span class="n">OnWorldInitializedActors</span><span class="p">.</span><span class="n">AddUObject</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnWorldInitializedActors</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="subsytem의-init-시작">Subsytem의 Init 시작</h3>
<p>PostLoadMapWithWorld 만 탐지 되지 않았다.<br />
<img src="https://github.com/user-attachments/assets/1c7f69c0-c447-4c3d-8e13-6b3cb691650c" alt="Image" /></p>

<h3 id="open-level-후">Open Level 후</h3>
<p>PostLoadMapWithWorld , OnWorldInitializedActors가  Construct 뒤에 실행된다.<br />
<img src="https://github.com/user-attachments/assets/ce5e5a6b-4b81-4f0a-9f17-3a82ece790db" alt="Image" /></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">FSubsystemCollectionBase</span><span class="o">&amp;</span> <span class="n">Collection</span><span class="p">)</span>
        <span class="n">LoadWidget</span> <span class="o">=</span> <span class="n">CreateWidget</span><span class="o">&lt;</span><span class="n">ULoadingWidget</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetGameInstance</span><span class="p">(),</span> <span class="n">ScenarioSetting</span><span class="p">.</span><span class="n">LoadingWidgetRef</span><span class="p">);</span>
        <span class="n">FCoreUObjectDelegates</span><span class="o">::</span><span class="n">PostLoadMapWithWorld</span><span class="p">.</span><span class="n">AddUObject</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnPostLoadMap</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">UScenarioSubsystem</span><span class="o">::</span><span class="n">OnPostLoadMap</span><span class="p">(</span><span class="n">UWorld</span><span class="o">*</span> <span class="n">World</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">LoadWidget</span><span class="o">-&gt;</span><span class="n">AddToViewport</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">LoadWidget</span><span class="o">-&gt;</span><span class="n">DeactivateSequence</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>
<p>
모션매칭을 이용한 애니메이션 제작은 기존 방식과 큰 차이가 있다. 모션 매칭의 주요 특징으로는 다음과 같다.<br />
<font color="dodgerred">1. 데이터 기반 접근</font>: 모션 매칭은 대규모의 캡처된 애니메이션 데이터베이스를 활용합니다.<br />
<font color="dodgerred">2. 실시간 검색</font>: 게임 내 캐릭터의 현재 모션 정보를 키로 사용하여 데이터베이스에서 가장 적합한 애니메이션을 실시간으로 검색합니다.<br />
<font color="dodgerred">3. 자연스러운 전환</font>: 복잡한 로직 없이도 다양한 애니메이션 클립 간의 자연스러운 전환이 가능합니다.<br />
<font color="dodgerred">4. 확장성</font>: 애니메이션 기능을 위한 확장 가능한 프레임워크를 제공합니다.<br />
</p>

<p><br /><br />
기존에는 특정 조건에 맞는 애니메이션을 하나하나 직접 설정해줘야 했지만 모션 매칭은 데이터 기반으로 현재 상태에서 가장 적합한 애니메이션을 자연스럽게 자동으로 설정해준다.</p>

<p><br /></p>
<h1 id="모션매칭-사전준비">모션매칭 사전준비</h1>
<h2 id="플러그인-설치">플러그인 설치</h2>
<ul>
  <li>아래 두 플러그인 설치하고 다시 시작한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/dbc4cc87-7a25-4b1d-ba26-266c97506563" alt="image" /><br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/7e725cda-a1ba-4064-a128-da6e780383ce" alt="image" /></li>
</ul>

<h2 id="애니메이션-시퀀스들-준비하기">애니메이션 시퀀스들 준비하기</h2>
<h3 id="모션-매칭-스키마-생성">모션 매칭 스키마 생성</h3>
<ul>
  <li>접두사는 PSS_</li>
  <li>각도 회전 값등 변수 설정하는 애셋이다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/331aea83-d937-4559-845f-ecc26b726c6c" alt="image" /></li>
</ul>

<hr />

<h3 id="database-생성">Database 생성</h3>
<ul>
  <li>
    <p>모션 매칭에 사용될 애니메이션들을 담는 데이터를 생성한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/6c101550-6a54-4a12-a0b9-da28e1352eeb" alt="image" /></p>
  </li>
  <li>적용할 스키마를 선택한다.</li>
  <li>접두사는 PSD_<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/04961922-19f6-47d4-88e8-5692eacf7047" alt="image" /></li>
</ul>

<hr />

<h4 id="psddatabase-화면">PSD(Database) 화면</h4>
<ul>
  <li>이제 여기에 사용할 애니메이션을 드래그 하면된다.</li>
  <li>그전에 <strong>루트모션</strong>을 사용 중인지 확인 해야한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/896d1c75-1c1b-4a07-b845-d8cf73b2a123" alt="image" /></li>
</ul>

<hr />

<h4 id="애니메이션-한번에-수정하기">애니메이션 한번에 수정하기</h4>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/5e49972c-c46e-436e-90dd-29f8af77b1ee" alt="image" /></p>

<ul>
  <li>컨트롤 a를 눌러 모두 선택후 EnableRootMotion을 활성화 한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/e10b9b6c-489e-4f8f-af60-5610d371c867" alt="image" /></li>
</ul>

<hr />

<h4 id="locomotion-psd-생성하기">Locomotion PSD 생성하기</h4>
<ul>
  <li>DB에서 애니메이션을 넣는다.</li>
  <li>각각 상하좌우 방향으로 시작, 진행 중, 멈출 때 해당하는 Walk 모션을 넣어준다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/36724702-59f2-4684-a817-0ae49418333f" alt="image" /></li>
</ul>

<p><br /></p>

<h1 id="모션매칭-활용하기">모션매칭 활용하기</h1>
<h2 id="abp-설정하기">ABP 설정하기</h2>
<ul>
  <li>Motion Matching 노드를 불러와 모션매칭 DataBase를 가져온다.</li>
  <li>그리고 현재 애니메이션에서 추적하기 위해 Trajectory(궤적)을 불러와야 한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/6c49c019-d49b-4f55-af2a-4ab987c59842" alt="image" /></li>
</ul>

<hr />

<h3 id="trajectory-컴포넌트-설치하기">Trajectory 컴포넌트 설치하기</h3>
<ul>
  <li>ABP를 사용할 BP에서 <code class="language-plaintext highlighter-rouge">Character Trajectory</code> 컴포넌트를 부착한다.</li>
</ul>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/31db32d6-577e-49b2-9075-bc079c638a43" alt="image" /></p>

<hr />

<h3 id="trajectory-정보-가져오기">Trajectory 정보 가져오기</h3>
<ul>
  <li>ABP와 BP의 Trajectory를 연결해야한다.</li>
  <li>그렇기 위해선 ABP의 EventGraph에서 자신을 사용하는 BP를 가져와야 한다.</li>
  <li>
    <p>자신을 사용중인 Actor를 가져와 그 액터 BP를 변수로 설정한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/128cb3a3-5f92-4268-a926-57aeb39bb0dd" alt="image" /></p>
  </li>
  <li>
    <p>변수화한 Owner Actor를 불러와 Trajectory를 매 프레임마다 변수화 시킨다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/c697f497-df56-46d3-bed8-1bb8e34fdb2f" alt="image" /></p>
  </li>
  <li>그리고 다시 AnimGraph로 돌아가서 Trajectory를 설정해준다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/a5b14922-a3a4-4367-b352-58a285a1615d" alt="image" /></li>
</ul>

<h2 id="디버깅-궤적-확인">디버깅 궤적 확인</h2>
<ul>
  <li>콘솔창에 <code class="language-plaintext highlighter-rouge">a.CharacterTrajectory.Debug 1</code> 을 하면 궤적이 보인다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/592c0d2d-152c-4334-864a-909b3613afec" alt="image" /></li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://www.youtube.com/watch?v=4ag7fSlEeKA">https://www.youtube.com/watch?v=4ag7fSlEeKA</a>
<a href="https://www.youtube.com/watch?v=S4aBd64t-hY&amp;ab_channel=GorkaGames">https://www.youtube.com/watch?v=S4aBd64t-hY&amp;ab_channel=GorkaGames</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="UnrealEngine" /><category term="Loading" /><category term="UserWidget" /><category term="Widget" /><summary type="html"><![CDATA[게임에서 로딩화면이란 정말 중요하다. 화면전환시 플레이어가 어색함없이 언리얼엔진에서 레벨을 이동할땐 OpenLevel 함수를 사용한다. 사용하면 다른 레벨로 이동하지만 이동하는 과정에서 끊김 현상이 발생한다. 이런 끊김 현상이 느껴지지 않도록 만들어야한다.]]></summary></entry><entry><title type="html">[Math] 세점을 지나는 원의중심(외심) 구하는 법</title><link href="http://localhost:4000/math/Math-%EC%84%B8%EC%A0%90%EC%9D%84-%EC%A7%80%EB%82%98%EB%8A%94-%EC%9B%90%EC%9D%98-%EC%A4%91%EC%8B%AC-%EA%B5%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Math] 세점을 지나는 원의중심(외심) 구하는 법" /><published>2025-02-16T00:00:00+09:00</published><updated>2025-02-16T00:00:00+09:00</updated><id>http://localhost:4000/math/%5BMath%5D%EC%84%B8%EC%A0%90%EC%9D%84%20%EC%A7%80%EB%82%98%EB%8A%94%20%EC%9B%90%EC%9D%98%20%EC%A4%91%EC%8B%AC%20%EA%B5%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/math/Math-%EC%84%B8%EC%A0%90%EC%9D%84-%EC%A7%80%EB%82%98%EB%8A%94-%EC%9B%90%EC%9D%98-%EC%A4%91%EC%8B%AC-%EA%B5%AC%ED%95%98%EA%B8%B0/"><![CDATA[<h1 id="외적을-이용한-선분과-선분의-교차점-구하기">📄외적을 이용한 선분과 선분의 교차점 구하기</h1>

<p>세 개의 점을 지나는 원은 단 하나만 존재하며, 이를 <strong>외접원</strong>이라고 합니다.. 이 외접원의 중심을 <strong>외심</strong>이라고 하며, 외심을 구하는 방법을 알아봅시다.</p>

<p><img src="https://github.com/user-attachments/assets/98bf6b4a-4383-4cfd-912e-89854a2c7bfa" alt="Image" /></p>

<h1 id="️외심의-특징">✏️외심의 특징</h1>
<p>외심의 특징은 다음과 같습니다.</p>
<ol>
  <li>삼각형의 세 변의 수직 이등분선은 외심에서 만난다.</li>
  <li>삼각형의 외심에서 세 꼭짓점에 이르는 거리는 같다.</li>
</ol>

<p>이 성질을 이용하면, 두 변의 <strong>수직 이등분선</strong>이 만나는 점을 구하여 외심을 찾을 수 있습니다.<br />
<img src="https://github.com/user-attachments/assets/3e26f4b7-1318-40c9-87db-ccdc6e952386" alt="Image" /></p>

<h1 id="️풀이">✏️풀이</h1>
<p>두 변의 수직 이등분선 방정식을 y=mx+b, y=nx+c라고 할 때, 두 식을 연립해서 풀면 중심의 좌표가 나오게됩니다.<br />
<img src="https://github.com/user-attachments/assets/7813b87a-46d0-4864-8f42-13ca2312adfa" alt="Image" /></p>

<h2 id="️기울기-공식">✏️기울기 공식</h2>
<p>주어진 세 점을 각각 , , 라 하자. 외심을 구하려면 두 변의 <strong>수직 이등분선</strong>을 찾아야 하며, 이를 위해 먼저 변의 기울기를 계산합니다.</p>

<p>기울기 공식:<br />
\(m=\frac{\Delta y}{\Delta x}=\frac{y_2-y_1}{x_2-x_1}\)<br />
직교하는 기울기 공식:<br />
\(m'=-\frac{x_2-x_1}{y_2-y_1}\)<br />
<img src="https://github.com/user-attachments/assets/e90cdab6-319c-4a9e-bb77-1e3d8f5e0421" alt="Image" /></p>

<h2 id="️수직-이등분선의-방정식">✏️수직 이등분선의 방정식</h2>
<p>각 수직 이등분선의 방정식은 다음과 같습니다.<br />
\(y=mx+b,y=nx+c\)<br />
각 방정식의 기울기를 구해줍니다.<br />
\(AB기울기=\frac{Y_B-Y_A}{X_B-X_{A}}, BC기울기=\frac{Y_C-Y_B}{X_C-X_{B}}\)</p>

\[AB기울기=m=-\frac{X_B-X_{A}}{Y_B-Y_A}, BC기울기=n=-\frac{X_C-X_{B}}{Y_C-Y_B}\]

<p>b와 c는 두 선분 중앙의 위치 값을 안다면 x와 y를 대입해 풀 수 있습니다.<br />
\(b=y-mx, c =y-nx\)</p>

<h2 id="️외심-좌표계산">✏️외심 좌표계산</h2>
<p>두 수직 이등분선의 방정식을 연립하여 외심의 좌표를 구해줍니다.<br />
\(mx-nx=c-b\)<br />
\(x(m-n)=c-b\)<br />
\(x=\frac{c-b}{m-n}\)<br />
\(y=m(\frac{c-b}{m-n})+b\)</p>

<h2 id="코드">💻코드</h2>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="n">Vector2</span> <span class="nf">GetCircumCircleCenter</span><span class="p">(</span><span class="n">Vector2</span> <span class="n">p0</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">p1</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">p2</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="c1">// slope equation : m = dy/dx = (y_2 - y_2)/(x_2 - x_1)  </span>
    <span class="c1">// perpendicular slope equation : m' = -(dx/dy) = -(x_2 - x_1)/(y_2 - y_2)        // y = mx+b  </span>
    <span class="kt">float</span> <span class="n">m</span> <span class="p">=</span> <span class="p">-(</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span> <span class="p">-</span> <span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">/</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>  
    <span class="c1">// y = nx+c  </span>
    <span class="kt">float</span> <span class="n">n</span> <span class="p">=</span> <span class="p">-(</span><span class="n">p2</span><span class="p">.</span><span class="n">x</span> <span class="p">-</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">/</span> <span class="p">(</span><span class="n">p2</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>  
      
    <span class="n">Vector2</span> <span class="n">p0p1Center</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span>  
    <span class="n">Vector2</span> <span class="n">p1p2Center</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="nf">Lerp</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="m">0.5f</span><span class="p">);</span>  
  
    <span class="kt">float</span> <span class="n">b</span> <span class="p">=</span> <span class="n">p0p1Center</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">m</span> <span class="p">*</span> <span class="n">p0p1Center</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">c</span> <span class="p">=</span> <span class="n">p1p2Center</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">n</span> <span class="p">*</span> <span class="n">p1p2Center</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>  
  
    <span class="kt">float</span> <span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="n">c</span> <span class="p">-</span> <span class="n">b</span><span class="p">)</span> <span class="p">/</span> <span class="p">(</span><span class="n">m</span> <span class="p">-</span> <span class="n">n</span><span class="p">);</span>  
    <span class="kt">float</span> <span class="n">y</span> <span class="p">=</span> <span class="n">m</span> <span class="p">*</span> <span class="n">x</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>  
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  
<span class="p">}</span>
</code></pre></div></div>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://mathbang.net/455">https://mathbang.net/455</a>
<a href="https://minstudyroom.tistory.com/4">https://minstudyroom.tistory.com/4</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="math" /><category term="math" /><category term="geometry" /><category term="circumcenter" /><category term="circumcircle" /><category term="triangle" /><category term="intersection" /><category term="line" /><category term="perpendicular_bisector" /><category term="point" /><category term="distance" /><category term="coordinate_geometry" /><category term="midpoint" /><category term="equation" /><category term="vector" /><category term="수학" /><category term="기하학" /><category term="외심" /><category term="외접원" /><category term="삼각형" /><category term="교차점" /><category term="선" /><category term="수직이등분선" /><category term="점" /><category term="길이" /><category term="좌표기하" /><category term="중점" /><category term="방정식" /><category term="벡터" /><summary type="html"><![CDATA[📄외적을 이용한 선분과 선분의 교차점 구하기]]></summary></entry><entry><title type="html">[Algorithm] 절차적 맵생성 관련 알고리즘 정리</title><link href="http://localhost:4000/algorithm/Algorithm-%EB%9E%9C%EB%8D%A4-%EB%A7%B5%EC%83%9D%EC%84%B1-%EA%B4%80%EB%A0%A8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AA%A8%EC%9D%8C/" rel="alternate" type="text/html" title="[Algorithm] 절차적 맵생성 관련 알고리즘 정리" /><published>2024-12-12T00:00:00+09:00</published><updated>2024-12-12T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/%5BAlgorithm%5D%EB%9E%9C%EB%8D%A4%20%EB%A7%B5%EC%83%9D%EC%84%B1%20%EA%B4%80%EB%A0%A8%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EB%AA%A8%EC%9D%8C</id><content type="html" xml:base="http://localhost:4000/algorithm/Algorithm-%EB%9E%9C%EB%8D%A4-%EB%A7%B5%EC%83%9D%EC%84%B1-%EA%B4%80%EB%A0%A8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%AA%A8%EC%9D%8C/"><![CDATA[<h1 id="맵-구조-생성-알고리즘">맵 구조 생성 알고리즘</h1>
<h2 id="1-bsp-알고리즘">1. BSP 알고리즘</h2>
<h3 id="개념">개념</h3>
<ul>
  <li>공간을 재귀적으로 분할하여 트리 구조로 표현한다.</li>
  <li>맵 전체를 큰 사각형으로 시작하여 이를 점점 더 작은 사각형으로 나눕니다.</li>
  <li>각 사각형에 방을 배치하고, 이후 이웃하는 방들을 연결하는 통로를 생성합니다.</li>
</ul>

<h3 id="장단점">장단점</h3>
<ul>
  <li>장점
    <ul>
      <li>만들기 쉽다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>직사각형의 단조로운 구조를 가진다.</li>
    </ul>
  </li>
  <li>예시 : https://www.youtube.com/watch?v=FO12bZD3a5M</li>
</ul>

<h2 id="2-셀룰러-오토마타세포-자동자">2. 셀룰러 오토마타(세포 자동자)</h2>

<p><img src="https://github.com/user-attachments/assets/01457887-9591-47fd-a1fb-14990fcc6592" alt="a" /></p>

<h3 id="개념-1">개념</h3>

<ul>
  <li>세포들이 주변에 있는 세포에 따라 자신의 상태를 변화시키는 알고리즘이다.
    <ul>
      <li>맨 처음 세포들의 초기 상태를 벽, 빈공간으로 설정한다.</li>
    </ul>
  </li>
  <li>그후 세포를 업데이트해서 주변 세포들의 상태에 따라 세포를 새로운 상태로 업데이트한다.
    <ul>
      <li>예를들어 자기 주변 세포들 중 벽 상태 세포가 4개 이상이면 자신도 벽으로 변한다.</li>
    </ul>
  </li>
</ul>

<h3 id="장단점-1">장단점</h3>

<ul>
  <li>장점
    <ul>
      <li>섬, 동굴같은 구조의 맵을 생성하기 좋다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>원하는 모양의 방을 만들기 어렵다.</li>
      <li>직각 형태의 방을 만들기 힘들다.</li>
    </ul>
  </li>
</ul>

<h3 id="예시">예시</h3>

<ul>
  <li>https://www.youtube.com/watch?v=v7yyZZjF1z4
    <ul>
      <li>셀룰러 오토마타 기본 개념</li>
    </ul>
  </li>
  <li>https://www.youtube.com/watch?v=yOgIncKp0BE
    <ul>
      <li>2D 마칭스퀘어를 이용한 벽 구조 생성</li>
    </ul>
  </li>
  <li>https://www.youtube.com/watch?v=xYOG8kH2tF8
    <ul>
      <li><strong>BFS, DFS</strong>를 이용한 방 영역 설정</li>
    </ul>
  </li>
  <li>https://www.youtube.com/watch?v=eVb9kQXvEZM
    <ul>
      <li>가장 가까운 방끼리 복도 연결</li>
      <li>방의 가장 외각 Tile들끼리 거리를 비교해서 가장 가운 곳끼리 연결한다.</li>
    </ul>
  </li>
</ul>

<h2 id="3-tinykeep-알고리즘">3. TinyKeep 알고리즘</h2>

<p><img src="https://github.com/user-attachments/assets/8a783d8c-f7a2-4f25-8671-6cdeb875607c" alt="a" /></p>

<ul>
  <li>맨 처음 방을 한곳에 몰아넣고 충돌 처리를 시켜서 밀어냅니다.</li>
  <li>그 후 선별한 각 방들 중심점을 기준으로 <strong>들로네 삼각분할</strong>을 합니다.</li>
  <li>들로네 삼각분할로 만든 선들을 이용해 <strong>최소 신장트리</strong>를 수행합니다.
    <ul>
      <li>최소 신장트리는 사이클이 없으면서 모든 정점이 연결되는 트리로 모든 방이 연결된 방 구조를 생성할 수 있습니다.</li>
      <li>최소 신장트리는 크루스칼, 프림 알고리즘 두 방식이 있는데 프림이 좀 더 빠릅니다.</li>
    </ul>
  </li>
</ul>

<h3 id="예시-1">예시</h3>

<ul>
  <li>https://www.youtube.com/watch?v=rBY2Dzej03A&amp;t=300s
    <ul>
      <li>2D, 3D 맵 생성 알고리즘</li>
    </ul>
  </li>
  <li>https://www.youtube.com/watch?v=t2ZQvJKrptc
    <ul>
      <li>엔터더 건전 모작</li>
    </ul>
  </li>
</ul>

<h2 id="4-perlinnoise">4. PerlinNoise</h2>

<p><img src="https://github.com/user-attachments/assets/45986986-d11b-446a-bcb9-72ffccb00916" alt="a" /></p>

<ul>
  <li>단순히 무작위 값을 나열한 노이즈가 아니라, 연속적으로 변화하는 값의 패턴의 노이즈를 생성한다.</li>
  <li>주파수(Frequency), 옥타브(octave) 등 파라미터로 모양을 조정할 수 있다.</li>
  <li><strong>1. Scale</strong>
    <ul>
      <li><strong>설명</strong>:
        <ul>
          <li>노이즈의 세부 패턴 크기를 제어합니다. 작은 값을 사용할수록 패턴이 확대되어 더 거친 구조를, 큰 값을 사용할수록 세부적이고 조밀한 패턴을 생성합니다.</li>
        </ul>
      </li>
      <li><strong>용도</strong>:
        <ul>
          <li>지형 생성에서 산맥 크기 또는 높낮이를 조정할 때 사용.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>2. Frequency</strong>
    <ul>
      <li><strong>설명</strong>:
        <ul>
          <li>노이즈 함수가 얼마나 자주 반복되는지를 나타내는 값입니다. 높은 주파수는 더 세부적인 패턴을, 낮은 주파수는 더 넓고 완만한 패턴을 생성합니다.</li>
        </ul>
      </li>
      <li><strong>용도</strong>:
        <ul>
          <li>여러 주파수를 조합하여 복잡한 형태의 노이즈를 생성(Octave 구조와 결합)합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>3. Amplitude</strong>
    <ul>
      <li><strong>설명</strong>:
        <ul>
          <li>노이즈 값의 진폭, 즉 노이즈 패턴의 높낮이를 조정합니다.</li>
          <li>높은 진폭은 강한 대비를, 낮은 진폭은 더 부드러운 패턴을 만듭니다.</li>
        </ul>
      </li>
      <li><strong>용도</strong>:
        <ul>
          <li>지형의 고도 또는 물결 높이를 조정할 때 사용.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>4. Octaves</strong>
    <ul>
      <li><strong>설명</strong>:
        <ul>
          <li>노이즈의 “세부 레벨”을 나타냅니다. 각 옥타브는 주파수와 진폭이 다른 노이즈 계층을 추가합니다.</li>
          <li>높은 옥타브 수는 더 복잡하고 세밀한 패턴을 생성합니다.</li>
        </ul>
      </li>
      <li><strong>용도</strong>:
        <ul>
          <li>자연스러운 텍스처 생성에서 중요한 요소로, 다중 계층 효과를 제공합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>5. Persistence</strong>
    <ul>
      <li><strong>설명</strong>:
        <ul>
          <li>옥타브 간 진폭의 감소 비율을 나타냅니다.</li>
          <li>1에 가까운 값은 각 옥타브가 비슷한 영향을 미치며, 작은 값은 고주파 노이즈의 영향을 줄입니다.</li>
        </ul>
      </li>
      <li><strong>용도</strong>:
        <ul>
          <li>세부 패턴의 강도와 전체적인 부드러움 조정.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>6. Lacunarity</strong>
    <ul>
      <li><strong>설명</strong>:
        <ul>
          <li>옥타브 간 주파수의 증가 비율을 나타냅니다.</li>
          <li>기본값은 2로 설정되며, 값이 커질수록 고주파 패턴이 더 복잡해집니다.</li>
        </ul>
      </li>
      <li><strong>용도</strong>:
        <ul>
          <li>세밀한 구조와 큰 구조 간의 균형을 조정.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>7. Seed</strong>
    <ul>
      <li><strong>설명</strong>:
        <ul>
          <li>노이즈의 난수 시드를 설정하여 생성되는 패턴의 고유성을 결정합니다.</li>
          <li>동일한 시드 값은 동일한 결과를 재생성합니다.</li>
        </ul>
      </li>
      <li><strong>용도</strong>:
        <ul>
          <li>특정 노이즈 패턴을 재현하거나 고유한 텍스처를 생성.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>8. Offset</strong>
    <ul>
      <li><strong>설명</strong>:
        <ul>
          <li>노이즈 패턴의 기준점을 조정하여 출력 패턴을 이동합니다.</li>
        </ul>
      </li>
      <li><strong>용도</strong>:
        <ul>
          <li>다른 영역에서 새로운 패턴을 만들거나 패턴의 시작점을 조정.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (int y = 0; y &lt; mapHeight; y++) {
	for (int x = 0; x &lt; mapWidth; x++) {

		float amplitude = 1;
		float frequency = 1;
		float noiseHeight = 0;

		for (int i = 0; i &lt; octaves; i++) {
			float sampleX = (x-halfWidth) / scale * frequency + octaveOffsets[i].x;
			float sampleY = (y-halfHeight) / scale * frequency + octaveOffsets[i].y;

			float perlinValue = Mathf.PerlinNoise (sampleX, sampleY) * 2 - 1;
			noiseHeight += perlinValue * amplitude;

			amplitude *= persistance;
			frequency *= lacunarity;
		}

		if (noiseHeight &gt; maxNoiseHeight) {
			maxNoiseHeight = noiseHeight;
		} else if (noiseHeight &lt; minNoiseHeight) {
			minNoiseHeight = noiseHeight;
		}
		noiseMap [x, y] = noiseHeight;
	}
}

</code></pre></div></div>

<h3 id="장점">장점</h3>

<ul>
  <li>알아두면 써먹을 곳이 많다.</li>
  <li>지형 지물 생성 범위를 지정할 때 더 활용하기 좋다.
    <ul>
      <li>펄린 노이즈로 특정 값 이상인 부분은 특정 바이옴으로 만들거나 낭떠러지로 표현할수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="예시-2">예시</h3>

<ul>
  <li>https://www.youtube.com/watch?v=RDQK1_SWFuc</li>
  <li>https://www.youtube.com/watch?v=NGc5VyhB-Fs</li>
  <li>https://1217pgy.tistory.com/7</li>
</ul>

<h1 id="지오메트리">지오메트리</h1>

<h2 id="보로노이와-들로네-삼각분할">보로노이와 들로네 삼각분할</h2>

<p><img src="https://github.com/user-attachments/assets/df59ced5-9a4b-40e5-a9c8-6b5729d753db" alt="a" /></p>

<ul>
  <li>예전에 정리한 PPT
    <ul>
      <li>https://www.slideshare.net/slideshow/ss-251207958/251207958#8</li>
    </ul>
  </li>
  <li>아주 좋은 강좌 링크
    <ul>
      <li>https://www.habrador.com/tutorials/math/13-voronoi/</li>
      <li>깃허브
        <ul>
          <li>https://github.com/Habrador/Computational-geometry</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="dceldouble-connected-edge-list">DCEL(Double-Connected Edge List)</h2>

<p><img src="https://blog.kakaocdn.net/dn/nWvmp/btrvtcI04R6/XqXcOAljphmTWbtMWxju40/img.png" alt="a" /></p>

<p>위 깃허브에선 DCEL을 이용해서 들로네 삼각분할, 보로노이 다이어그램을 구현해서 DCEL 설명을 남긴다.</p>

<p><strong>DCEL</strong> 이중 연결 가장자리 목록 혹은 <strong>half-edge data structure</strong> 라고도 불리는 이것은 <br />
일반적으로 위처럼 폴리곤이 Face Vertex Edge 3개의 요소로 이루어지는 구조를 뜻하는데 각 요소의 뜻은 다음과 같다.</p>

<p><strong>Face</strong> - 폴리곤의 내부<br />
<strong>Vertex</strong> - 폴리곤의 정점<br />
<strong>Edge</strong> - 폴리곤의 가장자리</p>

<p><img src="https://blog.kakaocdn.net/dn/c3VIrf/btrvl9gseEJ/vMstY7fARLOXpOsacKQVA0/img.png" alt="a" /></p>

<p>DCEL은 위와같은 모습이 되는데 한 폴리곤의 내부가 시계방향 혹은 반시계방향으로 정렬되 있는데 만약 모서리가 면의 경계에 있다면 그 위치에 있는 모서리는 두개이고 각 모서리를 가진 폴리곤의 회전 방향은 정 반대이다.</p>

<p>방향만 다른 같은 모서리가 두개있는 것이 마치 한 모서리를 반으로 가른것 같아서 half-Edge라고도 불리는 것 같다.<br />
폴리곤을 이루는 각 요소는 다음과 같은 데이터를 가지고 있는데</p>

<p><strong>Face -</strong> 폴리곤을 이루는 한 Edge<br />
<strong>Vertex -</strong> 자신이 포함된 폴리곤의 Face, 위에 사진상에선 한 위치에 여러개의 정점이 있는데 하나로 중첩해서 구현해도 상관없다. 오히려 많은 DCEL 자료에선 여러개의 정점으로 소개하지 않는다.<br />
<strong>Edge -</strong> p1Vertex, p2Vertex, prevEdge, nextEdge, oppositeEdge</p>

<p>Face1의 경우 E1, E2, E3중에 하나를 가지게 되고<br />
Vertex1은 E2를 가지게 되고<br />
Edge1은 p1으로 V3 p2로 V1 prevEdge는 E3 nextEdge는 E2 oppositeEdge는 E4가 된다.</p>

<p>DCEL은 도형 기하학에서 쓰이기 좋은데 예를 들어 한 메쉬가 있다고 가정했을 때 메쉬의 한 triangle를 구하려고하면 하나하나 일일이 찾는 브루트 포스 방식이 아니라 DCEL 폴리곤 데이터를 이용해 원하는 triangle을 찾아간다면 찾는데 걸리는 시간이 획기적으로 줄어들 수 있다.</p>

<h3 id="참고자료">참고자료</h3>

<p>https://www.ics.uci.edu/~goodrich/teach/geom/notes/DCEL.pdf</p>

<h1 id="그-밖에">그 밖에</h1>
<h2 id="푸아송디스크">푸아송디스크</h2>
<p><img src="https://github.com/user-attachments/assets/2589b7d9-594e-4249-b1d6-f4fb63619a0b" alt="a" /></p>
<ul>
  <li>점을 고르게 분포시키는 알고리즘이다.</li>
  <li>일반적인 랜덤 분포는 커다란 빈 부분이 생기거나 완전히 겹쳐지는 문제가 생긴다</li>
  <li>각 점 사이의 거리는 최소 거리 이상이여야한다.</li>
</ul>

<h3 id="예시-3">예시</h3>

<ul>
  <li>https://www.youtube.com/watch?v=7WcmyxyFO7o&amp;t=352s
    <ul>
      <li>푸아송 디스크 구현</li>
    </ul>
  </li>
  <li>https://www.youtube.com/watch?v=NGc5VyhB-Fs
    <ul>
      <li>펄린 노이즈, 푸아송 디스크를 이용해 랜덤맵에 나무심기</li>
    </ul>
  </li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href=""></a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="algorithm" /><category term="algorithm" /><category term="알고리즘" /><category term="절차적 맵 생성" /><category term="푸아송 디스크" /><category term="BSP" /><category term="셀룰러 오토마타" /><category term="펄린 노이즈" /><summary type="html"><![CDATA[맵 구조 생성 알고리즘 1. BSP 알고리즘 개념 공간을 재귀적으로 분할하여 트리 구조로 표현한다. 맵 전체를 큰 사각형으로 시작하여 이를 점점 더 작은 사각형으로 나눕니다. 각 사각형에 방을 배치하고, 이후 이웃하는 방들을 연결하는 통로를 생성합니다.]]></summary></entry><entry><title type="html">[Obsidian] Vercel을 활용한 Obsidian Digital Garden 블로그 만들기</title><link href="http://localhost:4000/obsidian/Obsidian-Vercel%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-Digital-Garden-%EB%A7%8C%EB%93%A4%EA%B8%B0/" rel="alternate" type="text/html" title="[Obsidian] Vercel을 활용한 Obsidian Digital Garden 블로그 만들기" /><published>2024-12-12T00:00:00+09:00</published><updated>2024-12-12T00:00:00+09:00</updated><id>http://localhost:4000/obsidian/%5BObsidian%5DVercel%EC%9D%84%20%ED%99%9C%EC%9A%A9%ED%95%9C%20Digital%20Garden%20%EB%A7%8C%EB%93%A4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/obsidian/Obsidian-Vercel%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-Digital-Garden-%EB%A7%8C%EB%93%A4%EA%B8%B0/"><![CDATA[<h1 id="옵시디언으로-블로그를-만드는-이유">📄옵시디언으로 블로그를 만드는 이유</h1>
<p>지금까지 나는 지식을 정리하고 정리한 내용을 공유하기 위해 여러 종류의 블로그 사이트를 사용해 봤다.<br />
맨처음에는 <strong>네이버</strong> 블로그였는데 한국인의 입장에선 확실히 네이버가 접근성이 좋긴하지만 한국인을 제외한 외국인들은 구글 검색에 뜨기가 쉽지않고 디자인이 마음에 들지않아 금방 포기했다.</p>

<p>그 다음은 <strong>티스토리</strong> 블로그였다. 개발관련 자료를 검색하면 많은 자료가 티스토리 혹은 Velog에 올라와 있었다. 나는 직접 커스텀하는 것을 좋아해서 Velog보다는 티스토리가 더 좋다 생각해서 티스토리에서 글을 작성했었다.<br />
물론 편하고 기본적으로 깔끔해서 좋긴 하지만 글을 검색하거나 사이트를 설정하는데 마음에 들지 않아 자연스럽게 손대지 않게 되었다.</p>

<p>좀 더 자유도 높은 블로그가 있을까 찾아봤는데 <strong>GitBlog</strong>가 눈에 들어왔다.<br />
GItBlog는 처음부터 끝까지 기능을 다 커스텀가능하고 테마도 풍부해서 마음에 드는게 많았다. 그 중 Jekyll 테마가 인지도 있어보여서 사용해봤다. 처음에는 css도 직접짜고 여러가지 기능을 넣을 수 있어서 재밌었지만 생산성 부분에서 문제가 커져갔다.</p>

<p>기본적으로 GitBlog는 자유도가 높은 만큼 학습량이 많아 초반에 시간이 오래걸리고 무엇보다 띄어쓰기가 너무 큰 문제였다. Jekyll테마에서만 그런지는 몰라도 줄바꿈이 제대로 적용되지 않아 br 태그를 중간중간 써줘야하고 생각한대로 글이 이쁘게 나오지도 않아서 css를 수정하고 글자도 다시 수정하는 등 글 하나 작성하는데 시간이 오래걸린다. 그리고 나는 옵시디언을 통해 먼저 글을 작성하고 그 글을 정리해서 포스팅하는데 이게 옵시디언과 달리 HTML을 중간중간 써줘야 하다보니 이것도 시간이 많이 걸린다.</p>

<p>그리고 가장 중요한게 조회수인데 사이트맵이 제대로 적용이 안되는지 사람이 몇달간 제대로 들어오지 않곤했다. 그래서 금방 흥미를 잃게 되었다.</p>

<p>결국 포스팅 하는게 귀찮아져서 손을 안대게 됐는데 어떻게 해야 내가 블로그를 열심히 쓰게 될까 생각해 보았다.<br />
지금까지 블로그를 사용했던 경험을 토대로 내가 블로그에서 가장 중요하게 생각하는 걸 3가지를 정해봤다.</p>
<ol>
  <li>포스트 업로드가 쉬워야한다.</li>
  <li>옵시디언에서 작성한 글에서 수정을 거의 안해야한다.</li>
  <li>자유도가 있어야한다.</li>
</ol>

<p>위 조건들을 토대로 찾아본 결과 <strong>Digital Garden</strong> 플러그인을 이용해 옵시디언 노트를 통쨰로 포스팅하는 방식이 가장 적절해 보였다. 아직 시작 단계이지만 얼추 봤을때는 아래의 장점이 잇었다.</p>
<ol>
  <li>버튼 몇번으로 업로드, 수정, 삭제가능하다.</li>
  <li>옵시디언 노트 내용이랑 똑같다.</li>
  <li>꾸미기 쉽다.</li>
</ol>

<p>내가 생각한 블로그의 조건이랑 딱 맞아 떨어져보여 한번 시작해보려고 한다.</p>

<h1 id="digital-garden으로-블로그-만들기">📄Digital Garden으로 블로그 만들기</h1>
<h3 id="플러그인-설치">🔍플러그인 설치</h3>
<ul>
  <li>Community Plugin에 가서 <code class="language-plaintext highlighter-rouge">Digital Garden</code>을 검색해서 설치한다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/3949101f-9e1d-4715-aab9-d6f718819783" alt="image" /></p>

<hr />

<h3 id="vercel-계정-생성">🔍Vercel 계정 생성</h3>
<ul>
  <li> <a href="https://github.com/signup">Vercel</a>로 가서 GitHub 계정과 연동해준다.</li>
</ul>

<div class="callout-info-expanded">
<div class="callout-header">Vercel</div>
<p>
클라우드 플랫폼으로, 웹사이트 및 애플리케이션을 배포, 관리, 그리고 성능을 최적화하는 데 도움을 준다.<br />
주로 Next.js와 같은 프레임워크와 밀접하게 연동된다.
</p>
</div>

<hr />

<h3 id="리포지토리-생성">🔍리포지토리 생성</h3>
<ul>
  <li>리포지토리 생성 후 <a href="https://github.com/oleeskild/digitalgarden">링크</a>로가서 Deploy 버튼 클릭한다</li>
  <li>이렇게 하면 Vercel이 열리고 GitHub 계정에 저장소의 사본이 생성된다. 사본 저장소의 이름을 작성하고 생성하면 Vercel의 단계에 따라 사이트를 인터넷에 게시된다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/8b371813-b355-4c2c-abe4-247c78591a32" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/fa8421f8-0d56-40f9-b1e0-410121ab0f18" alt="image" /></p>

<hr />

<h3 id="github-액세스토큰-생성">🔍GitHub 액세스토큰 생성</h3>
<ul>
  <li>다음으로 GitHub 계정에 대한 액세스 토큰을 만들어야 한다.</li>
  <li>토큰은 저장소를 접근하기 위한 비밀번호 역할을 하여 토큰을 만들어야 작성한 글을 업로드할 수 있다.</li>
  <li>토큰 생성방법은  <a href="https://dg-docs.ole.dev/advanced/fine-grained-access-token/">링크</a>에서 확인할 수 있다. 설정값을 똑같이 넣어준다.</li>
  <li>토큰은 <a href="https://github.com/settings/tokens/new?scopes=repo">여기</a>서 생성할 수 있다. </li>
  <li><strong>토큰 값은 한번 생성됐을때 한번만 알려주니까</strong> 꼭 어딘가에 저장해놓자</li>
</ul>

<hr />

<h3 id="digital-garden-플러그인-설정">🔍Digital Garden 플러그인 설정</h3>
<ul>
  <li>Digital Garden 플러그인에 깃허브 저장소 관련 정보를 넣어줘야한다.
    <ol>
      <li>Github repo name: 생성한 레포지토리 이름</li>
      <li>Github username: 깃허브 아이디</li>
      <li>Github token: 방금 생성한 토큰<br />
<img src="https://github.com/user-attachments/assets/47e4cadc-92f5-4432-813a-73bc23b0c3f7" alt="image" /></li>
    </ol>
  </li>
</ul>

<h2 id="노트-연결하기">🔍노트 연결하기</h2>
<ul>
  <li>프로퍼티를 통해 공개할 노트를 설정할 수 있다.</li>
  <li><strong>dg-publish</strong> : 노트를 다른 사람들에게 공개한다.</li>
  <li><strong>dg-home</strong> : 해당 노트를 메인 페이지로 설정한다.<br />
<img src="https://github.com/user-attachments/assets/ceb39f0c-4d75-41d1-bdf8-6a314375053d" alt="image" /></li>
</ul>

<h2 id="노트-푸시하기">🔍노트 푸시하기</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Digital Garden: Publish Single Note</code>를 눌러서 노트를 공개할 수 있다.</li>
  <li>그리고 사이트 주소를<a href="https://vercel.com/dashboard">Vercel</a>에서 찾고 몇분 뒤면 푸시한 노트가 올라와 있을 것이다.</li>
</ul>

<h2 id="마무리">🚀마무리</h2>
<ul>
  <li>옵시디언에서 글을 쓰고 그것을 그대로 웹사이트에 올리는 것은 분명 편하긴하다.</li>
  <li>하지만 사이드 카테고리가 너무 옵시디언이랑 똑같아 이 부분은 맘에 들지 않는다.</li>
  <li>그래서 대안으로 webpage export 플러그인을 알아봤는데 이건 분명 편해보이지만 깃허브와 연동하는 기능이 없어서 Digital Garden을 계속 쓸것같다.</li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://blog.naver.com/sharonichoya/220501242693">https://blog.naver.com/sharonichoya/220501242693</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="obsidian" /><category term="Obsidian" /><category term="Vercel" /><category term="Digital Garden" /><category term="Productivity" /><category term="Blog" /><category term="Naver" /><category term="네이버" /><category term="TiStory" /><category term="티스토리" /><category term="Git" /><category term="깃" /><category term="생산성" /><category term="블로그" /><summary type="html"><![CDATA[📄옵시디언으로 블로그를 만드는 이유 지금까지 나는 지식을 정리하고 정리한 내용을 공유하기 위해 여러 종류의 블로그 사이트를 사용해 봤다. 맨처음에는 네이버 블로그였는데 한국인의 입장에선 확실히 네이버가 접근성이 좋긴하지만 한국인을 제외한 외국인들은 구글 검색에 뜨기가 쉽지않고 디자인이 마음에 들지않아 금방 포기했다.]]></summary></entry><entry><title type="html">[Visual Studio] Visual Studio에서 빌드exe 파일 뽑는 법</title><link href="http://localhost:4000/ide/IDE-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4%EB%A1%9C-%EB%B9%8C%EB%93%9Cexe%ED%8C%8C%EC%9D%BC-%EB%BD%91%EA%B8%B0/" rel="alternate" type="text/html" title="[Visual Studio] Visual Studio에서 빌드exe 파일 뽑는 법" /><published>2024-12-12T00:00:00+09:00</published><updated>2024-12-12T00:00:00+09:00</updated><id>http://localhost:4000/ide/%5BIDE%5D%EB%B9%84%EC%A3%BC%EC%96%BC%20%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4%EB%A1%9C%20%EB%B9%8C%EB%93%9Cexe%ED%8C%8C%EC%9D%BC%20%EB%BD%91%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/ide/IDE-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4%EB%A1%9C-%EB%B9%8C%EB%93%9Cexe%ED%8C%8C%EC%9D%BC-%EB%BD%91%EA%B8%B0/"><![CDATA[<h2 id="why">📄Why</h2>
<ul>
  <li>프로그래밍 과제를 하는데 명령인수를 server-name으로 적으라고 했는데 서버인수가 무엇인지 몰랐다.</li>
  <li>그래서 명령인수에 대한 설명을 적다가 int main의 인자 값이 명령인수 뿐만 아니라 exe 파일에 인수를 넘기는 방식으로도 활용 할 수 있는 법을 알게되었고 그러다 exe 파일을 뽑는 방법을 정리하게 되었다.</li>
</ul>

<h2 id="빌드-파일-만들기">빌드 파일 만들기</h2>
<h3 id="솔루션-정리">🔍솔루션 정리</h3>
<ul>
  <li>빌드 탭에서 <code class="language-plaintext highlighter-rouge">솔루션정리(C)</code>를 누른다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/ab9fbbff-585e-435f-84de-0a63877e8536" alt="image" /></p>

<div class="callout-info-expanded">
<div class="callout-header">솔루션 정리</div>
<p>
기타 파일, 출력 파일을 삭제합니다.<br />
솔루션 정리 후 빌드를 하면 중간 파일과 출력 파일이 새로 생성됩니다.<br />
이를 통해 오류, 경고가 있는지 확인하고 다시 빌드를 하는 효과를 볼 수 있습니다.
</p>
</div>

<hr />

<h3 id="출력-준비-및-경로-설정">🔍출력 준비 및 경로 설정</h3>
<ul>
  <li>
    <p>상단 <code class="language-plaintext highlighter-rouge">프로젝트 &gt; 프로젝트 속성</code> 을 선택한다.<br />
<img src="https://github.com/user-attachments/assets/28b5793b-abe3-4d78-8ba4-9eef2c8be8be" alt="image" /></p>
  </li>
  <li>상단 구성에서 Release로 변경한다.</li>
  <li>출력 디렉터리에서 파일을 출력할 경로를 작성한다.<br />
<img src="https://github.com/user-attachments/assets/c577f535-6b72-4856-b7e9-f186b4ec96f6" alt="image" /></li>
</ul>

<hr />

<h3 id="솔루션-다시-정리">🔍솔루션 다시 정리</h3>
<ul>
  <li>빌드 탭에서 <code class="language-plaintext highlighter-rouge">솔루션정리(C)</code>를 한번 더 누른다.<br />
<img src="https://github.com/user-attachments/assets/ab9fbbff-585e-435f-84de-0a63877e8536" alt="image" /></li>
</ul>

<hr />

<h3 id="일괄-빌드">🔍일괄 빌드</h3>
<p><img src="https://github.com/user-attachments/assets/56760441-fb4d-478f-abe9-e9bf076523e6" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/730fed52-a777-44d0-943c-d9b34791d691" alt="image" /></p>

<h2 id="결과">🚀결과</h2>
<ul>
  <li>컨트롤 B를 눌러 빌드를 하면 출력디렉토리 경로에 .exe 파일이 생성된다.<br />
<img src="https://github.com/user-attachments/assets/f28d4ce7-31c3-4205-9445-5076ecb38fc7" alt="image" /></li>
</ul>

<p><img src="https://github.com/user-attachments/assets/25f1f69b-6623-4b9b-8250-3119d570be2a" alt="image" /></p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://splendidlolli.tistory.com/25">https://splendidlolli.tistory.com/25</a>
<a href=" https://heroeskdw.tistory.com/entry/%EC%BD%94%EB%94%A9c-%EB%AA%85%EB%A0%B9-%EC%9D%B8%EC%88%98-%EB%B0%9B%EA%B8%B0"> https://heroeskdw.tistory.com/entry/%EC%BD%94%EB%94%A9c-%EB%AA%85%EB%A0%B9-%EC%9D%B8%EC%88%98-%EB%B0%9B%EA%B8%B0</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ide" /><category term="Obsidian" /><category term="옵시디언" /><category term="테마" /><category term="Theme" /><category term="최적화" /><category term="Optimize" /><category term="속도" /><category term="아누푸친" /><category term="Anuppuchine" /><category term="Minimal" /><category term="미니멀" /><summary type="html"><![CDATA[📄Why 프로그래밍 과제를 하는데 명령인수를 server-name으로 적으라고 했는데 서버인수가 무엇인지 몰랐다. 그래서 명령인수에 대한 설명을 적다가 int main의 인자 값이 명령인수 뿐만 아니라 exe 파일에 인수를 넘기는 방식으로도 활용 할 수 있는 법을 알게되었고 그러다 exe 파일을 뽑는 방법을 정리하게 되었다.]]></summary></entry><entry><title type="html">[Visual Studio] 명령인수 개념과 exe파일에서 넘겨주는 법</title><link href="http://localhost:4000/ide/IDE-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4-%EB%AA%85%EB%A0%B9%EC%9D%B8%EC%88%98/" rel="alternate" type="text/html" title="[Visual Studio] 명령인수 개념과 exe파일에서 넘겨주는 법" /><published>2024-12-12T00:00:00+09:00</published><updated>2024-12-12T00:00:00+09:00</updated><id>http://localhost:4000/ide/%5BIDE%5D%EB%B9%84%EC%A3%BC%EC%96%BC%20%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4%20%EB%AA%85%EB%A0%B9%EC%9D%B8%EC%88%98</id><content type="html" xml:base="http://localhost:4000/ide/IDE-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4-%EB%AA%85%EB%A0%B9%EC%9D%B8%EC%88%98/"><![CDATA[<h1 id="main-함수의-매개변수">📄main 함수의 매개변수</h1>
<ul>
  <li>간혹 int main에 인자값이 <code class="language-plaintext highlighter-rouge">int argc, char** argv</code> 같은게 있는데 이것이 명령인수를 통해 넘겨주는 인자값들 이다.
    <ul>
      <li><strong>argc</strong> : 명령줄 인수의 개수</li>
      <li><strong>argv</strong> : 명령줄 인수의 문자열 배열
        <ul>
          <li>첫번째 값은 실행경로가 들어간다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>그러나 main 함수는 최초 시작 진입점인데 정보를 어떻게 넘겨주는 것일까?</li>
  <li>그것에 대해서 알아보도록 하겠다.</li>
</ul>

<h1 id="명령인수command-line-argument-전달하기">📄명령인수(command line argument) 전달하기</h1>
<h2 id="visual-studio">🔍Visual Studio</h2>
<ul>
  <li><strong>명령인수(Command-line arguments)</strong> 란 외부에서 전달하는 입력 값들을 뜻한다.</li>
  <li>이 값들이 main 함수에 매개변수로 들어오는 값들이다.</li>
  <li>이렇게 명령 인수를 전달하는 방법 중 하나는 Visual Studio로 전달하는 방법이 있다.</li>
</ul>

<hr />

<h3 id="명령인수-설정법">🔍명령인수 설정법</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">프로젝스 속성 페이지 &gt; 구성 속성 &gt; 디버깅</code> 으로 이동한다.</li>
  <li>명령인수를 넣어준다.<br />
<img src="https://github.com/user-attachments/assets/2309c627-dda4-4988-a879-08c907627a74" alt="image" /><em>프로젝스 속성 페이지 &gt; 구성 속성 &gt; 디버깅</em></li>
</ul>

<hr />

<ul>
  <li>아래처럼 명령인수를 출력을 할 수 있다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 명령인수의 개수</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"argc : "</span> <span class="o">&lt;&lt;</span> <span class="n">argc</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

	<span class="c1">// 명령인수의 문자열 출력</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<ul>
  <li>출력값을 보면 5종류의 명령인수를 적었지만 6개가 출력되는 것을 볼 수 있다.</li>
  <li>왜냐하면 명령인자의 첫번째 값은 <strong>실행 경로</strong>가 들어가기 때문이다.<br />
<img src="https://github.com/user-attachments/assets/1c9e226e-c6a0-429f-a76d-7e2f7ce15e86" alt="image" /><em>명령인수 출력 결과</em></li>
</ul>

<h2 id="exe-파일로-넘겨주기">🔍exe 파일로 넘겨주기</h2>
<ul>
  <li>비주얼 스튜디오 명령인수 뿐만 아니라 다른 방식으로도 main에 인자를 넘길 수 있다.</li>
  <li>그것은 .exe 파일을 실행할때 명령인수를 넘겨주며 실행하는 방법이다.</li>
  <li><strong>cmd</strong>에서 exe 파일을 실행하고자 할때 뒤에 명령인수로 넘겨줄 인자값들을 적어준다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/64fb48a4-807e-4b25-be53-6d1eb9990559" alt="image" /><em>exe 출력 결과</em></p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://blog.naver.com/sharonichoya/220501242693">https://blog.naver.com/sharonichoya/220501242693</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ide" /><category term="Visual Studio" /><category term="VS" /><category term="명령인수" /><category term="exe" /><category term="Build" /><category term="command line argument" /><summary type="html"><![CDATA[📄main 함수의 매개변수 간혹 int main에 인자값이 int argc, char** argv 같은게 있는데 이것이 명령인수를 통해 넘겨주는 인자값들 이다. argc : 명령줄 인수의 개수 argv : 명령줄 인수의 문자열 배열 첫번째 값은 실행경로가 들어간다.]]></summary></entry><entry><title type="html">[Obsidian] Anuppuchin테마는 크기가 커지면 엄청 느리다</title><link href="http://localhost:4000/obsidian/Obsidian-%EC%95%84%EB%88%84%ED%91%B8%EC%B9%9C%ED%85%8C%EB%A7%88-%EC%A0%9C%EA%B1%B0/" rel="alternate" type="text/html" title="[Obsidian] Anuppuchin테마는 크기가 커지면 엄청 느리다" /><published>2024-10-24T00:00:00+09:00</published><updated>2024-10-24T00:00:00+09:00</updated><id>http://localhost:4000/obsidian/Obsidian%20%EC%95%84%EB%88%84%ED%91%B8%EC%B9%9C%ED%85%8C%EB%A7%88%20%EC%A0%9C%EA%B1%B0</id><content type="html" xml:base="http://localhost:4000/obsidian/Obsidian-%EC%95%84%EB%88%84%ED%91%B8%EC%B9%9C%ED%85%8C%EB%A7%88-%EC%A0%9C%EA%B1%B0/"><![CDATA[<h2 id="현상">📄현상</h2>
<p>어느 순간부터 옵시디언으로 노트를 작성하면 타이핑 속도가 굉장히 느려지는 것이 느껴졌다. 특히 Bullet Point나 리스트로 작성하면 속도가 현저히 느려져 화면이 툭툭 끊기는 것이 심해졌다.</p>

<h2 id="원인">🔍원인</h2>
<p>개발자모드를 통해 확인하니 화면을 새로 그리는 Task부분에서 시간이 많이 걸리는데 그 부분마저 한계치를 넘어서 강제로 작업을 끊는 것으로 보였다.</p>

<p>결국 문제는 Anuppuchin테마의 문제였는데 플러그인, CSS 설정 모든 것을 건드려봐도 Anuppuchin 테마를 뺴는 것보다 더 효과적인것은 없었다. 방법을 어떻게든 찾고 싶었으나 답을 찾지 못하였고 결국 Minimal 테마로 옮겼다.</p>

<h2 id="결과">🚀결과</h2>
<p>사실 아누푸친테마의 가장 큰 장점이 <strong>레인보우 폴더</strong>라고 생각하는데 나는 그정도로 화려한 기능을 필요없고 간단하게 텍스트의 색상만 바꾸는 것을 원하니까 변경해도 큰 문제는 없는 것으로 보인다.</p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="obsidian" /><category term="Obsidian" /><category term="옵시디언" /><category term="테마" /><category term="Theme" /><category term="최적화" /><category term="Optimize" /><category term="속도" /><category term="아누푸친" /><category term="Anuppuchine" /><category term="Minimal" /><category term="미니멀" /><summary type="html"><![CDATA[📄현상 어느 순간부터 옵시디언으로 노트를 작성하면 타이핑 속도가 굉장히 느려지는 것이 느껴졌다. 특히 Bullet Point나 리스트로 작성하면 속도가 현저히 느려져 화면이 툭툭 끊기는 것이 심해졌다.]]></summary></entry><entry><title type="html">[Geometry] 선과 점사이 거리를 구하는 법</title><link href="http://localhost:4000/geometry/Math-%EC%84%A0%EA%B3%BC-%EC%A0%90%EC%82%AC%EC%9D%B4%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B5%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Geometry] 선과 점사이 거리를 구하는 법" /><published>2024-10-24T00:00:00+09:00</published><updated>2024-10-24T00:00:00+09:00</updated><id>http://localhost:4000/geometry/Math%20%EC%84%A0%EA%B3%BC%20%EC%A0%90%EC%82%AC%EC%9D%B4%EC%9D%98%20%EA%B1%B0%EB%A6%AC%20%EA%B5%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/geometry/Math-%EC%84%A0%EA%B3%BC-%EC%A0%90%EC%82%AC%EC%9D%B4%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B5%AC%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="선분과-점사이의-거리-구하기">선분과 점사이의 거리 구하기</h2>
<ul>
  <li>평행사변형의 넓이 공식을 이용한다.
    <ul>
      <li>(넓이) = 밑변 X 높이</li>
    </ul>
  </li>
  <li>외적은 두직선으로 이루어진 평행사변형의 넓이이다.</li>
  <li>평행사변형의 넓이는 밑변 X 높이인데 여기서 한 선분의 밑변을 나누면 높이만 남아 거리를 구할 수 있다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/3797b212-f5d9-4684-bf2f-60925b87d4ad" alt="image" /></p>

<h3 id="코드">코드</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">float</span> <span class="nf">Distance</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">Point</span> <span class="n">p1</span> <span class="p">=</span> <span class="n">End</span> <span class="p">-</span> <span class="n">Start</span><span class="p">,</span> <span class="n">p2</span> <span class="p">=</span> <span class="n">p</span> <span class="p">-</span> <span class="n">Start</span><span class="p">;</span>  
    <span class="k">return</span> <span class="n">MathUtility</span><span class="p">.</span><span class="nf">Cross2D</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="p">/</span> <span class="n">p1</span><span class="p">.</span><span class="nf">Magnitude</span><span class="p">();</span>  
<span class="p">}</span>
</code></pre></div></div>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="geometry" /><category term="Geometry" /><category term="기하학" /><category term="선분" /><category term="선" /><category term="길이" /><category term="Distance" /><category term="속도" /><category term="Line" /><category term="Point" /><category term="Parallelogram" /><summary type="html"><![CDATA[선분과 점사이의 거리 구하기 평행사변형의 넓이 공식을 이용한다. (넓이) = 밑변 X 높이 외적은 두직선으로 이루어진 평행사변형의 넓이이다. 평행사변형의 넓이는 밑변 X 높이인데 여기서 한 선분의 밑변을 나누면 높이만 남아 거리를 구할 수 있다.]]></summary></entry></feed>