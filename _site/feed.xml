<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-12-12T13:37:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mohitto55 Note</title><subtitle>모히또의 노트</subtitle><author><name>Mohitto55</name></author><entry><title type="html">[Visual Studio] 명령인수 개념과 exe파일에서 넘겨주는 법</title><link href="http://localhost:4000/ide/IDE-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4-%EB%AA%85%EB%A0%B9%EC%9D%B8%EC%88%98/" rel="alternate" type="text/html" title="[Visual Studio] 명령인수 개념과 exe파일에서 넘겨주는 법" /><published>2024-12-12T00:00:00+09:00</published><updated>2024-12-12T00:00:00+09:00</updated><id>http://localhost:4000/ide/%5BIDE%5D%EB%B9%84%EC%A3%BC%EC%96%BC%20%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4%20%EB%AA%85%EB%A0%B9%EC%9D%B8%EC%88%98</id><content type="html" xml:base="http://localhost:4000/ide/IDE-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4-%EB%AA%85%EB%A0%B9%EC%9D%B8%EC%88%98/"><![CDATA[<h1 id="main-함수의-매개변수">📄main 함수의 매개변수</h1>
<ul>
  <li>간혹 int main에 인자값이 <code class="language-plaintext highlighter-rouge">int argc, char** argv</code> 같은게 있는데 이것이 명령인수를 통해 넘겨주는 인자값들 이다.
    <ul>
      <li><strong>argc</strong> : 명령줄 인수의 개수</li>
      <li><strong>argv</strong> : 명령줄 인수의 문자열 배열
        <ul>
          <li>첫번째 값은 실행경로가 들어간다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>그러나 main 함수는 최초 시작 진입점인데 정보를 어떻게 넘겨주는 것일까?</li>
  <li>그것에 대해서 알아보도록 하겠다.</li>
</ul>

<h1 id="명령인수command-line-argument-전달하기">📄명령인수(command line argument) 전달하기</h1>
<h2 id="visual-studio">🔍Visual Studio</h2>
<ul>
  <li><strong>명령인수(Command-line arguments)</strong> 란 외부에서 전달하는 입력 값들을 뜻한다.</li>
  <li>이 값들이 main 함수에 매개변수로 들어오는 값들이다.</li>
  <li>이렇게 명령 인수를 전달하는 방법 중 하나는 Visual Studio로 전달하는 방법이 있다.</li>
</ul>

<hr />

<h3 id="명령인수-설정법">🔍명령인수 설정법</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">프로젝스 속성 페이지 &gt; 구성 속성 &gt; 디버깅</code> 으로 이동한다.</li>
  <li>명령인수를 넣어준다.<br />
<img src="https://github.com/user-attachments/assets/2309c627-dda4-4988-a879-08c907627a74" alt="image" /><em>프로젝스 속성 페이지 &gt; 구성 속성 &gt; 디버깅</em></li>
</ul>

<hr />

<ul>
  <li>아래처럼 명령인수를 출력을 할 수 있다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 명령인수의 개수</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"argc : "</span> <span class="o">&lt;&lt;</span> <span class="n">argc</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

	<span class="c1">// 명령인수의 문자열 출력</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<ul>
  <li>출력값을 보면 5종류의 명령인수를 적었지만 6개가 출력되는 것을 볼 수 있다.</li>
  <li>왜냐하면 명령인자의 첫번째 값은 <strong>실행 경로</strong>가 들어가기 때문이다.<br />
<img src="https://github.com/user-attachments/assets/1c9e226e-c6a0-429f-a76d-7e2f7ce15e86" alt="image" /><em>명령인수 출력 결과</em></li>
</ul>

<h2 id="exe-파일로-넘겨주기">🔍exe 파일로 넘겨주기</h2>
<ul>
  <li>비주얼 스튜디오 명령인수 뿐만 아니라 다른 방식으로도 main에 인자를 넘길 수 있다.</li>
  <li>그것은 .exe 파일을 실행할때 명령인수를 넘겨주며 실행하는 방법이다.</li>
  <li><strong>cmd</strong>에서 exe 파일을 실행하고자 할때 뒤에 명령인수로 넘겨줄 인자값들을 적어준다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/64fb48a4-807e-4b25-be53-6d1eb9990559" alt="image" /><em>exe 출력 결과</em></p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://blog.naver.com/sharonichoya/220501242693">https://blog.naver.com/sharonichoya/220501242693</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ide" /><category term="Visual Studio" /><category term="VS" /><category term="명령인수" /><category term="exe" /><category term="Build" /><category term="command line argument" /><summary type="html"><![CDATA[📄main 함수의 매개변수 간혹 int main에 인자값이 int argc, char** argv 같은게 있는데 이것이 명령인수를 통해 넘겨주는 인자값들 이다. argc : 명령줄 인수의 개수 argv : 명령줄 인수의 문자열 배열 첫번째 값은 실행경로가 들어간다.]]></summary></entry><entry><title type="html">[Visual Studio] Visual Studio에서 빌드exe 파일 뽑는 법</title><link href="http://localhost:4000/ide/IDE-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4%EB%A1%9C-%EB%B9%8C%EB%93%9Cexe%ED%8C%8C%EC%9D%BC-%EB%BD%91%EA%B8%B0/" rel="alternate" type="text/html" title="[Visual Studio] Visual Studio에서 빌드exe 파일 뽑는 법" /><published>2024-12-12T00:00:00+09:00</published><updated>2024-12-12T00:00:00+09:00</updated><id>http://localhost:4000/ide/%5BIDE%5D%EB%B9%84%EC%A3%BC%EC%96%BC%20%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4%EB%A1%9C%20%EB%B9%8C%EB%93%9Cexe%ED%8C%8C%EC%9D%BC%20%EB%BD%91%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/ide/IDE-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4%EB%A1%9C-%EB%B9%8C%EB%93%9Cexe%ED%8C%8C%EC%9D%BC-%EB%BD%91%EA%B8%B0/"><![CDATA[<h2 id="why">📄Why</h2>
<ul>
  <li>프로그래밍 과제를 하는데 명령인수를 server-name으로 적으라고 했는데 서버인수가 무엇인지 몰랐다.</li>
  <li>그래서 명령인수에 대한 설명을 적다가 int main의 인자 값이 명령인수 뿐만 아니라 exe 파일에 인수를 넘기는 방식으로도 활용 할 수 있는 법을 알게되었고 그러다 exe 파일을 뽑는 방법을 정리하게 되었다.</li>
</ul>

<h2 id="빌드-파일-만들기">빌드 파일 만들기</h2>
<h3 id="솔루션-정리">🔍솔루션 정리</h3>
<ul>
  <li>빌드 탭에서 <code class="language-plaintext highlighter-rouge">솔루션정리(C)</code>를 누른다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/ab9fbbff-585e-435f-84de-0a63877e8536" alt="image" /></p>

<div class="callout-info-expanded">
<div class="callout-header">솔루션 정리</div>
<p>
기타 파일, 출력 파일을 삭제합니다.<br />
솔루션 정리 후 빌드를 하면 중간 파일과 출력 파일이 새로 생성됩니다.<br />
이를 통해 오류, 경고가 있는지 확인하고 다시 빌드를 하는 효과를 볼 수 있습니다.
</p>
</div>

<hr />

<h3 id="출력-준비-및-경로-설정">🔍출력 준비 및 경로 설정</h3>
<ul>
  <li>
    <p>상단 <code class="language-plaintext highlighter-rouge">프로젝트 &gt; 프로젝트 속성</code> 을 선택한다.<br />
<img src="https://github.com/user-attachments/assets/28b5793b-abe3-4d78-8ba4-9eef2c8be8be" alt="image" /></p>
  </li>
  <li>상단 구성에서 Release로 변경한다.</li>
  <li>출력 디렉터리에서 파일을 출력할 경로를 작성한다.<br />
<img src="https://github.com/user-attachments/assets/c577f535-6b72-4856-b7e9-f186b4ec96f6" alt="image" /></li>
</ul>

<hr />

<h3 id="솔루션-다시-정리">🔍솔루션 다시 정리</h3>
<ul>
  <li>빌드 탭에서 <code class="language-plaintext highlighter-rouge">솔루션정리(C)</code>를 한번 더 누른다.<br />
<img src="https://github.com/user-attachments/assets/ab9fbbff-585e-435f-84de-0a63877e8536" alt="image" /></li>
</ul>

<hr />

<h3 id="일괄-빌드">🔍일괄 빌드</h3>
<p><img src="https://github.com/user-attachments/assets/56760441-fb4d-478f-abe9-e9bf076523e6" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/730fed52-a777-44d0-943c-d9b34791d691" alt="image" /></p>

<h2 id="결과">🚀결과</h2>
<ul>
  <li>컨트롤 B를 눌러 빌드를 하면 출력디렉토리 경로에 .exe 파일이 생성된다.<br />
<img src="https://github.com/user-attachments/assets/f28d4ce7-31c3-4205-9445-5076ecb38fc7" alt="image" /></li>
</ul>

<p><img src="https://github.com/user-attachments/assets/25f1f69b-6623-4b9b-8250-3119d570be2a" alt="image" /></p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://splendidlolli.tistory.com/25">https://splendidlolli.tistory.com/25</a>
<a href=" https://heroeskdw.tistory.com/entry/%EC%BD%94%EB%94%A9c-%EB%AA%85%EB%A0%B9-%EC%9D%B8%EC%88%98-%EB%B0%9B%EA%B8%B0"> https://heroeskdw.tistory.com/entry/%EC%BD%94%EB%94%A9c-%EB%AA%85%EB%A0%B9-%EC%9D%B8%EC%88%98-%EB%B0%9B%EA%B8%B0</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ide" /><category term="Obsidian" /><category term="옵시디언" /><category term="테마" /><category term="Theme" /><category term="최적화" /><category term="Optimize" /><category term="속도" /><category term="아누푸친" /><category term="Anuppuchine" /><category term="Minimal" /><category term="미니멀" /><summary type="html"><![CDATA[📄Why 프로그래밍 과제를 하는데 명령인수를 server-name으로 적으라고 했는데 서버인수가 무엇인지 몰랐다. 그래서 명령인수에 대한 설명을 적다가 int main의 인자 값이 명령인수 뿐만 아니라 exe 파일에 인수를 넘기는 방식으로도 활용 할 수 있는 법을 알게되었고 그러다 exe 파일을 뽑는 방법을 정리하게 되었다.]]></summary></entry><entry><title type="html">[Geometry] 외적을 이용해 선분간의 교차점을 구하는 방법</title><link href="http://localhost:4000/geometry/Geometry-%EC%84%A0%EB%B6%84-%EB%81%BC%EB%A6%AC%EC%9D%98-%EA%B5%90%EC%B0%A8%EC%A0%90-%EA%B5%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Geometry] 외적을 이용해 선분간의 교차점을 구하는 방법" /><published>2024-10-24T00:00:00+09:00</published><updated>2024-10-24T00:00:00+09:00</updated><id>http://localhost:4000/geometry/Geometry%20%EC%84%A0%EB%B6%84%20%EB%81%BC%EB%A6%AC%EC%9D%98%20%EA%B5%90%EC%B0%A8%EC%A0%90%20%EA%B5%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/geometry/Geometry-%EC%84%A0%EB%B6%84-%EB%81%BC%EB%A6%AC%EC%9D%98-%EA%B5%90%EC%B0%A8%EC%A0%90-%EA%B5%AC%ED%95%98%EA%B8%B0/"><![CDATA[<h1 id="외적을-이용한-선분과-선분의-교차점-구하기">📄외적을 이용한 선분과 선분의 교차점 구하기</h1>

<p>선분은 기하를 구성하는 <strong>기본요소</strong>이기 때문에 선분의 교차점을 구하는 것은 기하 문제의 기본입니다. 이런 선분의 교차점은 다양한 곳에서 사용 할 수 있습니다.</p>

<p>하지만 교차점을 구하는 것은 여러 변수들이 존재해서 생각보다 까다롭습니다.</p>

<h2 id="️직선과-직선의-교차점">✏️직선과 직선의 교차점</h2>

<p>선분은 직선의 일부분이기에 먼저 직선과 직선의 교차점을 구합니다.</p>

<p>좌표평면에서 두 직선에 대한 방정식을 x, y에 대해 세우고 <strong>연립 방정식</strong>을 푸는 것을 코드로 작성 할 수 있다. 하지만 그러면 수평과 수직에 대한 예외를 따로 처리해야해 코드가 간결하지 못합니다.</p>

<p>그렇다면 두 직선을 <strong>벡터로 표현</strong> 하고 벡터의 연산을 이용해 연립방정식을 풀면 외적으로 표현된 간결한 해를 얻을 수 있습니다.</p>

<hr />

<h3 id="️방정식-풀이1">✏️방정식 풀이1</h3>

<p>\(\overrightarrow{a_x} + p\overrightarrow{b_x} = \overrightarrow{c_x} + q\overrightarrow{d_x}\)<br />
\(\overrightarrow{a_y} + p\overrightarrow{b_y} = \overrightarrow{c_y} + q\overrightarrow{d_y}\)</p>

<p>이 연립방정식을 p에 대해 풀면 다음과 같습니다.<br />
이 때 분모가 0인 경우는 두 직선이 <strong>평행</strong>한 경우로 교점이 정의되지 않습니다.</p>

\[p = \frac{(c_x-a_x)d_{y}- (c_y-a_y)d_x}{b_xd_y-b_yd_x}\]

<p>이제 p를 외적으로 더 간략하게 나타낼 수 있습니다.<br />
\(p=\frac{(\overrightarrow{c}-\overrightarrow{a})\times\overrightarrow{d}}{\overrightarrow{b}\times\overrightarrow{d} }(\overrightarrow{b}\times\overrightarrow{d}\neq  0)\)</p>

<hr />

<h4 id="코드">💻코드</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 점 a, b를 지나는 직선과 점 c, d를 지나는 직선의 교차점 x를 반환한다.  </span>
<span class="c1">// 두 직선이 평행하면 false, 아니면 true를 반환한다.  </span>
<span class="k">public</span> <span class="kt">bool</span> <span class="nf">lineIntersection</span><span class="p">(</span><span class="n">Vector2</span> <span class="n">a</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">b</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">c</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">d</span><span class="p">,</span> <span class="n">ref</span> <span class="n">Vector2</span> <span class="n">x</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="c1">// 분모  </span>
    <span class="kt">float</span> <span class="n">det</span> <span class="o">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">Cross</span><span class="p">((</span><span class="n">Vector3</span><span class="p">)(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">)(</span><span class="n">d</span> <span class="o">-</span> <span class="n">c</span><span class="p">)).</span><span class="n">z</span><span class="p">;</span>  
    <span class="c1">// 두 직선이 평행한 경우라면  </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Mathf</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.00005</span><span class="n">f</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  
    <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Cross</span><span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">det</span><span class="p">);</span>  
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="k">public</span> <span class="kt">float</span> <span class="nf">Cross</span><span class="p">(</span><span class="n">Vector2</span> <span class="n">a</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">b</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">return</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">Cross</span><span class="p">((</span><span class="n">Vector3</span><span class="p">)</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">Vector3</span><span class="p">)</span><span class="n">b</span><span class="p">).</span><span class="n">z</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div></div>

<hr />
<h3 id="️방정식-풀이2">✏️방정식 풀이2</h3>

<p>선분의 시작점을 $S_1$과 $S_2$이라고 하고  $S_{1}+ tP_{1}, S_{2}+ uP_2$ 으로 각각 두 선분 상의 임의의 점으로 나타낼 수 있습니다. 그렇다는 것은 $S_{1}+ tP_{1}= S_{2}+ uP_2$ 일때가 두 선분이 교차하는 지점이라는 뜻이고 u와 t에 대해서 방정식을 풀 수있다면 교차점을 구할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">t</code>나 <code class="language-plaintext highlighter-rouge">u</code>를 구하기 위해서는 두 변수 중 하나를 제거해야 하며, 이를 외적을 통해 해결할 수 있습니다. 외적은 두 벡터가 평행할 때 0이 되는 성질을 이용합니다. 따라서 <code class="language-plaintext highlighter-rouge">t</code>와 곱해져 있는 벡터와 동일한 벡터를 양쪽에 외적해 주면 됩니다. 자기 자신을 외적하면 0이 되기 때문에, 양쪽에 <code class="language-plaintext highlighter-rouge">P₁</code>이나 <code class="language-plaintext highlighter-rouge">P₂</code>를 외적하여 구할 수 있습니다.</p>

<p>\(S_{1}+ tP_{1}= S_{2}+ uP_2\)<br />
\((S_{1}+ tP_{1})\times P_{1}= (S_{2}+ uP_{2)} \times P_1\)<br />
\(S_{1} \times P_{1}= S_{2} \times P_{1}+ u(P_{2}\times P_1)\)<br />
\(\frac{(S_{1}  - S_{2}) \times P_1}{P_{2} \times P_{1}}= u\)</p>

<p>\(S_{1}+ tP_{1}= S_{2}+ uP_2\)<br />
\((S_{1}+ tP_{1})\times P_{2}= (S_{2}+ uP_{2)} \times P_2\)<br />
\(S_{2}  + P_{2}= S_{1} \times P_{2}+ t(P_{1}\times P_2)\)<br />
\(\frac{(S_{2}  - S_{1}) \times P_2}{P_{1} \times P_{2}}= t\)</p>

<p><img src="https://github.com/user-attachments/assets/c86b4c1a-c742-4e0e-8366-25365fe1b61c" alt="화면 캡처 2024-10-21 144113 (1)" /><em>방정식 풀이</em></p>

<hr />

<h4 id="코드-1">💻코드</h4>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">IsIntersectingSegments</span><span class="p">(</span><span class="n">Segment</span> <span class="n">s</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">includeEndPoints</span> <span class="p">=</span> <span class="k">true</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">Point</span> <span class="n">p1</span> <span class="p">=</span> <span class="n">End</span> <span class="p">-</span> <span class="n">Start</span><span class="p">,</span> <span class="n">p2</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">End</span> <span class="p">-</span> <span class="n">s</span><span class="p">.</span><span class="n">Start</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">rxs</span> <span class="p">=</span> <span class="nf">Cross</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>  
    <span class="c1">// 두 선분이 평행하면 false다  </span>
    <span class="k">if</span> <span class="p">(</span><span class="nf">FloatZero</span><span class="p">(</span><span class="n">rxs</span><span class="p">))</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>  
      
    <span class="c1">// a_x + ub_x = c_x + td_x    // a_y + ub_y = c_y + td_y    // 이 식을 u나 t에대해서 풀고 외적으로 표현할 수도 있고  </span>
    <span class="c1">// a + ub = c + td  </span>
    <span class="c1">// (a + ub) X b = (c + td) X b : X는 외적  </span>
    <span class="c1">// 각각 b나 d를 외적해서 u나 b 하나를 없애고 나머지 하나에 대해서 연립해서 풀수도 있다.  </span>
    <span class="kt">float</span> <span class="n">u</span> <span class="p">=</span> <span class="nf">Cross</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Start</span> <span class="p">-</span> <span class="n">s</span><span class="p">.</span><span class="n">Start</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span> <span class="p">/</span> <span class="p">-</span><span class="n">rxs</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">Cross</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Start</span> <span class="p">-</span> <span class="k">this</span><span class="p">.</span><span class="n">Start</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="p">/</span> <span class="n">rxs</span><span class="p">;</span>  
  
    <span class="c1">// u와 t는 각각의 선분에서의 보간(Lerp) 비율을 나타내는 값이다.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">includeEndPoints</span><span class="p">)</span> <span class="k">return</span> <span class="n">u</span> <span class="p">&gt;=</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">u</span> <span class="p">&lt;=</span>  <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="n">t</span> <span class="p">&gt;=</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">t</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">;</span>  
    <span class="c1">// 교차점이 끝에 걸려있는지 체크한다.  </span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">u</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">u</span> <span class="p">&lt;</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="n">t</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">t</span> <span class="p">&lt;</span> <span class="m">1</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 교차점을 구하는 함수  </span>
<span class="k">public</span> <span class="n">Point</span> <span class="nf">Intersection</span><span class="p">(</span><span class="n">Segment</span> <span class="n">s</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="n">is</span> <span class="n">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">IsIntersectingSegments</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="k">return</span> <span class="n">null</span><span class="p">;</span>  
    <span class="c1">// 겹쳐져 있다면 결국 두 선분 사이에 있다는 뜻  </span>
    <span class="c1">// 그러니 교차점의 t(alpha) 값을 구하는 공식을 써서 교차점을 반환해준다.  </span>
    <span class="n">Point</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">End</span> <span class="o">-</span> <span class="n">Start</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">End</span> <span class="o">-</span> <span class="n">s</span><span class="p">.</span><span class="n">Start</span><span class="p">;</span>  
    <span class="kt">float</span> <span class="n">rxs</span> <span class="o">=</span> <span class="n">Cross</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>  
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Cross</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Start</span> <span class="o">-</span> <span class="n">Start</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="o">/</span> <span class="n">rxs</span><span class="p">;</span>  
    <span class="k">return</span> <span class="n">Start</span> <span class="o">+</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="o">*</span> <span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>  
<span class="p">}</span>
</code></pre></div></div>

<h2 id="️선분과-선분의-교차점">✏️선분과 선분의 교차점</h2>

<p>선분은 생각외로 직선보다 고려해야할 사항이 많습니다.<br />
<strong>두 선분이 모두 한 직선 위에 있는 경우</strong>에 처리하기가 힘듭니다.</p>
<ul>
  <li>두 선분이 서로 겹치지 않는다</li>
  <li>두 선분이 한점에 닿는다</li>
  <li>두 선분이 겹쳐진다</li>
  <li>한 선분이 다른 선분안에 포함된다<br />
원래는 첫번째의 경우만 겹쳐지지 않지만 위에서 작성한 코드로는 2,3,4도 겹쳐지지 않았다고 판별하기 때문입니다.<br />
<img src="https://github.com/user-attachments/assets/b80d5666-a0dc-4ad9-a46b-40a704d52b09" alt="image" /></li>
</ul>

<hr />

<h3 id="코드-2">💻코드</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 선분 a, b 선분 c, d가 평행하면 한 점에서 겹치는지 확인한다.  </span>
<span class="kt">bool</span> <span class="nf">paralleSegments</span><span class="p">(</span><span class="n">Vector2</span> <span class="n">a</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">b</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">c</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">d</span><span class="p">,</span> <span class="k">ref</span> <span class="n">Vector2</span> <span class="n">p</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="k">ref</span> <span class="n">a</span><span class="p">,</span> <span class="k">ref</span> <span class="n">b</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> <span class="n">d</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="k">ref</span> <span class="n">c</span><span class="p">,</span> <span class="k">ref</span> <span class="n">d</span><span class="p">);</span>  
  
    <span class="c1">// 한 직선위에 없거나 두 선분이 겹치지 않는 경우를 우선 걸러낸다.  </span>
    <span class="k">if</span> <span class="p">(</span><span class="nf">ccw</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="p">!=</span> <span class="m">0</span> <span class="p">||</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> <span class="n">d</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>  
      
    <span class="c1">// 두 선분이 겹친다면 교차점 하나를 찾는다.  </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="n">p</span> <span class="p">=</span> <span class="n">c</span><span class="p">;</span>  
    <span class="k">else</span> <span class="n">p</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>  
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>  
<span class="p">}</span>  
  
<span class="c1">// - p가 두 점 a, b를 감싸면서 각 변이 x, y축에 평행한 최소사각형 내부에 있는지 확인한다.  </span>
<span class="c1">// a, b, p는 일직선 상에 있다고 가정한다.  </span>
<span class="kt">bool</span> <span class="nf">inBoundingRectangle</span><span class="p">(</span><span class="n">Vector2</span> <span class="n">p</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">a</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">b</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="k">ref</span> <span class="n">a</span><span class="p">,</span> <span class="k">ref</span> <span class="n">b</span><span class="p">);</span>  
    <span class="k">return</span> <span class="n">p</span> <span class="p">==</span> <span class="n">a</span> <span class="p">||</span> <span class="n">p</span> <span class="p">==</span> <span class="n">b</span> <span class="p">||</span> <span class="p">((</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="p">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="p">&amp;&amp;</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>  
<span class="p">}</span>  
  
<span class="c1">// - 두 점 a, b를 지나는 선분과 두 점 c, b를 지나는 선분을 p에 반환한다.  </span>
<span class="c1">// - 교점이 여러개일 경우 아무점이나 반환한다.  </span>
<span class="kt">bool</span> <span class="nf">segmentIntersection</span><span class="p">(</span><span class="n">Vector2</span> <span class="n">a</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">b</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">c</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">d</span><span class="p">,</span> <span class="k">ref</span> <span class="n">Vector2</span> <span class="n">p</span><span class="p">){</span>      
    <span class="c1">//두 직선이 평행인 경우를 우선 예외로 처리한다.  </span>
    <span class="k">if</span><span class="p">(!</span><span class="nf">lineIntersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="k">ref</span> <span class="n">p</span><span class="p">))</span>          
        <span class="k">return</span> <span class="nf">paralleSegments</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="k">ref</span> <span class="n">p</span><span class="p">);</span>      
    <span class="c1">//p가 두 선분에 포함되어 있는 경우에만 참을 반환한다.  </span>
    <span class="k">return</span> <span class="nf">inBoundingRectangle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="nf">inBoundingRectangle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>  
<span class="p">}</span>
</code></pre></div></div>

<h2 id="최종-결과물">🚀최종 결과물</h2>
<p><img src="https://github.com/user-attachments/assets/ab4a0405-c74e-40f5-bd29-97de46a4f5f8" alt="Animation" /></p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://00ad-8e71-00ff-055d.tistory.com/98">https://00ad-8e71-00ff-055d.tistory.com/98</a>
<a href="https://bowbowbow.tistory.com/17">https://bowbowbow.tistory.com/17</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="geometry" /><category term="Geometry" /><category term="기하학" /><category term="기하" /><category term="선분" /><category term="선" /><category term="길이" /><category term="교차점" /><category term="Intersection" /><category term="Line" /><category term="Point" /><summary type="html"><![CDATA[📄외적을 이용한 선분과 선분의 교차점 구하기]]></summary></entry><entry><title type="html">[Obsidian] Anuppuchin테마는 크기가 커지면 엄청 느리다</title><link href="http://localhost:4000/obsidian/Obsidian-%EC%95%84%EB%88%84%ED%91%B8%EC%B9%9C%ED%85%8C%EB%A7%88-%EC%A0%9C%EA%B1%B0/" rel="alternate" type="text/html" title="[Obsidian] Anuppuchin테마는 크기가 커지면 엄청 느리다" /><published>2024-10-24T00:00:00+09:00</published><updated>2024-10-24T00:00:00+09:00</updated><id>http://localhost:4000/obsidian/Obsidian%20%EC%95%84%EB%88%84%ED%91%B8%EC%B9%9C%ED%85%8C%EB%A7%88%20%EC%A0%9C%EA%B1%B0</id><content type="html" xml:base="http://localhost:4000/obsidian/Obsidian-%EC%95%84%EB%88%84%ED%91%B8%EC%B9%9C%ED%85%8C%EB%A7%88-%EC%A0%9C%EA%B1%B0/"><![CDATA[<h2 id="현상">📄현상</h2>
<p>어느 순간부터 옵시디언으로 노트를 작성하면 타이핑 속도가 굉장히 느려지는 것이 느껴졌다. 특히 Bullet Point나 리스트로 작성하면 속도가 현저히 느려져 화면이 툭툭 끊기는 것이 심해졌다.</p>

<h2 id="원인">🔍원인</h2>
<p>개발자모드를 통해 확인하니 화면을 새로 그리는 Task부분에서 시간이 많이 걸리는데 그 부분마저 한계치를 넘어서 강제로 작업을 끊는 것으로 보였다.</p>

<p>결국 문제는 Anuppuchin테마의 문제였는데 플러그인, CSS 설정 모든 것을 건드려봐도 Anuppuchin 테마를 뺴는 것보다 더 효과적인것은 없었다. 방법을 어떻게든 찾고 싶었으나 답을 찾지 못하였고 결국 Minimal 테마로 옮겼다.</p>

<h2 id="결과">🚀결과</h2>
<p>사실 아누푸친테마의 가장 큰 장점이 <strong>레인보우 폴더</strong>라고 생각하는데 나는 그정도로 화려한 기능을 필요없고 간단하게 텍스트의 색상만 바꾸는 것을 원하니까 변경해도 큰 문제는 없는 것으로 보인다.</p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="obsidian" /><category term="Obsidian" /><category term="옵시디언" /><category term="테마" /><category term="Theme" /><category term="최적화" /><category term="Optimize" /><category term="속도" /><category term="아누푸친" /><category term="Anuppuchine" /><category term="Minimal" /><category term="미니멀" /><summary type="html"><![CDATA[📄현상 어느 순간부터 옵시디언으로 노트를 작성하면 타이핑 속도가 굉장히 느려지는 것이 느껴졌다. 특히 Bullet Point나 리스트로 작성하면 속도가 현저히 느려져 화면이 툭툭 끊기는 것이 심해졌다.]]></summary></entry><entry><title type="html">[Geometry] 선과 점사이 거리를 구하는 법</title><link href="http://localhost:4000/geometry/Math-%EC%84%A0%EA%B3%BC-%EC%A0%90%EC%82%AC%EC%9D%B4%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B5%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Geometry] 선과 점사이 거리를 구하는 법" /><published>2024-10-24T00:00:00+09:00</published><updated>2024-10-24T00:00:00+09:00</updated><id>http://localhost:4000/geometry/Math%20%EC%84%A0%EA%B3%BC%20%EC%A0%90%EC%82%AC%EC%9D%B4%EC%9D%98%20%EA%B1%B0%EB%A6%AC%20%EA%B5%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/geometry/Math-%EC%84%A0%EA%B3%BC-%EC%A0%90%EC%82%AC%EC%9D%B4%EC%9D%98-%EA%B1%B0%EB%A6%AC-%EA%B5%AC%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="선분과-점사이의-거리-구하기">선분과 점사이의 거리 구하기</h2>
<ul>
  <li>평행사변형의 넓이 공식을 이용한다.
    <ul>
      <li>(넓이) = 밑변 X 높이</li>
    </ul>
  </li>
  <li>외적은 두직선으로 이루어진 평행사변형의 넓이이다.</li>
  <li>평행사변형의 넓이는 밑변 X 높이인데 여기서 한 선분의 밑변을 나누면 높이만 남아 거리를 구할 수 있다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/3797b212-f5d9-4684-bf2f-60925b87d4ad" alt="image" /></p>

<h3 id="코드">코드</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">float</span> <span class="nf">Distance</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="n">Point</span> <span class="n">p1</span> <span class="p">=</span> <span class="n">End</span> <span class="p">-</span> <span class="n">Start</span><span class="p">,</span> <span class="n">p2</span> <span class="p">=</span> <span class="n">p</span> <span class="p">-</span> <span class="n">Start</span><span class="p">;</span>  
    <span class="k">return</span> <span class="n">MathUtility</span><span class="p">.</span><span class="nf">Cross2D</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="p">/</span> <span class="n">p1</span><span class="p">.</span><span class="nf">Magnitude</span><span class="p">();</span>  
<span class="p">}</span>
</code></pre></div></div>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="geometry" /><category term="Geometry" /><category term="기하학" /><category term="선분" /><category term="선" /><category term="길이" /><category term="Distance" /><category term="속도" /><category term="Line" /><category term="Point" /><category term="Parallelogram" /><summary type="html"><![CDATA[선분과 점사이의 거리 구하기 평행사변형의 넓이 공식을 이용한다. (넓이) = 밑변 X 높이 외적은 두직선으로 이루어진 평행사변형의 넓이이다. 평행사변형의 넓이는 밑변 X 높이인데 여기서 한 선분의 밑변을 나누면 높이만 남아 거리를 구할 수 있다.]]></summary></entry><entry><title type="html">[UE5] 컴파일시 MSB3073오류 해결하기</title><link href="http://localhost:4000/ue5/Unreal-MSB3073-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0%EB%B2%94/" rel="alternate" type="text/html" title="[UE5] 컴파일시 MSB3073오류 해결하기" /><published>2024-10-10T00:00:00+09:00</published><updated>2024-10-10T00:00:00+09:00</updated><id>http://localhost:4000/ue5/Unreal%20MSB3073%20%EC%98%A4%EB%A5%98%20%ED%95%B4%EA%B2%B0%EB%B2%94</id><content type="html" xml:base="http://localhost:4000/ue5/Unreal-MSB3073-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0%EB%B2%94/"><![CDATA[<h2 id="발생과정">발생과정</h2>
<p>프로젝트를 최초 생성하고 컴파일 하려하면 이런 오류가 뜬다 왜 이럴까?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1&gt;Microsoft.MakeFile.Targets(44,5): Error MSB3073 : ""C:\Program Files\Epic Games\UE_5.4\Engine\Build\BatchFiles\Build.bat" MultiShooterEditor Win64 Development -Project="C:\Users\admin\git\UE5\MultiShooter\MultiShooter.uproject" -WaitMutex -FromMsBuild -architecture=x64" 명령이 종료되었습니다(코드: 6).
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;------ 빌드 시작: 프로젝트: MultiShooter, 구성: Development_Editor x64 ------ 1&gt;Using bundled DotNet SDK version: 6.0.302 1&gt;Running UnrealBuildTool: dotnet "..\..\Engine\Binaries\DotNET\UnrealBuildTool\UnrealBuildTool.dll" MultiShooterEditor Win64 Development -Project="C:\MultiShooter\MultiShooter.uproject" -WaitMutex -FromMsBuild -architecture=x64 1&gt;Log file: C:\Users\admin\AppData\Local\UnrealBuildTool\Log.txt 1&gt;Creating makefile for MultiShooterEditor (no existing makefile) 1&gt;Visual Studio 2022 is installed, but is missing the C++ toolchain. Please verify that the "MSVC v143 - VS 2022 C++ x64/x86 build tools (Latest)" component is selected in the Visual Studio 2022 installation options. 1&gt;Total execution time: 0.76 seconds 1&gt;UnrealBuildTool has banned the MSVC 14.39.33519-14.39.99999 toolchains due to compiler issues. Please install a different toolchain such as 14.38.33130 by opening the generated solution and installing recommended components or from the Visual Studio installer. 1&gt;C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Microsoft\VC\v170\Microsoft.MakeFile.Targets(44,5): error MSB3073: ""C:\Program Files\Epic Games\UE_5.4\Engine\Build\BatchFiles\Build.bat" MultiShooterEditor Win64 Development -Project="C:\MultiShooter\MultiShooter.uproject" -WaitMutex -FromMsBuild -architecture=x64" 명령이 종료되었습니다(코드: 6). 1&gt;"MultiShooter.vcxproj" 프로젝트를 빌드했습니다. - 실패 ========== 빌드: 0개 성공, 1개 실패, 11개 최신 상태, 0개 건너뜀 ==========
</code></pre></div></div>

<hr />

<h3 id="정확한-오류-확인하기">정확한 오류 확인하기</h3>
<p>비쥬얼 스튜디오에서 출력으로 정확한 로그를 볼 수 있다.</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/cf4baada-ed6c-4521-ba58-5da3ad7b2921" alt="image" /></p>

<hr />

<h3 id="1-경로중-한글-없애기">1. 경로중 한글 없애기</h3>
<p>경로중에 한글이 있다면 오류가 생길 수 있다.<br />
한글로된 폴더 이름을 영어로 변경해준다.</p>

<hr />

<h3 id="2-툴체인-오류">2. 툴체인 오류</h3>
<p>UnrealBuildTool과 다른 <strong>툴체인</strong>을 사용하여 생기는 오류다.<br />
툴체인을 직접 설정해줘야한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnrealBuildTool has banned the MSVC 14.39.33519-14.39.99999 toolchains due to compiler issues. Please install a different toolchain such as 14.38.33130 by opening the generated solution and installing recommended components or from the Visual Studio installer
</code></pre></div></div>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/ccc4b4ab-15a5-4351-95aa-405c37c71a9b" alt="image" /></p>

<div class="callout-info-expanded">
<div class="callout-header">툴체인</div>
<p>
툴체인은 개발자가 코드를 작성하고 빌드하여 실행 가능한 프로그램을 만들기 위해 사용하는 모든 도구들을 의미합니다. 코드를 어떻게 빌드하고, 링크하며, 디버깅할지에 대한 정보를 제공합니다
</p>
</div>

<h2 id="해결완료">해결완료</h2>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/b23de2e7-bd3a-4cd2-9483-f84ccc851120" alt="image" /></p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://learn.microsoft.com/en-us/answers/questions/1163496/code-error-when-building-unreal-engine-5-source-co">https://learn.microsoft.com/en-us/answers/questions/1163496/code-error-when-building-unreal-engine-5-source-co</a>
<a href="https://gall.dcinside.com/mgallery/board/view/?id=gamejob&amp;no=14429">https://gall.dcinside.com/mgallery/board/view/?id=gamejob&amp;no=14429</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE" /><category term="UE5" /><category term="UnrealEngine" /><category term="VisualStudio" /><category term="Vs" /><category term="IDE" /><category term="Build" /><category term="빌드" /><category term="MSB3073" /><category term="컴파일" /><summary type="html"><![CDATA[발생과정 프로젝트를 최초 생성하고 컴파일 하려하면 이런 오류가 뜬다 왜 이럴까?]]></summary></entry><entry><title type="html">[UE5] 프레넬을 활용한 현실감 있는 물 셰이더 만들기</title><link href="http://localhost:4000/ue5/%EC%96%B8%EB%A6%AC%EC%96%BC-%EB%AC%BC%EC%85%B0%EC%9D%B4%EB%8D%94-%EB%B0%8F-%ED%94%84%EB%A0%88%EB%84%AC/" rel="alternate" type="text/html" title="[UE5] 프레넬을 활용한 현실감 있는 물 셰이더 만들기" /><published>2024-10-07T00:00:00+09:00</published><updated>2024-10-07T00:00:00+09:00</updated><id>http://localhost:4000/ue5/%EC%96%B8%EB%A6%AC%EC%96%BC%20%EB%AC%BC%EC%85%B0%EC%9D%B4%EB%8D%94%20%EB%B0%8F%20%ED%94%84%EB%A0%88%EB%84%AC</id><content type="html" xml:base="http://localhost:4000/ue5/%EC%96%B8%EB%A6%AC%EC%96%BC-%EB%AC%BC%EC%85%B0%EC%9D%B4%EB%8D%94-%EB%B0%8F-%ED%94%84%EB%A0%88%EB%84%AC/"><![CDATA[<h2 id="시작하기">시작하기</h2>
<ul>
  <li>언리얼을 이용해서 프로젝트를 시작했는데 컨셉은 청소기를 통해 물체들을 빨아들이는 건데 그 중에서 물같은 유체도 포함된다.</li>
  <li>팀원들에게 부탁하기에는 다들 바빠보여서 이번 기회에 공부할겸 한번 직접 제작해 볼까 한다.</li>
</ul>

<h2 id="fresnel-프레넬-이란">Fresnel 프레넬 이란?</h2>
<ul>
  <li>프레넬이란 모든 빛은 매질(media)에 따라 반사, 흡수, 굴절을 하게 되는데 이 프레넬 공식을 통해 빛의 움직을 계산한다.</li>
  <li>이를 사용하면 물체의 가장자리 빛이 더 강하게 반사되는 현상을 표현할 수 있다.</li>
</ul>

<hr />

<h3 id="골절률-refactive-index">골절률 (Refactive index)</h3>
<ul>
  <li>빛이 특정 매질을 통과해서 이동할때 얼마나 <strong>느려지는지</strong> 비율을 측정한 것이다.</li>
  <li>빛이 느려지면 이동 방향이 바뀌게 된다.</li>
  <li>빛은 여러 파장이 합쳐서 보이게 되는데 이런 파장에 따라 골절률이 달라진다.</li>
  <li>그렇기에 파장별로 골절률 계산을 해야한다.<br />
<img src="https://github.com/user-attachments/assets/8bfec418-635f-4c14-bb49-23067c2b2d10" alt="image" /></li>
</ul>

<hr />

<h3 id="스넬의-법칙snells-law">스넬의 법칙(Snell’s law)</h3>
<ul>
  <li>
    <p>매질에 따라 빛이 꺾이는 것을 알 수 있는 공식이다.<br />
<img src="https://github.com/user-attachments/assets/abc4be5e-62bf-4f95-b6aa-797076eb0a9f" alt="image|200" /></p>
  </li>
  <li>v 는 속도 (velocity)</li>
  <li>λ는 파장 (wavelength)</li>
  <li>n은 골절률 (IOR)</li>
  <li>
    <p>이런 관계를 설명한 것이 스넬의 법칙이다.<br />
<img src="https://github.com/user-attachments/assets/e9bb11eb-7e95-471a-b074-a88950b44b0c" alt="image" /></p>
  </li>
  <li>그래서 물과 기름이 만나면 아래처럼 파장이 변화한다.<br />
<img src="https://github.com/user-attachments/assets/6ffce623-64b5-4330-a11c-12f371b6b900" alt="image" /></li>
</ul>

<hr />

<h3 id="매질이-반사할수도-있다">매질이 반사할수도 있다.</h3>
<ul>
  <li>굴절률이 다른 매질을 만나게되면 특정 각도에서 굴절이 아니라 완전히 <strong>반사</strong>하는 경우가 있다.</li>
  <li>Critical angle처럼 특정 각도를 넘어가면 전반사가 발생한다.<br />
<img src="https://github.com/user-attachments/assets/0d33de0e-adad-403d-b55d-2e6193c57e6f" alt="image" /></li>
</ul>

<hr />

<h4 id="전반사-각도-구하기-공식">전반사 각도 구하기 공식</h4>
<ul>
  <li>대기의 굴절률이 1이고 아크릴의 굴절률이 1.5면 전반사 각은 41.8이 된다.<br />
<img src="https://github.com/user-attachments/assets/8f69a657-2cc3-4871-b42f-c8a925b3d7dd" alt="image" /><br />
<img src="https://github.com/user-attachments/assets/7a908200-6b73-4062-bc31-ea4148acd85a" alt="image" /></li>
</ul>

<hr />

<h3 id="프레넬-공식-fresnel-equation">프레넬 공식 (Fresnel equation)</h3>
<ul>
  <li>그래픽스에서 반사와 굴절을 계산하기 위해서 반사되는 빛의 양과 얼마나 빛이 굴절되는지 알아야한다.</li>
  <li>그 공식이 프레넬 공식인데 유도식은 너무 어려워서 패스
    <ul>
      <li>프레넬 공식은 스넬의 법칙, <a href="https://en.wikipedia.org/wiki/Law_of_reflection">반사 법칙</a> 등을 이용해서 유도된다</li>
    </ul>
  </li>
  <li>일반적으로 컴퓨터 그래픽스에서는 <strong>Schlick’s approximation</strong>을 사용한다. 근사계산 공식이다.
    <ul>
      <li>모든 각도에서의 굴절률(IOR)을 알 수 없기 때문에 근사계산을 해야한다.<br />
<img src="https://github.com/user-attachments/assets/7ea1103a-3294-4a98-ad21-01cf79fdfe96" alt="image" /></li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="그래프">그래프</h4>
<ul>
  <li>프레넬 공식을 그래프와 시키면 다음과 같다.</li>
  <li>가로축 : 시선과 노멀벡터의 각도</li>
  <li>세로축 : 반사율</li>
  <li>
    <p>수평(90도)일 수록 높은 반사율을 보인다.<br />
<img src="https://github.com/user-attachments/assets/f7b49942-a550-4f9d-aa8f-f392c247e2f5" alt="image" /></p>
  </li>
  <li>일반적으로 물체를 수직에서 바라본(0도) 반사율 값을 넣는 근사 계산식을 사용한다.</li>
  <li>R0값이 그래프에서의 0도의 반사율 값이라 보면된다.</li>
  <li>
    <p>대부분의 엔진에서는 F0이라고 표현한다(Fresnel at Degree 0 도 인듯 하다.)</p>
  </li>
  <li>아래는 대기속에 있다고 가정할때의 식이다.<br />
<img src="https://github.com/user-attachments/assets/99a0abe5-c784-4a51-99a7-a34cb82bcb05" alt="image" /></li>
  <li>물의 경우 1.33의 굴절률을 가진다.
    <ul>
      <li><a href="https://pixelandpoly.com/ior.html">매질의 굴절률 리스트</a></li>
    </ul>
  </li>
  <li><strong>일반적으로 이 F0 를 “Metallic” 핀에다가 넣어 주시면 된다</strong><br />
<img src="https://github.com/user-attachments/assets/899e8591-f5fb-49fe-bad0-a1f1e36ca3db" alt="image" /></li>
</ul>

<hr />

<h2 id="물-쉐이더-만들기">물 쉐이더 만들기</h2>
<h3 id="겉부분만-반사시키기">겉부분만 반사시키기</h3>
<p><img src="https://github.com/user-attachments/assets/d20c6596-7ec1-43e1-ab01-de0af6d447c5" alt="image" /></p>

<hr />

<h3 id="언리얼의-fresnal-노드">언리얼의 Fresnal 노드</h3>
<p><img src="https://github.com/user-attachments/assets/bff4eee8-7a85-4657-baf1-2f04446ce392" alt="image" /></p>
<ul>
  <li>Fresnal 노드는 빛의 굴절률 공식이지만 림라이트나 실루엣을 만들때 많이 사용한다.</li>
  <li>다만 이 노드는 Metalic으로 반영되는 Fresnel은 의미가 명확하지만 <strong>이건 그냥 효과</strong>이기 떄문이다.</li>
  <li>이 노드는 사용하면 비물리적인 결과를 산출할 수 있어서 보통 Metalic을 제거하고 <strong>Emissive</strong>를 사용한다.<br />
<img src="https://github.com/user-attachments/assets/441467ab-d6cd-46f0-87ad-d0da12824248" alt="image" /></li>
</ul>

<h2 id="타일링-오프셋">타일링 오프셋</h2>
<h3 id="타일링-오프셋-tiling-offset">타일링 오프셋 (Tiling Offset)</h3>
<ul>
  <li>언리얼은 타일링 오프셋 노드가 따로 없다</li>
  <li>그래서 직접 텍스처 좌표계나 월드 포지션을 통해 이동시켜야한다.<br />
<img src="https://github.com/user-attachments/assets/a435543f-4b38-4d54-8656-dd57233a9475" alt="image" /></li>
</ul>

<h2 id="시간에-따른-노이즈-생성">시간에 따른 노이즈 생성</h2>
<ul>
  <li>Absolute world Position
    <ul>
      <li>절대적인 월드 포지션<br />
<img src="https://github.com/user-attachments/assets/78ace0ae-c67a-42c6-8abe-b5e618cff88f" alt="image" /></li>
    </ul>
  </li>
</ul>

<h3 id="noise-node">Noise Node</h3>
<ul>
  <li>Function으로 노이즈 종류를 변경할 수 있다.<br />
<img src="https://github.com/user-attachments/assets/0a8dc7c5-cd87-402b-8fd8-d05314044d20" alt="image" /></li>
  <li>Output Value를 통해 흰색 검은색 부분 비율을 조절할 수 있다.<br />
<img src="https://github.com/user-attachments/assets/bf0c6d93-8095-4c8a-a699-b3e8049a2ca1" alt="image" /></li>
</ul>

<h2 id="노이즈-조절하기">노이즈 조절하기</h2>
<ul>
  <li>
    <p>Multiply로 Destortion(파괴) 값을 조절해서 노이즈 값을 연하게 해준다.<br />
<img src="https://github.com/user-attachments/assets/7ad0d9a6-ab4a-4d4f-9ec3-6353cffff0a9" alt="image" /></p>
  </li>
  <li>
    <p>Destortion 값이 1이면 노이즈가 눈에 보여서 줄이는 작업이 필요하다.<br />
<img src="https://github.com/user-attachments/assets/ea45e62a-9ee3-4566-9a7b-d180d8d2cdad" alt="image|300" /></p>
  </li>
</ul>

<h2 id="씬-컬러-적용">씬 컬러 적용</h2>
<ul>
  <li>스크린 포지션에 노이즈를 입히고 그렇게 만들어진 UV에 화면 색깔을 입히면 물처럼 일그러진 효과를 만들 수 있다.<br />
<img src="https://github.com/user-attachments/assets/b35009ce-f3ff-42af-93be-6b1ffe284b07" alt="image" /></li>
</ul>

<p><img src="https://github.com/user-attachments/assets/e3dbb263-152c-4202-bdff-19ba45f7968b" alt="image" /></p>

<h2 id="프레넬-빛-반사효과-추가">프레넬, 빛 반사효과 추가</h2>
<ul>
  <li>프레넬을 추가해서 빛 반사 효과를 준다.<br />
<img src="https://github.com/user-attachments/assets/2ba92d15-5152-47bd-b16d-a76c9f7021f5" alt="image" /></li>
</ul>

<h2 id="일렁임-효과-추가">일렁임 효과 추가</h2>
<ul>
  <li>노이즈 값과 NormalVector를 곱해서 일렁임 효과를 줄 수 있다.<br />
<img src="https://github.com/user-attachments/assets/7996c9ef-666d-4c8f-a041-df1b440b7cb7" alt="image" /></li>
</ul>

<h2 id="투과시키는-빛-일렁임">투과시키는 빛 일렁임</h2>
<ul>
  <li>투과되는 뒤쪽 배경을 일렁이고 싶다면 Refraction을 수정한다.<br />
<img src="https://github.com/user-attachments/assets/f33d512f-f98f-4d38-8247-147f1d715c76" alt="image" /></li>
</ul>

<h2 id="결과물">결과물</h2>
<p><img src="https://github.com/user-attachments/assets/bb2f1eec-6261-40c6-b6b9-639465e37762" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/0134427d-47d6-4b9b-baf9-34ac60a8e218" alt="image" /></p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://lifeisforu.tistory.com/384">https://lifeisforu.tistory.com/384</a>
<a href="https://www.youtube.com/watch?v=3CcWus6d_B8&amp;t=611s">https://www.youtube.com/watch?v=3CcWus6d_B8&amp;t=611s</a>
<a href="https://www.youtube.com/watch?v=3CcWus6d_B8&amp;t=611s">https://www.youtube.com/watch?v=3CcWus6d_B8&amp;t=611s</a>
<a href="https://www.youtube.com/watch?v=z5VzzPkqtnA">https://www.youtube.com/watch?v=z5VzzPkqtnA</a>
<a href="https://www.youtube.com/watch?v=OFmWEIb_Z70">https://www.youtube.com/watch?v=OFmWEIb_Z70</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="UnrealEngine5" /><category term="Fresnel" /><category term="물 셰이더" /><category term="물리 기반 렌더링" /><category term="쉐이더 그래프" /><category term="반사 효과" /><category term="UnrealEngine" /><category term="Shader" /><category term="물리 엔진" /><summary type="html"><![CDATA[시작하기 언리얼을 이용해서 프로젝트를 시작했는데 컨셉은 청소기를 통해 물체들을 빨아들이는 건데 그 중에서 물같은 유체도 포함된다. 팀원들에게 부탁하기에는 다들 바빠보여서 이번 기회에 공부할겸 한번 직접 제작해 볼까 한다.]]></summary></entry><entry><title type="html">[Obsidian] Vercel을 활용한 Obsidian Digital Garden 블로그 만들기</title><link href="http://localhost:4000/obsidian/Vercel%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-Obsidian-Digital-Garden-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/" rel="alternate" type="text/html" title="[Obsidian] Vercel을 활용한 Obsidian Digital Garden 블로그 만들기" /><published>2024-10-07T00:00:00+09:00</published><updated>2024-10-07T00:00:00+09:00</updated><id>http://localhost:4000/obsidian/Vercel%EC%9D%84%20%ED%99%9C%EC%9A%A9%ED%95%9C%20Obsidian%20Digital%20Garden%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/obsidian/Vercel%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-Obsidian-Digital-Garden-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"><![CDATA[<h1 id="옵시디언으로-블로그를-만드는-이유">옵시디언으로 블로그를 만드는 이유</h1>
<p>지금까지 나는 지식을 정리하고 정리한 내용을 공유하기 위해 여러 종류의 블로그 사이트를 사용해 봤다. 맨처음에는 <strong>네이버</strong> 블로그였는데 한국인의 입장에선 확실히 네이버가 접근성이 좋긴하지만 한국인을 제외한 외국인들은 구글 검색에 뜨기가 쉽지않고 디자인이 마음에 들지않아 금방 포기했다.</p>

<p>그 다음은 <strong>티스토리</strong> 블로그였다. 개발관련 자료를 검색하면 많은 자료가 티스토리 혹은 Velog에 올라와 있었다. 나는 직접 커스텀하는 것을 좋아해서 Velog보다는 티스토리가 더 좋다 생각해서 티스토리에서 글을 작성했었다.</p>

<p>물론 편하고 기본적으로 깔끔해서 좋긴 하지만 글을 검색하거나 사이트를 설정하는데 마음에 들지 않아 자연스럽게 손대지 않게 되었다.</p>

<p>좀 더 자유도 높은 블로그가 있을까 찾아봤는데 <strong>GitBlog</strong>가 눈에 들어왔다.<br />
GItBlog는 처음부터 끝까지 기능을 다 커스텀가능하고 테마도 풍부해서 마음에 드는게 많았다. 그 중 Jekyll 테마가 인지도 있어보여서 사용해봤다. 처음에는 css도 직접짜고 여러가지 기능을 넣을 수 있어서 재밌었지만 생산성 부분에서 문제가 커져갔다.</p>

<p>기본적으로 GitBlog는 자유도가 높은 만큼 학습량이 많아 초반에 시간이 오래걸리고 무엇보다 띄어쓰기가 너무 큰 문제였다. Jekyll테마에서만 그런지는 몰라도 줄바꿈이 제대로 적용되지 않아 br 태그를 중간중간 써줘야하고 생각한대로 글이 이쁘게 나오지도 않아서 css를 수정하고 글자도 다시 수정하는 등 글 하나 작성하는데 시간이 오래걸린다. 그리고 나는 옵시디언을 통해 먼저 글을 작성하고 그 글을 정리해서 포스팅하는데 이게 옵시디언과 달리 HTML을 중간중간 써줘야 하다보니 이것도 시간이 많이 걸린다.</p>

<p>그리고 가장 중요한게 조회수인데 사이트맵이 제대로 적용이 안되는지 사람이 몇달간 제대로 들어오지 않곤했다. 그래서 금방 흥미를 잃게 되었다.</p>

<p>결국 포스팅 하는게 귀찮아져서 손을 안대게 됐는데 어떻게 해야 내가 블로그를 열심히 쓰게 될까 생각해 보았다.<br />
지금까지 블로그를 사용했던 경험을 토대로 내가 블로그에서 가장 중요하게 생각하는 걸 3가지를 정해봤다.</p>
<ol>
  <li>포스트 업로드가 쉬워야한다.</li>
  <li>옵시디언에서 작성한 글에서 수정을 거의 안해야한다.</li>
  <li>자유도가 있어야한다.</li>
</ol>

<p>위 조건들을 토대로 찾아본 결과 <strong>Digital Garden</strong> 플러그인을 이용해 옵시디언 노트를 통쨰로 포스팅하는 방식이 가장 적절해 보였다. 아직 시작 단계이지만 얼추 봤을때는 아래의 장점이 있었다.</p>
<ol>
  <li>버튼 몇번으로 업로드, 수정, 삭제가능하다.</li>
  <li>옵시디언 노트 내용이랑 똑같다.</li>
  <li>꾸미기 쉽다.</li>
</ol>

<p>내가 생각한 블로그의 조건이랑 딱 맞아 떨어져보여 한번 시작해보려고 한다.</p>

<h1 id="digital-garden으로-블로그-만들기">Digital Garden으로 블로그 만들기</h1>
<h3 id="플러그인-설치">플러그인 설치</h3>
<ul>
  <li>Community Plugin에 가서 <code class="language-plaintext highlighter-rouge">Digital Garden</code>을 검색해서 설치한다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/3949101f-9e1d-4715-aab9-d6f718819783" alt="image" /></p>

<h3 id="vercel-계정-생성">Vercel 계정 생성</h3>
<ul>
  <li> <a href="https://github.com/signup">Vercel</a>로 가서 GitHub 계정과 연동해준다.</li>
</ul>

<div class="callout-info-expanded">
<div class="callout-header">정보</div>
<p>
클라우드 플랫폼으로, 웹사이트 및 애플리케이션을 배포, 관리, 그리고 성능을 최적화하는 데 도움을 준다. 
주로 Next.js와 같은 프레임워크와 밀접하게 연동된다.
</p>
</div>

<hr />

<h3 id="리포지토리-생성">리포지토리 생성</h3>
<ul>
  <li>리포지토리 생성 후 <a href="https://github.com/oleeskild/digitalgarden">링크</a>로가서 Deploy 버튼 클릭한다</li>
  <li>이렇게 하면 Vercel이 열리고 GitHub 계정에 저장소의 사본이 생성된다. 사본 저장소의 이름을 작성하고 생성하면 Vercel의 단계에 따라 사이트를 인터넷에 게시된다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/8b371813-b355-4c2c-abe4-247c78591a32" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/fa8421f8-0d56-40f9-b1e0-410121ab0f18" alt="image" /></p>

<hr />

<h3 id="github-액세스토큰-생성">GitHub 액세스토큰 생성</h3>
<ul>
  <li>다음으로 GitHub 계정에 대한 액세스 토큰을 만들어야 한다.</li>
  <li>토큰은 저장소를 접근하기 위한 비밀번호 역할을 하여 토큰을 만들어야 작성한 글을 업로드할 수 있다.</li>
  <li>토큰 생성방법은  <a href="https://dg-docs.ole.dev/advanced/fine-grained-access-token/">링크</a>에서 확인할 수 있다. 설정값을 똑같이 넣어준다.</li>
  <li>토큰은 <a href="https://github.com/settings/tokens/new?scopes=repo">여기</a>서 생성할 수 있다. </li>
  <li><strong>토큰 값은 한번 생성됐을때 한번만 알려주니까</strong> 꼭 어딘가에 저장해놓자</li>
</ul>

<hr />

<h3 id="digital-garden-플러그인-설정">Digital Garden 플러그인 설정</h3>
<p>Digital Garden 플러그인에 깃허브 저장소 관련 정보를 넣어줘야한다.</p>
<ol>
  <li>Github repo name: 생성한 레포지토리 이름</li>
  <li>Github username: 깃허브 아이디</li>
  <li>Github token: 방금 생성한 토큰<br />
<img src="https://github.com/user-attachments/assets/47e4cadc-92f5-4432-813a-73bc23b0c3f7" alt="image" /></li>
</ol>

<h2 id="노트-연결하기">노트 연결하기</h2>
<ul>
  <li>프로퍼티를 통해 공개할 노트를 설정할 수 있다.</li>
  <li><strong>dg-publish</strong> : 노트를 다른 사람들에게 공개한다.</li>
  <li><strong>dg-home</strong> : 해당 노트를 메인 페이지로 설정한다.<br />
<img src="https://github.com/user-attachments/assets/ceb39f0c-4d75-41d1-bdf8-6a314375053d" alt="image" /></li>
</ul>

<h2 id="노트-푸시하기">노트 푸시하기</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Digital Garden: Publish Single Note</code>를 눌러서 노트를 공개할 수 있다.</li>
  <li>그리고 사이트 주소를<a href="https://vercel.com/dashboard">Vercel</a>에서 찾고 몇분 뒤면 푸시한 노트가 올라와 있을 것이다.</li>
</ul>

<h1 id="마무리">마무리</h1>
<ul>
  <li>옵시디언에서 글을 쓰고 그것을 그대로 웹사이트에 올리는 것은 분명 편하긴하다.</li>
  <li>하지만 사이드 카테고리가 너무 옵시디언이랑 똑같아 이 부분은 맘에 들지 않는다.</li>
  <li>그래서 대안으로 webpage export 플러그인을 알아봤는데 이건 분명 편해보이지만 깃허브와 연동하는 기능이 없어서 Digital Garden을 계속 쓸것같다.</li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://deepfield.blog/">https://deepfield.blog/kr/%EC%A7%80%EC%8B%9D%EB%82%98%EB%88%94/%EC%98%B5%EC%8B%9C%EB%94%94%EC%96%B8%EC%9C%BC%EB%A1%9C%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</a>
<a href="https://dg-docs.ole.dev/getting-started/01-getting-started/">https://dg-docs.ole.dev/getting-started/01-getting-started/</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="obsidian" /><category term="Obsidian" /><category term="옵시디언" /><category term="Vercel" /><category term="DigitalGarden" /><category term="지식정원" /><category term="블로그" /><category term="blog" /><category term="플러그인" /><summary type="html"><![CDATA[옵시디언으로 블로그를 만드는 이유 지금까지 나는 지식을 정리하고 정리한 내용을 공유하기 위해 여러 종류의 블로그 사이트를 사용해 봤다. 맨처음에는 네이버 블로그였는데 한국인의 입장에선 확실히 네이버가 접근성이 좋긴하지만 한국인을 제외한 외국인들은 구글 검색에 뜨기가 쉽지않고 디자인이 마음에 들지않아 금방 포기했다. 그 다음은 티스토리 블로그였다. 개발관련 자료를 검색하면 많은 자료가 티스토리 혹은 Velog에 올라와 있었다. 나는 직접 커스텀하는 것을 좋아해서 Velog보다는 티스토리가 더 좋다 생각해서 티스토리에서 글을 작성했었다.]]></summary></entry><entry><title type="html">[CS] 페이징과 스와핑을 활용한 가상 메모리 관리 기법 이해하기</title><link href="http://localhost:4000/computerscience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/" rel="alternate" type="text/html" title="[CS] 페이징과 스와핑을 활용한 가상 메모리 관리 기법 이해하기" /><published>2024-08-27T00:00:00+09:00</published><updated>2024-08-27T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0%20%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/computerscience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/"><![CDATA[<p>컴퓨터 시스템에서 프로세스는 작업을 처리하기 위해 반드시 데이터를 메모리에 저장해야 한다. 하지만 물리적인 메모리 용량은 제한적이기 때문에, 모든 프로세스가 동시에 메모리에 상주할 수는 없다.</p>

<p>이를 해결하고자 운영체제는 다양한 메모리 관리 기법을 통해 메모리 자원을 효율적으로 배분하고 활용한다. 이러한 기법들은 프로세스의 메모리 사용량을 최적화하고, 실행 속도를 보장하며, 시스템의 안정성을 유지하는 데 중요한 역할을 한다.</p>

<p>오늘은 그중에서도 연속적 메모리 할당, 스와핑, 페이징 등 현대 운영체제에서 흔히 사용되는 메모리 관리 기법들을 자세히 살펴보며, 각각의 장단점과 적용 사례에 대해 알아보자.</p>

<p>이 과정을 통해 컴퓨터 시스템이 어떻게 메모리 자원을 관리하고, 이를 통해 성능을 극대화하는지 이해할 수 있을 것이다.</p>

<h2 id="연속적-메모리할당">연속적 메모리할당</h2>
<p><img src="https://github.com/user-attachments/assets/ef40bf7b-1bf2-469d-827d-c2d2e858536f" alt="image" /></p>
<ul>
  <li>프로세스 영역에 연속적으로 프로세스를 할당해 놓은 것을 의미한다.</li>
  <li>메모리를 차곡차곡 쌓아놓은 형태</li>
  <li>이러한 방식은 비효율적이며 후에 <strong>페이징</strong>이라는 방식으로 프로세스를 관리하는 것이 좋다.</li>
</ul>

<h2 id="스와핑">스와핑</h2>
<p><img src="https://github.com/user-attachments/assets/0a438116-b3bf-4a71-a986-60fdcde2f2d5" alt="image" /></p>
<ul>
  <li>현재 사용하지 않는(휴면상태)인 프로세스를 <strong>보조기억장치</strong>에넘겨서 효율적으로 메모리를 관리하는 기법
    <ul>
      <li><strong>스왑아웃</strong> : 무직백수 프로세스를 부조기억장치로 내쫓는 작업</li>
      <li><strong>스왑 인</strong> : 할일이 생긴 프로세스를 다시 메모리에 들여보내는 작업</li>
      <li><strong>스왑 영역</strong> : 무직백수 프로세스들이 모여지낼 <em>보조기억 장치의 일부 공간</em></li>
    </ul>
  </li>
</ul>

<h3 id="스와핑의-장점">스와핑의 장점</h3>
<p><img src="https://github.com/user-attachments/assets/b7043fb1-1309-4c59-a613-0cfea6ef443a" alt="image" /></p>
<ul>
  <li>내가 로아, 마크, 림월드 같은 큰 메모리를 필요로 하는 프로세스를 동시에 띄어 놓아야 하는 상황이있다.</li>
  <li>하지만 프로그램들의 메모리 용량은 물리 메모리의 허용된 용량보다 큰데 그럴때 빛을 발한다.</li>
  <li>실제로 사용하지 않는 프로세스는 보조기억장치에 넘기고 해당 자리에 다른 프로세스를 넣어서 모든 프로세스가 돌갈 수 있게 해준다.</li>
</ul>

<h3 id="명령어">명령어</h3>
<p><img src="https://github.com/user-attachments/assets/89fbc725-6d8e-4c50-8cc8-20800808f45c" alt="image" /></p>

<h2 id="연속-메모리-할당-방법">연속 메모리 할당 방법</h2>
<h3 id="최초-적합first-fit">최초 적합(first-fit)</h3>
<p><img src="https://github.com/user-attachments/assets/4bc86db6-3665-45ac-ac7e-b55213863e63" alt="Pasted image 20240731230854" /></p>

<ul>
  <li>프로세스를 적재할 공간을 발견하자마자 해당 공간에 적재하는 방식</li>
  <li>Greedy Algorithm같은 방식이다.</li>
  <li>빠르게 할당 가능하다.
    <h3 id="최적-적합best-fit">최적 적합(best-fit)</h3>
    <p><img src="https://github.com/user-attachments/assets/ccc12a6c-c5e0-42da-b37f-bb4cc29bef1d" alt="image" /></p>
  </li>
  <li>빈공간들 중 프로세스가 들어설 수 있는 가장 작은 공간에 할당하는 방</li>
</ul>

<h3 id="최악-적합worst-fit">최악 적합(worst-fit)</h3>
<p><img src="https://github.com/user-attachments/assets/0368ebfb-959d-454d-a24a-13b210ddac77" alt="image" /></p>
<ul>
  <li>가장 큰 공간에 할당하는 방법</li>
  <li><strong>외부 단편화</strong>문제 때문에 효율 낭비가 심한 방법이다.</li>
</ul>

<h2 id="외부-단편화">외부 단편화</h2>
<p><img src="https://github.com/user-attachments/assets/aad9f5ca-8b71-4f2d-b449-e6795dde2b0d" alt="image" /></p>
<ul>
  <li>외부 단편화란 메모리 중간중간 작은 빈 공간이 생겨나는 것을 뜻한다.</li>
  <li>이 현상의 단점은 CS MemoryStream과 같이 큰 용량의 프로세스는 여러개의 작은 공간에 할당 할 수 없는 문제가 생긴다.</li>
</ul>

<h3 id="해결법1--컴팩션">해결법1 : 컴팩션</h3>
<ul>
  <li>Garbage Collector의 메모리 컴팩션과 같은 원리다.</li>
  <li>띄엄띄엄 놓여진 프로세스 메모리들을 압축해서 하나로 연결한다.</li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>오버헤드가 심하다.</li>
  <li>컴팩션중 프로세스 이용이 불가하다.</li>
</ul>

<h3 id="해결법2-페이징">해결법2: 페이징</h3>
<ul>
  <li>가상 메모리 기법으로 현대 운영체제 대부분이 사용하는 메모리 관리 기법이다.</li>
</ul>

<h1 id="14-2-페이징을-이용한-가상-메모리-관리">14-2 페이징을 이용한 가상 메모리 관리</h1>
<h2 id="페이징paging이란">페이징(paging)이란</h2>
<p><img src="https://github.com/user-attachments/assets/ca7ce90a-0410-4a70-bbb5-3db0c87f9226" alt="image" /></p>
<ul>
  <li>페이징이란 하나의 프로세스를 잘게 나눠서 <strong>외부 단편화</strong>된 메모리 공간에 프로세스를 할당함으로써 비연속적인 메모리 공간을 효율적으로 사용할 수 있게 해주는 메모리 관리 기법이다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/144c01fb-45a4-4f8d-bc29-944baf5fde83" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/251c4b27-6f4b-4c96-b97b-a90f61b39278" alt="image" /></p>

<ul>
  <li>좀 더 문서체로 말하자면 다음과 같다.
    <ul>
      <li>프로세스의 논리 주소 공간을 <strong>페이지(page)</strong> 단위로 자른다.
        <ul>
          <li>페이지 단위는 일정하나 일부 운영 체제에서는 Huge page라고 큰 용량의 페이지를 할당하는 경우도 있다.</li>
        </ul>
      </li>
      <li>메모리의 물리 주소 공간을 프레임(frame)라는 단위로 페이지와 같은 크기로 자른다.</li>
      <li>그리고 페이지를 프레임에 끼워 맞추는 방법이다.</li>
    </ul>
  </li>
</ul>

<h3 id="페이지-스와핑">페이지 스와핑</h3>
<p><img src="https://github.com/user-attachments/assets/5711310e-e824-4950-925b-1f16917d9208" alt="image" /></p>
<ul>
  <li>페이지를 스와핑 한다고? 그럼 프로그램이 제대로 돌아가지 않는거 아닌가?
    <ul>
      <li>그렇지 않다. 사실 프로세스가 실행되는 데는 모든 페이지가 필요한 것이아니다.</li>
      <li>일부 페이지를 보조기억 장치로 <strong>아웃</strong>시킴으로 써 논리 메모리 용량이 물리 메모리 용량 보다 더 크게 프로세스를 할당 할 수 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="페이지-테이블">페이지 테이블</h2>
<ul>
  <li>페이지 방식의 메모리 관리 기법은 불연속적으로 메모리가 존재한다.</li>
  <li>그럼 CPU에서는 해당 메모리 주소들을 어떻게 관리할까?</li>
  <li>분명 주소가 있어야 하는데 어디에 주소를 넣어놓는거지??</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/be314d5e-68d8-4366-b33c-5c54cbc4da3a" alt="image" /></p>
<ul>
  <li>그것이 바로 페이지 테이블(Page table)
    <ul>
      <li>페이지와 프레임 주소를 연결 시켜준다.</li>
    </ul>
  </li>
</ul>

<h3 id="내부-단편화">내부 단편화</h3>
<p><img src="https://github.com/user-attachments/assets/57449fba-db83-41e3-ad2f-ae6651e29ad7" alt="image" /></p>

<ul>
  <li>그런데 이런 페이지도 단점이 있다!</li>
  <li>바로 프로세스를 페이지로 자를 경우 마지막 페이지 부분이 프로세스 크기와 딱 맞아 떨어지지 않아서 빈 공간이 생기는 현상이다.</li>
  <li>외부 단편화가 물리 메모리주소에 단편화 현상이 발생한 거라면 내부 단편화는 프로세스 자체에 단편화 현상이 발생한 것이다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/e67405c2-af02-4f2f-8e38-96a29cca8f88" alt="image" /></p>
<ul>
  <li>페이지 크기 명령</li>
</ul>

<h2 id="process-table-base-registerptbr">Process Table Base Register(PTBR)</h2>
<p><img src="https://github.com/user-attachments/assets/01c3a0fd-d783-4566-a6d7-5d91e3629aae" alt="image" /></p>

<ul>
  <li>페이지 테이블의 위치를 가리키는 주소
    <ul>
      <li>이것은 메모리가 아니라 [[CPU]]에 저장되어있다.</li>
    </ul>
  </li>
</ul>

<h3 id="뭔가-비효율-적인데">뭔가…? 비효율 적인데</h3>
<ul>
  <li>원하는 페이지에 접근하려면 페이지 테이블 &gt; 페이지 이렇게 두번 접근해야 한다.</li>
  <li>이는 굉장히 비효율적이다.</li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
혼자 공부하는 컴퓨터구조+운영체제
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="computerscience" /><category term="가상 메모리" /><category term="Virtual Memory" /><category term="페이징" /><category term="Paging" /><category term="스와핑" /><category term="Swapping" /><category term="메모리 관리 기법" /><category term="Memory Management" /><category term="컴퓨터 구조" /><category term="Computer Architecture" /><category term="운영체제" /><category term="Operating System" /><category term="메모리 단편화" /><category term="Memory Fragmentation" /><category term="프로세스 메모리 할당" /><category term="Process Memory Allocation" /><summary type="html"><![CDATA[컴퓨터 시스템에서 프로세스는 작업을 처리하기 위해 반드시 데이터를 메모리에 저장해야 한다. 하지만 물리적인 메모리 용량은 제한적이기 때문에, 모든 프로세스가 동시에 메모리에 상주할 수는 없다.]]></summary></entry><entry><title type="html">[UE5] 언리얼엔진 캐릭터 애니메이션 모션매칭 사용법</title><link href="http://localhost:4000/ue5/UE5-%EB%AA%A8%EC%85%98%EB%A7%A4%EC%B9%AD%EC%82%AC%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="[UE5] 언리얼엔진 캐릭터 애니메이션 모션매칭 사용법" /><published>2024-08-26T00:00:00+09:00</published><updated>2024-08-26T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20%EB%AA%A8%EC%85%98%EB%A7%A4%EC%B9%AD%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-%EB%AA%A8%EC%85%98%EB%A7%A4%EC%B9%AD%EC%82%AC%EC%9A%A9%EB%B2%95/"><![CDATA[<p>언리얼엔진이 5.4버전이 나오면서 모션매칭 기능이 새로 발표되었다.<br />
모션 매칭은 캐릭터 애니메이션을 위한 차세대 프레임워크다. 이 기술은 언리얼 엔진 5.4 버전에서 새롭게 도입되었으며, 캐릭터의 움직임을 더욱 자연스럽고 역동적으로 만드는 데 중점을 준다.</p>

<p><br /></p>
<p>
모션매칭을 이용한 애니메이션 제작은 기존 방식과 큰 차이가 있다. 모션 매칭의 주요 특징으로는 다음과 같다.<br />
<font color="dodgerred">1. 데이터 기반 접근</font>: 모션 매칭은 대규모의 캡처된 애니메이션 데이터베이스를 활용합니다.<br />
<font color="dodgerred">2. 실시간 검색</font>: 게임 내 캐릭터의 현재 모션 정보를 키로 사용하여 데이터베이스에서 가장 적합한 애니메이션을 실시간으로 검색합니다.<br />
<font color="dodgerred">3. 자연스러운 전환</font>: 복잡한 로직 없이도 다양한 애니메이션 클립 간의 자연스러운 전환이 가능합니다.<br />
<font color="dodgerred">4. 확장성</font>: 애니메이션 기능을 위한 확장 가능한 프레임워크를 제공합니다.<br />
</p>

<p><br /><br />
기존에는 특정 조건에 맞는 애니메이션을 하나하나 직접 설정해줘야 했지만 모션 매칭은 데이터 기반으로 현재 상태에서 가장 적합한 애니메이션을 자연스럽게 자동으로 설정해준다.</p>

<p><br /></p>
<h1 id="모션매칭-사전준비">모션매칭 사전준비</h1>
<h2 id="플러그인-설치">플러그인 설치</h2>
<ul>
  <li>아래 두 플러그인 설치하고 다시 시작한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/dbc4cc87-7a25-4b1d-ba26-266c97506563" alt="image" /><br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/7e725cda-a1ba-4064-a128-da6e780383ce" alt="image" /></li>
</ul>

<h2 id="애니메이션-시퀀스들-준비하기">애니메이션 시퀀스들 준비하기</h2>
<h3 id="모션-매칭-스키마-생성">모션 매칭 스키마 생성</h3>
<ul>
  <li>접두사는 PSS_</li>
  <li>각도 회전 값등 변수 설정하는 애셋이다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/331aea83-d937-4559-845f-ecc26b726c6c" alt="image" /></li>
</ul>

<hr />

<h3 id="database-생성">Database 생성</h3>
<ul>
  <li>
    <p>모션 매칭에 사용될 애니메이션들을 담는 데이터를 생성한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/6c101550-6a54-4a12-a0b9-da28e1352eeb" alt="image" /></p>
  </li>
  <li>적용할 스키마를 선택한다.</li>
  <li>접두사는 PSD_<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/04961922-19f6-47d4-88e8-5692eacf7047" alt="image" /></li>
</ul>

<hr />

<h4 id="psddatabase-화면">PSD(Database) 화면</h4>
<ul>
  <li>이제 여기에 사용할 애니메이션을 드래그 하면된다.</li>
  <li>그전에 <strong>루트모션</strong>을 사용 중인지 확인 해야한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/896d1c75-1c1b-4a07-b845-d8cf73b2a123" alt="image" /></li>
</ul>

<hr />

<h4 id="애니메이션-한번에-수정하기">애니메이션 한번에 수정하기</h4>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/5e49972c-c46e-436e-90dd-29f8af77b1ee" alt="image" /></p>

<ul>
  <li>컨트롤 a를 눌러 모두 선택후 EnableRootMotion을 활성화 한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/e10b9b6c-489e-4f8f-af60-5610d371c867" alt="image" /></li>
</ul>

<hr />

<h4 id="locomotion-psd-생성하기">Locomotion PSD 생성하기</h4>
<ul>
  <li>DB에서 애니메이션을 넣는다.</li>
  <li>각각 상하좌우 방향으로 시작, 진행 중, 멈출 때 해당하는 Walk 모션을 넣어준다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/36724702-59f2-4684-a817-0ae49418333f" alt="image" /></li>
</ul>

<p><br /></p>

<h1 id="모션매칭-활용하기">모션매칭 활용하기</h1>
<h2 id="abp-설정하기">ABP 설정하기</h2>
<ul>
  <li>Motion Matching 노드를 불러와 모션매칭 DataBase를 가져온다.</li>
  <li>그리고 현재 애니메이션에서 추적하기 위해 Trajectory(궤적)을 불러와야 한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/6c49c019-d49b-4f55-af2a-4ab987c59842" alt="image" /></li>
</ul>

<hr />

<h3 id="trajectory-컴포넌트-설치하기">Trajectory 컴포넌트 설치하기</h3>
<ul>
  <li>ABP를 사용할 BP에서 <code class="language-plaintext highlighter-rouge">Character Trajectory</code> 컴포넌트를 부착한다.</li>
</ul>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/31db32d6-577e-49b2-9075-bc079c638a43" alt="image" /></p>

<hr />

<h3 id="trajectory-정보-가져오기">Trajectory 정보 가져오기</h3>
<ul>
  <li>ABP와 BP의 Trajectory를 연결해야한다.</li>
  <li>그렇기 위해선 ABP의 EventGraph에서 자신을 사용하는 BP를 가져와야 한다.</li>
  <li>
    <p>자신을 사용중인 Actor를 가져와 그 액터 BP를 변수로 설정한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/128cb3a3-5f92-4268-a926-57aeb39bb0dd" alt="image" /></p>
  </li>
  <li>
    <p>변수화한 Owner Actor를 불러와 Trajectory를 매 프레임마다 변수화 시킨다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/c697f497-df56-46d3-bed8-1bb8e34fdb2f" alt="image" /></p>
  </li>
  <li>그리고 다시 AnimGraph로 돌아가서 Trajectory를 설정해준다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/a5b14922-a3a4-4367-b352-58a285a1615d" alt="image" /></li>
</ul>

<h2 id="디버깅-궤적-확인">디버깅 궤적 확인</h2>
<ul>
  <li>콘솔창에 <code class="language-plaintext highlighter-rouge">a.CharacterTrajectory.Debug 1</code> 을 하면 궤적이 보인다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/592c0d2d-152c-4334-864a-909b3613afec" alt="image" /></li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://www.youtube.com/watch?v=4ag7fSlEeKA">https://www.youtube.com/watch?v=4ag7fSlEeKA</a>
<a href="https://www.youtube.com/watch?v=S4aBd64t-hY&amp;ab_channel=GorkaGames">https://www.youtube.com/watch?v=S4aBd64t-hY&amp;ab_channel=GorkaGames</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="UnrealEngine" /><category term="Animation" /><category term="MotionMatching" /><summary type="html"><![CDATA[언리얼엔진이 5.4버전이 나오면서 모션매칭 기능이 새로 발표되었다. 모션 매칭은 캐릭터 애니메이션을 위한 차세대 프레임워크다. 이 기술은 언리얼 엔진 5.4 버전에서 새롭게 도입되었으며, 캐릭터의 움직임을 더욱 자연스럽고 역동적으로 만드는 데 중점을 준다.]]></summary></entry></feed>