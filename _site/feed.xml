<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-19T20:47:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mohitto55 Note</title><subtitle>모히또의 노트</subtitle><author><name>Mohitto55</name></author><entry><title type="html">[Algorithm] Selection Sort 선택정렬 알고리즘</title><link href="http://localhost:4000/algorithm/Selection-Sort-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC/" rel="alternate" type="text/html" title="[Algorithm] Selection Sort 선택정렬 알고리즘" /><published>2024-03-19T00:00:00+09:00</published><updated>2024-03-19T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/Selection%20Sort%20%EC%84%A0%ED%83%9D%20%EC%A0%95%EB%A0%AC</id><content type="html" xml:base="http://localhost:4000/algorithm/Selection-Sort-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC/"><![CDATA[<h2 id="selection-sort">Selection Sort</h2>
<p>선택정렬 알고리즘은 제자리 정렬 알고리즘 중 하나로 입력 데이터 외 추가 데이터가 필요하지 않은 알고리즘이다.</p>

<h2 id="원리">원리</h2>
<ul>
  <li>정렬하고자 하는 데이터 중 가장 큰 데이터의 맨 끝 데이터랑 교환
    <ol>
      <li>0번 째 Index부터 N-i까지 차례로 순회한다.</li>
      <li>순회를 하던 중 값이 Index &lt; Index +1 일 경우 가장 큰 값을 Index + 1이라 한다.</li>
      <li>순회를 마쳤으면 마지막 값이랑 <font color="dodgerred">가장 큰 값</font>이랑 교환한다.</li>
      <li>i를 1 올리고 다시 0부터 순회한다.</li>
    </ol>
  </li>
</ul>

<h2 id="시간-복잡도">시간 복잡도</h2>

\[(n-1) + (n-2)... = \frac{n(n-1)}{2} = O(N^2)\]

<ul>
  <li>비교 횟수</li>
  <li>i가 n-2 일 때 비교횟수 : <font color="dodgerred">n-2</font></li>
  <li>i가 n-1 일 때 비교횟수 : <font color="dodgerred">n-1</font></li>
  <li>
    <p>i가 1 일 때 비교횟수 : <font color="dodgerred">1</font></p>
  </li>
  <li>교환 횟수
    <ul>
      <li>외부 루프의 실행 횟수와 동일</li>
      <li>Swap시 3번의 데이터 이동 발생</li>
    </ul>
  </li>
</ul>

<h2 id="코드">코드</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">void</span> <span class="nf">SelectionSort</span><span class="p">(){</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">last</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">last</span><span class="o">++</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">largestIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cur</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="n">last</span><span class="p">;</span> <span class="n">cur</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">largestIndex</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">cur</span><span class="p">]){</span>
				<span class="n">largestIndex</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">largestIndex</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">cur</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html">https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html</a>
<a href="https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC">https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="algorithm" /><category term="Algorighm" /><category term="Sort" /><category term="정렬" /><category term="Selection Sort" /><category term="선택정렬" /><summary type="html"><![CDATA[Selection Sort 선택정렬 알고리즘은 제자리 정렬 알고리즘 중 하나로 입력 데이터 외 추가 데이터가 필요하지 않은 알고리즘이다.]]></summary></entry><entry><title type="html">[Network] 네트워크공부</title><link href="http://localhost:4000/network/TCPIP%EA%B3%B5%EB%B6%80/" rel="alternate" type="text/html" title="[Network] 네트워크공부" /><published>2024-03-16T00:00:00+09:00</published><updated>2024-03-16T00:00:00+09:00</updated><id>http://localhost:4000/network/TCPIP%EA%B3%B5%EB%B6%80</id><content type="html" xml:base="http://localhost:4000/network/TCPIP%EA%B3%B5%EB%B6%80/"><![CDATA[<h2 id="통신을-위한-규칙-프로토콜">통신을 위한 규칙, 프로토콜</h2>
<ul>
  <li>Packet을 처리하려면 규칙이 필요하다</li>
  <li>프로토콜 덕에 회사가 달라도 패킷 처리가 가능하다</li>
  <li>Https도 프로토콜이다.</li>
</ul>

<h3 id="프로토콜에-결정되어-있는-것">프로토콜에 결정되어 있는 것</h3>
<ul>
  <li>LAN케이블 소재나 핀도 프로토콜이 있다.</li>
  <li>Packet와 Header에도 어느 영역이 어떤 정보인지 프로토콜이 있다.</li>
</ul>

<h3 id="프로토콜은-계층으로-정리한다">프로토콜은 계층으로 정리한다.</h3>
<ul>
  <li>데이터 송신할 땐 위 계층에서 아래 계층으로</li>
  <li>데이터 수신할 땐 아래 계층에서 위 계층으로</li>
  <li>송수신 할 때 같은 계층에서 일처리한다.
    <h3 id="두가지-계층구조-모델">두가지 계층구조 모델</h3>
    <h4 id="tcpip-45계층">TCP/IP 4,5계층</h4>
    <p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/ba6486b7-2af9-40f1-bc00-d72910333b8d" alt="image" /></p>
  </li>
  <li>문서마다 4계층 혹은 5계층으로 나뉜다
    <ul>
      <li>5계층으로 생각하는 것이 좋을 듯하다</li>
    </ul>
  </li>
  <li>실질적으로 OSI보다 이 구조를 많이 사용한다.</li>
</ul>

<h4 id="osi-7계층">OSI 7계층</h4>
<p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/a4426d89-74fb-4b5c-a4f4-c19fb5f006ec" alt="image" />
국제표준기구에서 만든 컴퓨터 프로토콜 계층으로 각 계층은 다른 계층에 의존할 필요 없어 캡슐화와 은닉이 용이하다.</p>

<p>OSI를 다 지켜서 하는 프로토콜은 없다고 한다. 이유는 너무 복잡하기 때문이다.</p>

<h3 id="ip-주소ip-address">IP 주소(IP Address)</h3>
<p>인터넷에 연결된 컴퓨터들의 주소로 Ipv4 버전을 사용한다. 32bit로 구성되며 192.168.212.153 과 같이 표기한다. 네트워크 계층에서 쓰이는 값이다.</p>

<h3 id="mac-주소">MAC 주소</h3>
<p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/8e1257f2-702b-44d4-be35-3455a39dda5b" alt="image" />
MAC주소는 6바이트로 구성되며, ‘00-0c-29-43-5e-be’ 혹은 ‘00:0c:29:43:5e:be’ 처럼 16진수로 표현된다.</p>

<ul>
  <li>물리 <em>Appliance</em>의 경우 물리 <em>NIC</em>가 만들어 질때 <em>ROM</em>에 기록한다.</li>
  <li>가상 <em>Appliance</em>의 경우 기본적으로 하이퍼바이저에서 가상 <em>NIC</em>에 할당된다.</li>
</ul>

<p>MAC 주소 맨 앞자리 3개는 벤더코드로 OUI라고 불리고 단말의 NIC를 어디서 제조했는지 알 수 있음. 뒤자리 3개는 UAA라고 벤더에서 할당하거나 무작위로 정해진 값이다.</p>

<p>MAC주소는 <strong>고유한 값을 가지지 않는다</strong>. 그래서 MAC주소가 같은 기기가 여러 대가 같은 이더넷을 쓸 경우 주소를 바꿔줘야 한다.</p>

<p>※ Appliance - 특정 목적에 최적화된 성능 내도록 만들어진 하드웨어, OS, 어플리케이션
※ NIC - **Network Interface Controller의 약자로 인터넷에 연결하기 위한 하드웨어 장치
※ ROM - 한번 기록 시 다시 기록 못하지만 빨라서 바이오스를 저장하는 용도의 저장장치</p>

<h3 id="mac주소와-ip-주소-모두-필요한-이유">Mac주소와 IP 주소 모두 필요한 이유</h3>
<ul>
  <li>MAC Address는 NIC에 할당 된 <strong>물리적</strong> 주소 - 어떤 기기에 프레임 전달하지?</li>
  <li>IP주소는 OS에 할당된 <strong>논리적</strong> 주소 - 어디에 패킷 전달하지?</li>
  <li>이 두 주소를 연결하는 다리가 ARP
    <ul>
      <li>네트워크 계층과 데이터 링크 계층 연결</li>
    </ul>
  </li>
  <li>데이터 링크 계층 - 이더넷</li>
  <li>네트워크 계층 - IP 이기 때문에 양쪽 주소가 필요함</li>
  <li>데이터링크 계층에서 PPP사용하면 MAC은 필요없음</li>
</ul>

<p>※ ppp - 점대점 프로토콜로 연결 양끝 노드간에 일대일(point-to-point)직렬 링크를 구성하여 데이터 전달한다</p>

<p>출처 : 그림으로 배우는 TCPIP구조
http://www.ktword.co.kr/test/view/view.php?m_temp1=1074&amp;id=429</p>

<h3 id="ipaddress-클래스">IPAddress 클래스</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">IPAddress</span> <span class="p">:</span> <span class="n">IParsable</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Net</span><span class="p">.</span><span class="n">IPAddress</span><span class="p">&gt;,</span> <span class="n">ISpanFormattable</span><span class="p">,</span> <span class="n">ISpanParsable</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Net</span><span class="p">.</span><span class="n">IPAddress</span><span class="p">&gt;,</span> <span class="n">IUtf8SpanFormattable</span>
</code></pre></div></div>
<p>.NET에서는 IP 주소를 표기하기위해 IPAddress 클래스를 사용한다.
IPAddress를 초기화 하는 데는 여러 방법이 있다.</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IPAddress</span> <span class="n">ip1</span> <span class="p">=</span> <span class="n">IPAddress</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="s">"192.168.1.13"</span><span class="p">);</span>
<span class="n">IPAddress</span> <span class="n">ip2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">IPAddress</span><span class="p">(</span><span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="m">192</span><span class="p">,</span> <span class="m">168</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">13</span> <span class="p">});</span>
<span class="n">IPAddress</span> <span class="n">ip3</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">IPAddress</span><span class="p">(</span><span class="m">218212544</span><span class="p">);</span>
</code></pre></div></div>

<p>https://www.csharpstudy.com/net/article/3-IP-%EC%A3%BC%EC%86%8C%EC%99%80-%ED%98%B8%EC%8A%A4%ED%8A%B8</p>

<p>https://www.csharpstudy.com/net/article/9-Socket-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8</p>

<p>https://learn.microsoft.com/ko-kr/dotnet/api/system.net.sockets.socket?view=net-8.0</p>

<h3 id="socket-class">Socket class</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Socket</span> <span class="p">:</span> <span class="n">IDisposable</span>
</code></pre></div></div>
<p>Socket은 .NET Framework에서 가장 Low 레벨 클래스로 TcpClient, TcpListener, UDPClient들 모두 Socket을 바탕으로 만들어 졌다. Socket은 AppleTalk, IPX, Netbios 등 다양한 네트워크 통신에서 사용할 수 있다.</p>

<h3 id="ipendpoint">IPEndPoint</h3>
<p>https://learn.microsoft.com/ko-kr/dotnet/api/system.net.ipendpoint?view=net-7.0</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">IPEndPoint</span> <span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="n">Net</span><span class="p">.</span><span class="n">EndPoint</span>
</code></pre></div></div>
<blockquote>
  <p>네트워크 엔드포인트를 IP주소와 포트 번호로 나타낸다.</p>
</blockquote>

<h3 id="socket-클라이언트">Socket 클라이언트</h3>
<p>Socket 클래스는 클라이언트와 서버에서 공히 사용 할 수 있다.</p>

<ul>
  <li>Stream - 데이터 복제와 경계 보존 없이 연결기반 byte 스트림을 지원한다. 이 소켓 유형은 싱글 피어와
    <h3 id="encoding">Encoding</h3>
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Encoding</span> <span class="p">:</span> <span class="n">ICloneable</span>
</code></pre></div>    </div>
    <p>우리가 문자를 패킷으로 보낼 땐 문자를 0101같은 컴퓨터 언어(byte)로 변경해야 한다. 이러한 과정을 <strong>인코딩</strong>이라고 부르며 ASCII, Unicode, UTF8 과 같은 다양한 방식으로 인코딩 할 수 있다. C#에서는 이런 인코딩 과정을 도와주는 Encoding 클래스가 있다.</p>
  </li>
</ul>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="n">s1</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">Unicode</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">uniBytes</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">s2</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">utf8bytes</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">s3</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">defBytes</span><span class="p">);</span>
</code></pre></div></div>
<blockquote>
  <p>이런 방식으로 byte를 다시 사람이 읽을 수 있는 문자로 바꿀 수 있다.</p>
</blockquote>

<p>https://www.csharpstudy.com/Tip/Tip-string-encoding.aspx</p>

<h3 id="addressfamily">AddressFamily</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">AddressFamily</span>
</code></pre></div></div>
<p>네트워크 유형을 뜻한다. 일반 네트워크 IP 통신에선 언제나 AddressFamily.Internetwork를 사용한다. 필드 값으로 AppleTalk, Atm, FireFox, Max 등이 있는데 사용할 경우는 적어보인다.</p>

<h3 id="sockettype">SocketType</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">SocketType</span>
</code></pre></div></div>

<h3 id="socketflags">SocketFlags</h3>
<p>주로 Socket.Send(), Socket.Receive() 메서드와 함께 사용되며 데이터 전송 및 수신 동작을 제어할 수 있다. Field를 몇가지 살펴보자면</p>
<ul>
  <li>None - 기본 동작 소켓 수행</li>
  <li>Peek - 들어오는 메시지를 미리 확인</li>
  <li>OutOfBand - 대역 외 데이터 처리</li>
  <li>DontRoute - 라우팅 테이블 사용하지 않고 보내기</li>
  <li>Truncated - 메시지가 너무 커 지정된 버퍼에 맞지 않아 자른다.
https://learn.microsoft.com/ko-kr/dotnet/api/system.net.sockets.socketflags?view=netcore-3.1</li>
</ul>

<h2 id="소켓-함수">소켓 함수</h2>
<h3 id="bind">Bind</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Socket</span><span class="p">.</span><span class="nf">Bind</span><span class="p">();</span>
</code></pre></div></div>
<p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/984b5482-906d-4683-b012-344b8ddc24be" alt="image" />
응용 프로그램 자신(Local)주소와 소켓번호를 연결하는 작업</p>

<p>서버에서 Bind를 해야하는 이유는 임의의 클라이언트가 서버 프로그램이 만든 소켓과 통신 하려면 그 소켓을 찾을 수 있어야 하며 따라서 서버는 소켓번호와 클라이언트가 알고 있을 서버의 IP주소 및 포트번호(서버의 소켓주소)를 미리 연결 시켜두는 것이 필요하다</p>

<p>간단히 말해 클라이언트가 서버 소켓과 위치를 알기위해 줄로 연결한 작업이다.</p>

<h3 id="accept">Accept</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Socket</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
</code></pre></div></div>
<p>소켓에서 들어오는 연결 시도를 허용하는 함수
소켓과의 연결함
https://learn.microsoft.com/ko-kr/windows/win32/api/winsock2/nf-winsock2-accept</p>

<h3 id="connect">Connect</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Socket</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
</code></pre></div></div>
<p>원격 호스트에 대한 연결 설정.
호스트는 hostname과 port number로 지정된다.</p>

<p>※ 호스트(host) : 네트워크/인터넷에서 호스트는 네트워크/인터넷을 통해 다른 컴퓨터들과 쌍방향 통신이 가능한 컴퓨터</p>

<h3 id="accept와-connect-차이점">Accept와 Connect 차이점</h3>
<ul>
  <li>Accept
    <ul>
      <li>서버 소켓에서 호출</li>
      <li>소켓에서의 연결 시도 허용</li>
    </ul>
  </li>
  <li>Connect
    <ul>
      <li>클라이언트 소켓에서 호출</li>
      <li>서버에 연결하기 위해 호출한다</li>
      <li>서버에서 Accept를 하면 양방향 통신 시작한다</li>
    </ul>
  </li>
</ul>

<h2 id="쓰레드-함수">쓰레드 함수</h2>
<h3 id="join">Join</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Thread</span><span class="p">.</span><span class="nf">Join</span><span class="p">()</span>
</code></pre></div></div>
<p>이 인스턴스가 나타내는 스레드가 종료될 때까지 호출 스레드를 차단
현재 스레드 객체의 작업이 완료되거나 종료 될 때까지 기본 스레드의 실행을 대기 하도록 한다.
이 스레드가 끝날 때까지 메인 프로그램은 종료되지 않는다.</p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href=""></a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="network" /><category term="Network" /><category term="TCPIP" /><summary type="html"><![CDATA[통신을 위한 규칙, 프로토콜 Packet을 처리하려면 규칙이 필요하다 프로토콜 덕에 회사가 달라도 패킷 처리가 가능하다 Https도 프로토콜이다.]]></summary></entry><entry><title type="html">[Unity] Private Repository 패키지를 UPM를 이용한 업데이트 방법</title><link href="http://localhost:4000/unity/%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A7%A4%EB%8B%88%EC%A0%80/" rel="alternate" type="text/html" title="[Unity] Private Repository 패키지를 UPM를 이용한 업데이트 방법" /><published>2024-03-15T00:00:00+09:00</published><updated>2024-03-15T00:00:00+09:00</updated><id>http://localhost:4000/unity/%ED%8C%A8%ED%82%A4%EC%A7%80%20%EB%A7%A4%EB%8B%88%EC%A0%80</id><content type="html" xml:base="http://localhost:4000/unity/%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A7%A4%EB%8B%88%EC%A0%80/"><![CDATA[<h2 id="들어가며">들어가며</h2>
<p>Unity를 이용하다 보니 생산성을 위해 여러가지 모듈을 개발하곤 한다. 나는 만들어진 <strong>모듈</strong>을 GitHub에 올리고 그것을 필요한 프로젝트에서 다시 다운 하는 방식으로 사용하고 있었다.</p>

<p>하지만 이런 방식은 너무 번거롭고 버전관리도 제대로 되지 않아 자동으로 관리할 수 있는 기능을 원했고 그렇게 찾은 것이 <strong>UPM</strong> 기능이다. UPM을 이용하여 Private 한 Repository에 접근해 개발 관리를 쉽게하는 <strong>CI/CD</strong>를 개발 할 것이다.</p>

<h2 id="package-manager">Package Manager</h2>
<p>유니티에는 패키지 매니저라고 하는 기능이 있다. 이는 유니티 프로젝트에 필요한 다양한 패키지를 관리하고 설치할 수 있는 기능이다.</p>

<p>이를 이용하면 번거롭게 GitHub에서 수동으로 다운 받고 사용할 일안하고 자동화를 할 수 있을 것으로 보인다. 작성한 코드를 Registry에 업로드하면 <strong>Github Action</strong>으로 연동을 해 버전을 업데이트 할 수 있다. 이런 모듈은 <strong>AssetStore</strong>처럼 다운받고 사용 할 수 있다.</p>

<p>이 글에서는 GitHub Action은 사용하지 않고 배포하는 법에 대해 쓴다.</p>

<h2 id="1-unity-설정">1. Unity 설정</h2>
<h3 id="1-1-패키지-만드는-법">1-1. 패키지 만드는 법</h3>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/f35905b7-b06b-4cd5-84c8-d10ba68c89b1" alt="image" /></p>
<ol>
  <li>패키지 폴더 열기</li>
  <li>패키지 안에 커스텀 패키지 폴더 만들기</li>
  <li>패키지와 해당 종속성 설명하는 <code class="language-plaintext highlighter-rouge">package.json</code> 필요</li>
  <li><code class="language-plaintext highlighter-rouge">package.json</code> 양식 작성하기
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "name": "com.[company-name].[package-name]",
  "version": "1.2.3",
  "displayName": "Package Example",
  "description": "This is an example package",
  "unity": "2019.1",
  "unityRelease": "0b5",
  "documentationUrl": "https://example.com/",
  "changelogUrl": "https://example.com/changelog.html",
  "licensesUrl": "https://example.com/licensing.html",
  "dependencies": {
 "com.[company-name].some-package": "1.0.0",
 "com.[company-name].other-package": "2.0.0"
 },
 "keywords": [
 "keyword1",
 "keyword2",
 "keyword3"
  ],
  "author": {
 "name": "Unity",
 "email": "unity@example.com",
 "url": "https://www.unity3d.com"
  }
}
</code></pre></div>    </div>
  </li>
</ol>

<hr />
<h3 id="1-2-패키지-폴더-구조-및-방법">1-2. 패키지 폴더 구조 및 방법</h3>
<p>에셋을 패키지화 하기 위해선 우선 유니티에서 <a href="https://docs.unity3d.com/Manual/cus-layout.html">지정한 규격</a>에 맞춰 패키지 폴더를 구성해야 한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;package-root&gt;
  ├── package.json
  ├── README.md
  ├── CHANGELOG.md
  ├── LICENSE.md
  ├── Third Party Notices.md
  ├── Editor
  │   ├── &lt;company-name&gt;.&lt;package-name&gt;.Editor.asmdef
  │   └── EditorExample.cs
  ├── Runtime
  │   ├── &lt;company-name&gt;.&lt;package-name&gt;.asmdef
  │   └── RuntimeExample.cs
  ├── Tests
  │   ├── Editor
  │   │   ├── &lt;company-name&gt;.&lt;package-name&gt;.Editor.Tests.asmdef
  │   │   └── EditorExampleTest.cs
  │   └── Runtime
  │        ├── &lt;company-name&gt;.&lt;package-name&gt;.Tests.asmdef
  │        └── RuntimeExampleTest.cs
  ├── Samples~
  │        ├── SampleFolder1
  │        ├── SampleFolder2
  │        └── ...
  └── Documentation~
       └── &lt;package-name&gt;.md
</code></pre></div></div>

<hr />

<h3 id="1-3-폴더에-패키지-파일-넣기">1-3. 폴더에 패키지 파일 넣기</h3>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/f35905b7-b06b-4cd5-84c8-d10ba68c89b1" alt="image" /><em>meta 파일도 모두 있어야한다.</em></p>

<p>깃허브 Repository 에 올릴 파일들은 패키지 폴더 안에 패키지와 관련 된 모든 파일을 규격에 따라 넣는다. 또한 파일탐색기로 이동했을 때 파일들의 <font color="dodgerred">metafile</font>들이 모두 생성 되어 있는지 확인해야 한다.</p>

<hr />
<h3 id="1-4-manifestjson-파일-설정">1-4. manifest.json 파일 설정</h3>
<p>Packages/manifest.json 파일 편집해 해당 종속성을 설명해야 한다.</p>

<hr />
<h3 id="1-5-asmdef-생성">1-5. asmdef 생성</h3>
<p>패키지에 Script가 있으면 내 Script를 패키지 내 Script와 연결 해야한다.
스크립트에 대응하는 asmdef 유형의 어셈블리 정의 파일을 생성한다.</p>

<p>asmdef파일은 <a href="https://docs.unity3d.com/Manual/cus-asmdef.html">네이밍 컨벤션</a>을 따라 이름을 작성해야 한다. 예를 들어 Runtime 폴더 내에 있는 스크립트에 대응하는 asmdef는</p>

<p><code class="language-plaintext highlighter-rouge">&lt;company-name&gt;.&lt;package-name&gt;.Editor.Tests.asmdef</code> 와 같이 작성해야 한다.</p>

<div class="callout-info-expanded">
<div class="callout-header">asmdef파일</div>
<p>
닷넷 생태계의 C프로젝트와 동일한 단일체이다.
</p>
</div>

<hr />
<h3 id="1-6-라이센스-관련-파일-설정하기">1-6. 라이센스 관련 파일 설정하기</h3>
<p>법적 문제가 생기지 않게 <code class="language-plaintext highlighter-rouge">Third Party Notices.md</code>, <code class="language-plaintext highlighter-rouge">LICENSE.md</code> 파일을 생성하는 것이 좋다.</p>

<p>관련 문서 : <a href="https://docs.unity3d.com/Manual/cus-legal.html">https://docs.unity3d.com/Manual/cus-legal.html</a></p>

<p><code class="language-plaintext highlighter-rouge">LICENSE.md</code> 파일 작성법</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unity Timeline copyright © 2017-2019 Unity Technologies ApS

Licensed under the Unity Companion License for Unity-dependent projects--see [Unity Companion License](http://www.unity3d.com/legal/licenses/Unity_Companion_License).

Unless expressly provided otherwise, the Software under this license is made available strictly on an “AS IS” BASIS WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED. Please review the license for details on these and other terms and conditions.
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Third Party Notices.md</code> 파일 작성법</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This package contains third-party software components governed by the license(s) indicated below:

Component Name: Semver

License Type: "MIT"

[SemVer License](https://github.com/myusername/semver/blob/master/License.txt)

Component Name: MyComponent

License Type: "MyLicense"

[MyComponent License](https://www.mycompany.com/licenses/License.txt)

</code></pre></div></div>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Third Party Notices.md</code> 에서는 라이센스 타입을 작성해 줘야 한다. 자신의 목적에 맞는 적절한 라이센스를 선택해서 넣는다.</p>
</blockquote>

<p>상세한 라이센스 설명 링크 - <a href="https://olis.or.kr/license/compareGuide.do">오픈소스SW 라이선스 종합정보시스템</a></p>

<p>주요한 라이센스 두개를 소개하자면</p>
<ul>
  <li>MIT - 오픈소스, 상업적 이용 원하면 고르면 안된다.</li>
  <li>
    <font color="dodgerred">GPL</font>
    <font> - GPL 소스를 조금만 사용해도 모든 소스 공개해야한다.</font>
  </li>
</ul>

<h2 id="2-repository-설정">2. Repository 설정</h2>
<h3 id="2-1-패키지-repository에-올리기-준비">2-1 패키지 Repository에 올리기 준비</h3>
<p>repository에 접근하는 방법은 두가지가 있는데 HTTPS, SSH 중 하나로 불러올 수 있다. 둘다 장단점이 있다.</p>
<ul>
  <li><strong>HTTPS</strong> - 로그인마다 이름과 비번 적어야 한다.
    <ul>
      <li>UPM이 깃에서 패키지 가져올 때 사용자 자격 증명 입력할 단말이 없어 깃이 UPM에 오류를 보고 한다.</li>
    </ul>
  </li>
  <li><strong>SSH</strong> - 접근시 파일이 내부에 생성되 보안 이슈가 생긴다.</li>
</ul>

<p>나는 <strong>HTTPS</strong>로 선택 했는데 이유는 보안 이슈와 <strong>Git Credential Manager</strong>을 이용해 로그인시 이름과 패스워드를 작성 안해도 되게 만들 수 있기 때문이다.</p>

<hr />
<h3 id="2-2-github-repository-만들기">2-2. GitHub Repository 만들기</h3>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/0848fc1d-14e0-493b-be3a-f8de85e1cf54" alt="image" /><em>Repository 설정</em></p>

<p>패키지 배포용 Repository를 새로 설정하고 만든다.</p>
<ol>
  <li>Private 설정</li>
  <li>리드미 넣기
 2-1. Readme.md의 메타파일도 필요하기에 로컬과 연동시키면 Unity를 켜 만들어준다.</li>
  <li>Unity gitignore 지정</li>
  <li>라이센스는 이미 <code class="language-plaintext highlighter-rouge">LICENSE.md</code> 만들었으니 설정하지 않는다</li>
</ol>

<hr />
<h3 id="2-3-로컬저장소-연결하기">2-3. 로컬저장소 연결하기</h3>
<p>유니티 커스텀 패키지 폴더와 원격 repository를 HTTP를 이용해 연결한다. 패키지 폴더 안에 파일이 있으면 연결이 안되는 파일들을 잠시 다른 곳에 뒀다가 연결이 되면 다시 넣는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git init
</code></pre></div></div>
<blockquote>
  <p>.git 파일 생성</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git remote add http
</code></pre></div></div>
<blockquote>
  <p>Http를 이용한 원격 저장소 연결</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull origin main
</code></pre></div></div>
<blockquote>
  <p>Readme.md 파일 등 받기</p>
</blockquote>

<hr />
<h3 id="2-4-git-credential-helper-설정">2-4. Git Credential Helper 설정</h3>
<p>HTTP로 접근시 매번 로그인 해야하는데 이걸 한번 인증으로 끝낼 수 있게 할 것이다.</p>

<p>Git - <a href="https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Credential-%EC%A0%80%EC%9E%A5%EC%86%8C">Credential 공식 문서</a></p>

<p><a href="https://docs.unity3d.com/Manual/upm-config-https-git.html">유니티 문서</a>에 의하면 아래 두줄을 작성하면 된다.</p>

<p>Follow these steps to access packages in private repositories that use HTTPS Git URLs:
Configure Git to use GCM by running the following command in a terminal:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config --global credential.helper manager
</code></pre></div></div>

<p>Access the repository one time by using a terminal. For example, run the following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git ls-remote --heads https://&lt;url-to-repository&gt; HEAD
</code></pre></div></div>

<hr />
<h3 id="2-5-메타파일-보이게하기">2-5. 메타파일 보이게하기</h3>
<p>만약 패키지 폴더안에 메타파일이 안보일 경우
<strong>ProjectSettings-&gt;Editor-&gt;VersionControl-&gt;Mode-&gt;Visible Meta Files</strong> 설정하기
옛날 버전에 있는 것으로 보이고 최신 버전이면 안보일 것이다.</p>

<h2 id="3-패키지-다운-받기">3. 패키지 다운 받기</h2>
<h3 id="3-1-url을-이용해-다운받기">3-1. URL을 이용해 다운받기</h3>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/f11ac87d-f036-49f7-87a4-a5336cc57432" alt="image" /></p>

<ol>
  <li>깃헙 HTTPS 저장소 주소 복사</li>
  <li>패키지 매니저 열기</li>
  <li>왼쪽 상단위 + 누르고 깃헙 으로 다운 클릭</li>
</ol>

<hr />
<h3 id="3-2-유지보수-주의점">3-2. 유지보수 주의점</h3>
<ul>
  <li>수정할 때마다 버전을 높이고 올려야한다. 아니면 변경 안된다</li>
  <li>반드시 모든 파일이 meta파일이 생성되야함. Readme도 반드시!!
    <ul>
      <li>github Action 을 이용하면 패키지 폴더만 배포할 수 있게 하여 Readme파일을 넣지 않아도 된다.</li>
    </ul>
  </li>
  <li>종속성 필요한 경우
    <ul>
      <li>package.json 종속성 추가하기</li>
      <li>Asmdef 파일 생성하고 Assembly Definition References에 사용중인 패키지 어셈블리 추가</li>
    </ul>
  </li>
</ul>

<hr />

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://drehzr.tistory.com/1544">https://drehzr.tistory.com/1544</a>
<a href="https://www.youtube.com/watch?v=mgsLb3TKljk">https://www.youtube.com/watch?v=mgsLb3TKljk</a>
<a href="https://flyingsquirrel.medium.com/github-license%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EB%82%98%EC%97%90%EA%B2%8C-%EB%A7%9E%EB%8A%94-%EB%9D%BC%EC%9D%B4%EC%84%A0%EC%8A%A4-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0-ae29925e8ff4">https://flyingsquirrel.medium.com/github-license%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EB%82%98%EC%97%90%EA%B2%8C-%EB%A7%9E%EB%8A%94-%EB%9D%BC%EC%9D%B4%EC%84%A0%EC%8A%A4-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0-ae29925e8ff4</a>
<a href="https://docs.unity3d.com/Manual/cus-asmdef.html">https://docs.unity3d.com/Manual/cus-asmdef.html</a>
<a href="https://docs.unity3d.com/Manual/upm-config-https-git.html">https://docs.unity3d.com/Manual/upm-config-https-git.html</a>
<a href="https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Credential-%EC%A0%80%EC%9E%A5%EC%86%8C">https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Credential-%EC%A0%80%EC%9E%A5%EC%86%8C</a>
<a href="https://jh-bk.tistory.com/28">hhttps://jh-bk.tistory.com/28</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="unity" /><category term="Unity" /><category term="PackageManager" /><category term="UPM" /><category term="유니티" /><category term="Git" /><category term="Repository" /><category term="Git Credential Helper" /><category term="CI/CD" /><summary type="html"><![CDATA[들어가며 Unity를 이용하다 보니 생산성을 위해 여러가지 모듈을 개발하곤 한다. 나는 만들어진 모듈을 GitHub에 올리고 그것을 필요한 프로젝트에서 다시 다운 하는 방식으로 사용하고 있었다.]]></summary></entry><entry><title type="html">[Algorithm] GCD 최소공약수 알고리즘</title><link href="http://localhost:4000/algorithm/GCD-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" rel="alternate" type="text/html" title="[Algorithm] GCD 최소공약수 알고리즘" /><published>2024-03-12T00:00:00+09:00</published><updated>2024-03-12T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/GCD%20%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="http://localhost:4000/algorithm/GCD-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"><![CDATA[<p>예전 블로그에서 GCD에 관한 글을 작성하였는데 너무 오래되어 기억이 안나서 다시 재 작성하기로 했다.</p>

<h2 id="최대공약수-최소공배수의-개념">최대공약수, 최소공배수의 개념</h2>
<ul>
  <li>최대공약수 : 두 수의 약수 중 가장 큰 공통된 약수</li>
  <li>최소공배수 : 두 수의 배수 중 가장 작은 공통된 배수</li>
</ul>

<h2 id="유클리드-알고리즘">유클리드 알고리즘</h2>
<p>두 자연수의 최대 공약수(Greatest Common Divisor)를 찾는 알고리즘을 뜻한다.
유클리드 알고리즘으로 푸는 법은 두개가 있다.</p>

<h3 id="첫-번째">첫 번째</h3>
<ul>
  <li>a &gt; b 일 경우 GCD(a,b) = GCD(a-b,b)</li>
  <li>a &lt; b 일 경우 GCD(a,b) = GCD(a, b-a)</li>
  <li>a == b 일 경우 GCD(a,a)=a 이면 최대 공약수이다.</li>
</ul>

<hr />

<h4 id="재귀함수-구현">재귀함수 구현</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">GCD</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">GCD</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">GCD</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h4 id="반복문-구현">반복문 구현</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">GCD</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="두-번째-방법">두 번째 방법</h3>
<h4 id="원리">원리</h4>
<blockquote>
  <p>2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a&gt;b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다.</p>

  <p>이 성질에 따라, b를 r로 나눈 나머지 r’를 구하고, 다시 r을 r’로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.</p>
  <ul>
    <li>위키백과</li>
  </ul>
</blockquote>

<p>A&gt;B일 때 A%B=r 이고 GCD(A,B) = GCD(B,r) 임을 이용하여 푼다.</p>

<p>A % B = r,  B % r = r’ .. 를 반복해 나머지가 0이면 최대공약수이다.</p>

<hr />

<h4 id="반복문-구현-1">반복문 구현</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">GCD</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h4 id="재귀함수-구현-1">재귀함수 구현</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">GCD</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">GCD</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="최소공배수lcm-구현">최소공배수(LCM) 구현</h2>
<p>최소공배수 * 최대공약수 = a * b 임을 이용하여 푼다.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LCM</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span> <span class="o">/</span> <span class="n">GCD</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://seunghyum.github.io/algorithm/Euclidean-algorithm/#">https://seunghyum.github.io/algorithm/Euclidean-algorithm/#</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="algorithm" /><category term="Algorighm" /><category term="최대공약수" /><category term="최소공배수" /><category term="GCD" /><category term="LCM" /><category term="유클리드 호제법" /><category term="유클리드 알고리즘" /><summary type="html"><![CDATA[예전 블로그에서 GCD에 관한 글을 작성하였는데 너무 오래되어 기억이 안나서 다시 재 작성하기로 했다.]]></summary></entry><entry><title type="html">[VScode] Snippet을 이용해 템플릿 사용하기</title><link href="http://localhost:4000/vscode/VSCode-Snippets/" rel="alternate" type="text/html" title="[VScode] Snippet을 이용해 템플릿 사용하기" /><published>2024-03-09T00:00:00+09:00</published><updated>2024-03-09T00:00:00+09:00</updated><id>http://localhost:4000/vscode/VSCode%20Snippets</id><content type="html" xml:base="http://localhost:4000/vscode/VSCode-Snippets/"><![CDATA[<h2 id="snippet">Snippet</h2>
<blockquote>
  <p>스니펫(snippet)은 재사용 가능한 소스 코드, 기계어, 텍스트의 작은 부분을 일컫는 프로그래밍 용어이다. 사용자가 루틴 편집 조작 중 반복 타이핑을 회피할 수 있게 도와준다.
-<a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%8B%88%ED%8E%AB">Wikipedia</a></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">snippet</code>이란 <strong>작은 코드 조각</strong>을 뜻하는 말로 자주 쓰는 코드를 하나의 템플릿으로 만들어 반복작업을 줄일 수 있게 해주는 기능을 말한다.</p>

<p>대부분의 텍스트 편집기, IDE는 이런 <code class="language-plaintext highlighter-rouge">snipet</code> 기능을 지원하며 VScode또한 마찬가지다.</p>

<h2 id="vscode에서-snippet-사용하기">VScode에서 Snippet 사용하기</h2>
<h3 id="1-snippet-파일-열기">1. Snippet 파일 열기</h3>
<p><code class="language-plaintext highlighter-rouge">snippet</code>을 작성하기 위해선 먼저 <code class="language-plaintext highlighter-rouge">snippet</code>코드를 관리하는 <code class="language-plaintext highlighter-rouge">JSON</code>파일을 열어야 한다. 파일을 열기위한 방법은 두가지가 있다.</p>

<hr />

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/63414c56-30f2-4f78-9818-b1f4fa30e2d2" alt="image" /></p>

<p><strong>1. File-&gt;Preferences-&gt;Configure User Snippets</strong></p>

<p><strong>2. Setting-&gt;User Snippets</strong></p>

<hr />

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/b3df2470-fc19-45ba-bca8-60f4c685993a" alt="image" /></p>

<p>위 두가지 방법 중 하나를 실행하면 화면 상단에 커맨드창이 나올것이다. 필요한 <code class="language-plaintext highlighter-rouge">snipet</code> 파일을 열고 없으면 <code class="language-plaintext highlighter-rouge">New Global Snippets file</code>을 눌러 파일이름을 설정 한 후 연다.</p>

<hr />
<h3 id="2-내용-작성하기">2. 내용 작성하기</h3>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
	</span><span class="nl">"snippet-name"</span><span class="p">:{</span><span class="w">
		</span><span class="nl">"prefix"</span><span class="p">:</span><span class="w"> </span><span class="s2">"blog-template"</span><span class="p">,</span><span class="w">
		</span><span class="nl">"body"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
		</span><span class="s2">"---"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"title : '[] '"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"category: "</span><span class="p">,</span><span class="w">
		</span><span class="s2">"tags: []"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"---"</span><span class="p">,</span><span class="w">
		</span><span class="s2">""</span><span class="p">,</span><span class="w">
		</span><span class="s2">""</span><span class="p">,</span><span class="w">
		</span><span class="s2">""</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;div class='Reference'&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;div class='callout-header'&gt; &lt;/div&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;p&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;a href=''&gt;&lt;/a&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;/p&gt;"</span><span class="p">,</span><span class="w">
		</span><span class="s2">"&lt;/div&gt;"</span><span class="w">
	</span><span class="p">],</span><span class="w">
		</span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Blog Template"</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>소스는 다음 규격을 맞춰 작성하면 된다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이름</th>
      <th><center>설명</center></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">snippet-name</td>
      <td>- snippet의 이름<br />- description이 설정 되있지 않으면 Intellisense에서 해당 이름이 표시된다.</td>
    </tr>
    <tr>
      <td style="text-align: center">prefix</td>
      <td>- 자동완성시 불러올 키워드</td>
    </tr>
    <tr>
      <td style="text-align: center">body</td>
      <td>- 자동완성시 불러올 내용<br />- 줄이 여러개일 경우 ,(comma)를 이용해 줄 바꿈을 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">description</td>
      <td>- prefix 작성 시 Intellisense에서 표시 될 설명이다.</td>
    </tr>
  </tbody>
</table>

<hr />
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/c15bcda9-d6d5-4340-a7e4-992411b7f4d6" alt="Honeycam" /><em>snippet을 활용해 생산성을 높일 수 있다</em></p>

<p><code class="language-plaintext highlighter-rouge">snippet</code>이 적용이 되면 위와 같이 작동한다. 단 몇 타자 만으로 긴 코드를 빠르게 작성할 수 있다.</p>

<h2 id="snippet-적용이-안될-경우">Snippet 적용이 안될 경우</h2>
<p>설정을 완벽하게 했음에도 불구하고 Intellisense가 작동하지 않는 경우가 있다. 그럴경우 <code class="language-plaintext highlighter-rouge">setting.json</code>에서 <code class="language-plaintext highlighter-rouge">editor.quickSuggestions</code>을 true로 설정해줘야 한다.</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/53927eaa-961c-4f7a-8006-13142db2a248" alt="image" /><em>View-&gt;Command palette OR Ctrl+Shift+p</em></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"[markdown]"</span><span class="p">:{</span><span class="w">
     </span><span class="nl">"editor.quickSuggestions"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>커맨드 창을 열어 <code class="language-plaintext highlighter-rouge">Open User Setting(JSON)</code>을 적고 위 소스를 넣어주면 된다.</p>

<div class="callout-info-expanded">
<div class="callout-header">setting.json과 quickSuggestions</div>
<p>
setting.json은 작업중인 프로젝트의 셋팅값을 설정하는 파일이고 quickSuggestions 설정은 자동 완성 활성화 여부를 결정하는 값이다.
</p>
</div>

<h2 id="snippet-변수">Snippet 변수</h2>
<p><code class="language-plaintext highlighter-rouge">snippet</code>은 여러 변수 값을 지원한다. <code class="language-plaintext highlighter-rouge">$name</code> or <code class="language-plaintext highlighter-rouge">${name:default}</code> 같은 문구를 사용 함으로써 파일의 이름이나 내용을 불러올 수 있다. 자세한 내용은 <a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">공식문서</a>에서 확인하기 바란다.</p>

<hr />

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://velog.io/@humblego42/VSCode%EC%97%90%EC%84%9C-Snippet-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0">vVSCode에서 Snippet 활용하기</a>
<a href="https://junu-k.medium.com/vscode-%EA%BF%80%ED%8C%81-1-%EB%82%98%EB%A7%8C%EC%9D%98-%EC%8A%A4%EB%8B%88%ED%8E%AB-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-28b6044a77d3">vscode 꿀팁: 나만의 스니펫 사용하기</a>
<a href="https://gnews365.tistory.com/entry/vscode-settingjson-%EC%97%90-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4-%EC%BD%94%EB%93%9C">vscode setting.json 에 들어가기</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="vscode" /><category term="Vscode" /><category term="Snippet" /><category term="Template" /><category term="템플릿" /><category term="스니펫" /><category term="IDE" /><summary type="html"><![CDATA[Snippet 스니펫(snippet)은 재사용 가능한 소스 코드, 기계어, 텍스트의 작은 부분을 일컫는 프로그래밍 용어이다. 사용자가 루틴 편집 조작 중 반복 타이핑을 회피할 수 있게 도와준다. -Wikipedia]]></summary></entry><entry><title type="html">[Git Blog] 마크다운으로 이미지 캡션 추가하기</title><link href="http://localhost:4000/gitblog/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%BA%A1%EC%85%98/" rel="alternate" type="text/html" title="[Git Blog] 마크다운으로 이미지 캡션 추가하기" /><published>2024-03-09T00:00:00+09:00</published><updated>2024-03-09T00:00:00+09:00</updated><id>http://localhost:4000/gitblog/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4%20%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EC%BA%A1%EC%85%98</id><content type="html" xml:base="http://localhost:4000/gitblog/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%BA%A1%EC%85%98/"><![CDATA[<h2 id="이미지-캡션">이미지 캡션</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/4f373422-5831-4b69-8cd3-cef821f8f859" alt="image" /><em>이미지 아래 회색 글씨</em>
캡션이란 위와 같이 이미지 아래 작은 글씨로 이미지에 대한 설명 글을 뜻한다. 한 문장으로 이미지에 대한 설명을 간략히 보여주기에 글을 이해하는데 도움을 주는 기능이다.</p>

<hr />
<h3 id="markdown-이미지">Markdown 이미지</h3>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">![</span><span class="nv">이름</span><span class="p">](</span><span class="sx">링크</span><span class="p">)</span>
</code></pre></div></div>

<p>minimal-mistake 블로그 글을 쓸 때 이미지 표시를 주로 마크다운 기능을 이용해서 작성하는데 아쉽게도 마크다운에선 캡션 기능을 지원하고 있지 않다.</p>

<p><strong>css</strong>를 이용하면 구현이 되지만 <strong>html</strong>태그를 작성해야 하기에 어떻게든 마크다운 만으로 캡션기능을 넣고 싶어 이것 저것 찾아봤다.</p>

<hr />

<h3 id="markdown-이미지-캡션-사용법">Markdown 이미지 캡션 사용법</h3>
<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">![</span><span class="nv">이름</span><span class="p">](</span><span class="sx">링크</span><span class="p">)</span><span class="ge">*캡션내용*</span>
</code></pre></div></div>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/429cfcbd-d2e3-464b-84c3-7f6affb15c4d" alt="image" class="width-half" /><em>em 태그가 만들어진다</em>
html태그를 쓰지 않으면서 마크다운 만으로 캡션을 넣는 방법이 있다. 마크다운 이미지 링크 바로 뒤에 <em>Italics</em>글씨체로 바꿔주는 ** 문법을 넣는다.</p>

<p>해당 문법은 블로그 페이지가 생성될 시 em태그로 변환되어 지는데 css에서 <strong>em</strong>태그 속성을 변경하는 방식으로 캡션 기능을 만든다.</p>

<hr />
<h4 id="css-추가">CSS 추가</h4>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span> <span class="o">+</span> <span class="nt">em</span> <span class="p">{</span>
    <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
    <span class="nl">text-align</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
    <span class="nl">text-emphasis</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">_sass/_page.scss</code>로가서 위 소스를 추가해주면 된다.
이는 img 뒤에 올 em태그의 속성을 변경하는 css로 캡션과 같이 이미지 아래에 글씨가 오게 설정한다.</p>

<p>해당 소스를 그대로 사용하면 em태그로 인해 글씨체가 기울어져 있을 것이다. 일반 글씨체로 바꾸고 싶고 작게 보이게 하고 싶다면 아래 내용을 추가한다.</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">img</span> <span class="o">+</span> <span class="nt">em</span> <span class="p">{</span>
    <span class="nl">display</span><span class="p">:</span> <span class="nb">block</span><span class="p">;</span>
    <span class="nl">text-align</span><span class="p">:</span> <span class="nb">center</span><span class="p">;</span>
    <span class="nl">text-emphasis</span><span class="p">:</span> <span class="m">0</span><span class="p">;</span>
    <span class="nl">font-size</span><span class="p">:</span> <span class="m">0.8em</span><span class="p">;</span> <span class="err">//글씨</span> <span class="err">크기를</span> <span class="err">줄인다</span>
    <span class="nl">font-style</span><span class="p">:</span> <span class="nb">normal</span><span class="p">;</span> <span class="err">//Italics글씨체가</span> <span class="err">아닌</span> <span class="err">일반</span> <span class="err">글씨체</span>
    <span class="nl">color</span><span class="p">:</span> <span class="n">rgba</span><span class="p">(</span><span class="err">$</span><span class="n">text-color</span><span class="p">,</span> <span class="m">0.75</span><span class="p">);</span> <span class="err">//폰트색의</span> <span class="err">투명도를</span> <span class="err">낮춘다</span>
  <span class="p">}</span>
</code></pre></div></div>

<hr />
<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://62che.com/blog/vuepress/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%97%90-%EC%BA%A1%EC%85%98-%EB%8B%AC%EA%B8%B0.html#%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%86%E1%85%A9%E1%84%8B%E1%85%A3%E1%86%BC">https://62che.com/blog/vuepress/%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%97%90-%EC%BA%A1%EC%85%98-%EB%8B%AC%EA%B8%B0.html#%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%86%E1%85%A9%E1%84%8B%E1%85%A3%E1%86%BC</a>
<a href="https://yoophi.github.io/logs/vuepress/image-caption.html">https://yoophi.github.io/logs/vuepress/image-caption.html</a>
<a href="https://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll">https://stackoverflow.com/questions/19331362/using-an-image-caption-in-markdown-jekyll</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="gitblog" /><category term="Git" /><category term="Blog" /><category term="minimal-mistake" /><category term="Jekyll" /><category term="Markdown" /><category term="Caption" /><category term="마크다운" /><category term="캡션" /><summary type="html"><![CDATA[이미지 캡션 이미지 아래 회색 글씨 캡션이란 위와 같이 이미지 아래 작은 글씨로 이미지에 대한 설명 글을 뜻한다. 한 문장으로 이미지에 대한 설명을 간략히 보여주기에 글을 이해하는데 도움을 주는 기능이다.]]></summary></entry><entry><title type="html">[Algorithm] Dynamic Programming(동적 계획법) 설명</title><link href="http://localhost:4000/algorithm/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95-%EC%84%A4%EB%AA%85/" rel="alternate" type="text/html" title="[Algorithm] Dynamic Programming(동적 계획법) 설명" /><published>2024-03-06T00:00:00+09:00</published><updated>2024-03-06T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95%20%EC%84%A4%EB%AA%85</id><content type="html" xml:base="http://localhost:4000/algorithm/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95-%EC%84%A4%EB%AA%85/"><![CDATA[<h2 id="dynamic-programming">Dynamic Programming</h2>
<p>다이나믹 프로그래밍이란 복잡한 문제를 여러개의 작은 문제로 나누고 값을 저장하여 푸는 <strong>방법</strong>을 말한다. 일반적으로 재귀 함수를 통해 이전 함수의 결과 값을 이용해 문제를 풀어나간다.</p>

<h2 id="동적계획법-사용하는-이유">동적계획법 사용하는 이유</h2>
<p>동적계획법은 재귀(Naive Recursion)함수와 비슷하다. 일반적인 재귀 함수는 같은 조건의 작은 문제들이 여러번 반복되어서 효율성이 낮다. 가장 대표적인 문제 중 하나인 <strong>피보나치 수열</strong>을 예시로 들어보자면</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/ba0e9997-bbd3-4b81-aa69-10f8870712ce" alt="image" /></p>

<p>피보나치의 점화식은 <code class="language-plaintext highlighter-rouge">f(n) = f(n-1)+f(n-2)</code> 이다.  만약 <code class="language-plaintext highlighter-rouge">f(n-1)</code>과 <code class="language-plaintext highlighter-rouge">f(n-2)</code> 함수를 각각 호출할 시 겹치는 식이 많아 지는 것을 볼 수 있다. n이 크면 클 수록 겹치는 식이 기하급수적으로 늘어날 것이 분명하다. 이렇듯 재귀함수는 문제의 크기가 클수록 효율성이 매우 떨어진다.</p>

<p>동적계획법은 재귀함수하지만 이미 한번 구한 결과 값을 저장하고 다음에 같은 조건의 식이 발생하면 저장해 놓은 값을 재사용함으로 써 불필요한 연산을 줄여 속도를 매우 높일 수 있다.</p>

<h2 id="사용조건">사용조건</h2>
<h3 id="overlapping-subproblems겹치는-부분-구조">Overlapping Subproblems(겹치는 부분 구조)</h3>
<p>DP는 기본적으로 <strong>겹치는 문제</strong>가 발생할 시에 사용할 수 있다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/ba0e9997-bbd3-4b81-aa69-10f8870712ce" alt="image" /></p>

<p>피보나치 수열과 같이 겹치는 식의 경우 값을 저장했다가 다음번에 같은 식이 발생하면 다시 재사용한다.</p>

<hr />
<h3 id="optimal-substructure최적-부분-구조">Optimal Substructure(최적 부분 구조)</h3>
<p>부분 문제의 최적의 결과 값이 전체 문제의 <strong>최적의 결과</strong>를 낼 수 있는 경우를 뜻한다. 이러한 구조를 가진다면 문제는 여러 작은 부분 문제로 나뉠 수 있고 <strong>작은 문제의 값을 이용해 큰 문제의 값</strong>도 구할 수 있다.</p>

<p>피보나치 수열도 이런 최적 부분 구조를 지녔는데 <code class="language-plaintext highlighter-rouge">f(n) = f(n-1)+f(n-2)</code> 와 같이 작은 부분인 <code class="language-plaintext highlighter-rouge">f(n-1</code>)와 <code class="language-plaintext highlighter-rouge">f(n-2)</code>를 이용해 <code class="language-plaintext highlighter-rouge">f(n)</code>을 구할 수 있다.</p>

<h2 id="dp-적용하기">DP 적용하기</h2>
<h3 id="1-dp문제인지-확인하기">1. DP문제인지 확인하기</h3>
<p>dp를 사용하기 위해선 당연하게도 해당 문제가 DP를 이용하는 문제인지 파악 해야 한다.</p>

<p>파악하는 방법은 위에서 말했던 대로 <strong>큰 문제를 작은 문제로</strong> 나눌 수 있는지 확인하고 작은 문제의 결과 값이 큰 문제의 <strong>최적 값</strong>을 낼 수 있는지 확인한다.</p>

<h3 id="2-점화식-파악하기">2. 점화식 파악하기</h3>
<p>DP문제임을 확인 했다면 <font color="dodgerred">점화식</font>을 알아야 한다.
점화식이란 DP문제를 푸는데 사용하는 재귀식을 말한다. 즉 하위 문제와 상위 문제식간의 상관 관계를 뜻한다.</p>

<p>점화식을 구하는 것이 DP문제의 핵심으로 이를 구해야 재귀 함수를 구현할 수 있다. 점화식은 문제마다 다르기에 문제에 맞는 점화식을 찾아야한다.</p>

<h3 id="3-memoization-방법-구상하기">3. Memoization 방법 구상하기</h3>
<p>점화식을 이용해 구현한 함수의 값을 저장할 방법을 구상 해야 한다. 이렇게 작은 문제에서 사용한 값을 다음에도 쓰기 위해 저장하는 방법을 <strong>Memoization</strong>이라고 한다.</p>

<p>배열에 값을 저장하고 후에 사용하는 문제에서 같은 조건의 문제가 이미 있었을 경우 저장된 값을 불러와 재사용 해야한다.</p>

<h3 id="4-기저-상태-확인하기">4. 기저 상태 확인하기</h3>
<p>가장 많이 실수 하는 부분 중 하나다. 더 이상 쪼갤 수 없는 문제 즉 <font color="dodgerred">가장 작은 문제</font>의 경우의 상황을 확인 해야 한다.</p>

<p>예를 들어 가장 작은 상태일 경우에만 특정 값을 반환하는 등 조건 식을 만드는데 문제의 상황에 따라 다르다.</p>

<p>힘들게 점화식을 풀어도 미처 생각지도 못한 부분에서 오류가 발생할 수 있으니 <strong>여러 경우의 수</strong>들을 생각하며 조건을 알아야 한다.</p>

<h3 id="5-구현하기">5. 구현하기</h3>
<p>마지막으로 구상한 내용들을 토대로 코드를 작성하면 된다.</p>

<h2 id="사용방법">사용방법</h2>
<h3 id="bottom-up-방식---반복문">Bottom-Up 방식 - 반복문</h3>
<p>작은 문제를 계산하고 그 값들을 누적 해서 큰 값을 구하는 방식이다. 결과 값을 저장하는 배열 dp가 있다고 했을 때 작은 문제에서 사용하던 결과 값을 저장해 놓은 다음 큰 문제에서 하위 문제에서 저장한 값을 가져다 사용한다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/87fc9c70-0db4-4a97-8645-07b84905467b" alt="image" /></p>

<p>이 방식을 <strong>Tabulation</strong> 방식이라고 하는 이유는 반복문을 통해 테이블의 처음부터 끝까지 채우는 과정을 <strong>table-filling</strong> 이라고 부르기 때문이다.</p>

<p>결과 값을 저장하고 기억한다는 점에선 Memoization과 비슷하다.</p>

<hr />
<h3 id="top-down-방식---재귀">Top-Down 방식 - 재귀</h3>
<p>n값을 구하기 위해 가장 작은 문제인 기저 상태에서 시작하는 대신 가장 큰 문제인 <code class="language-plaintext highlighter-rouge">dp[n]</code>부터 시작하는 방식을 말하며, 내려갈 식까지 간 후 결과 값을 반환하는 방식으로 <strong>재귀</strong>를 통해 푸는 방식이다.</p>

<p>이전에 계산을 완료 했을 경우 저장 된 값을 불려와 이용하는 Memoization 방식을 쓴다.</p>

<h2 id="분할정복divide-and-conquer과의-차이점">분할정복(Divide and Conquer)과의 차이점</h2>
<ul>
  <li>분할 정복과 큰 문제를 작은 문제로 나눠 계산하는 방식을 같다.</li>
  <li>그러나 하위 문제 중복 여부에 따라 다르다
    <ul>
      <li>분할 정복은 하위 문제가 중복이 일어나지 않을 때 사용</li>
      <li>DP는 하위 문제가 <strong>중복</strong>이 될 경우에 사용</li>
    </ul>
  </li>
</ul>

<h2 id="관련-문제">관련 문제</h2>

<ul>
  <li>
    <p><a href="https://www.acmicpc.net/problem/1003">1003번: 피보나치 함수</a> - 기본적인 피보나치 함수</p>
  </li>
  <li>
    <p><a href="https://www.acmicpc.net/problem/1149">1149번: RGB거리</a> - 조금 더 복잡한 DP 문제</p>
  </li>
  <li>
    <p><a href="https://www.acmicpc.net/problem/12865">12865번: 평범한 배낭</a> - 대표적인 DP 문제중 하나인 냅색(Knapsack) 문제</p>
  </li>
  <li>
    <p><a href="https://www.acmicpc.net/problem/2098">2098번: 외판원 순회</a> - 유명한 DP문제중 하나인 TSP 문제</p>
  </li>
</ul>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95">https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95</a>
<a href="https://80000coding.oopy.io/60c3d4d3-f569-4b47-bdde-9a65d30f3bc5">https://80000coding.oopy.io/60c3d4d3-f569-4b47-bdde-9a65d30f3bc5</a>
<a href="https://syujisu.tistory.com/entry/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-Dynamic-Programming%EA%B3%BC-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-Divide-and-Conquer-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">https://syujisu.tistory.com/entry/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95-Dynamic-Programming%EA%B3%BC-%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-Divide-and-Conquer-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="algorithm" /><category term="Algorithm" /><category term="DP" /><category term="Danamic Programming" /><summary type="html"><![CDATA[Dynamic Programming 다이나믹 프로그래밍이란 복잡한 문제를 여러개의 작은 문제로 나누고 값을 저장하여 푸는 방법을 말한다. 일반적으로 재귀 함수를 통해 이전 함수의 결과 값을 이용해 문제를 풀어나간다.]]></summary></entry><entry><title type="html">[C++] 백준 2629번-양팔저울</title><link href="http://localhost:4000/boj/BOJ-2629%EB%B2%88/" rel="alternate" type="text/html" title="[C++] 백준 2629번-양팔저울" /><published>2024-03-06T00:00:00+09:00</published><updated>2024-03-06T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ%202629%EB%B2%88</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-2629%EB%B2%88/"><![CDATA[<p><a href="https://www.acmicpc.net/problem/2629">BOJ 2629-양팔저울</a></p>

<h2 id="문제">문제</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/b8f27588-2419-4e33-b6a8-55f07c43faea" alt="image" /></p>

<div class="code-block1">
예제 입력1
<div class="language-cpp highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code>2
1 4
2
3 2</code></pre></div></div></div>

<div class="code-block2">
에제 출력1
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>Y N</code></pre></div></div></div>

<div class="code-block1">
예제 입력2
<div class="language-cpp highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code>4
2 3 3 3
3
1 4 10</code></pre></div></div></div>

<div class="code-block2">
에제 출력2
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>Y Y N</code></pre></div></div></div>

<h2 id="풀이">풀이</h2>
<p>DP를 사용하여 푸는 문제다.</p>
<ul>
  <li>구슬의 무게 + 왼쪽 추의 무게합 = 우측 추의 무게 합 이 성립될 경우 Y를 출력하라는 문제이다.</li>
  <li>그렇기에 <strong>구슬 무게 = 우측 추의 무게합 - 왼쪽 추의 무게합</strong>이 점화식이다.</li>
  <li>추를 놓는 모든 경우의 수 중 <strong>우측 추의 무게합 - 왼쪽 추의 무게합</strong>이 존재 할 경우 해당 무게와 같은 무게인 구슬이 있으면 해당 구슬은 Y를 출력할 수 있다.</li>
  <li>모든 경우의 수를 탐색할 경우 시간 초과가 발생할 수 있으므로 flag[무게합][i번 째 추]에 체크해서 중복되는 경우는 넘기도록 한다.</li>
</ul>

<h2 id="소스코드">소스코드</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"bits/stdc++.h"</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">weights</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">beads</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">answer</span><span class="p">[</span><span class="mi">50001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">50001</span><span class="p">][</span><span class="mi">600</span><span class="p">];</span>


<span class="kt">int</span> <span class="nf">DP</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">50000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)][</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">answer</span><span class="p">[</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">flag</span><span class="p">[</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">)][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
	<span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">weights</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
	<span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">beads</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">answer</span><span class="p">[</span><span class="n">DP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">answer</span><span class="p">[</span><span class="n">beads</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Y "</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"N "</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Mohitto55</name></author><category term="boj" /><category term="boj" /><category term="백준" /><category term="solved" /><category term="문제풀이 2629번" /><category term="Dynamic Programming" /><category term="DP" /><summary type="html"><![CDATA[BOJ 2629-양팔저울]]></summary></entry><entry><title type="html">[C++] 백준 12865번-평범한 배낭</title><link href="http://localhost:4000/boj/BOJ-12865%EB%B2%88/" rel="alternate" type="text/html" title="[C++] 백준 12865번-평범한 배낭" /><published>2024-03-06T00:00:00+09:00</published><updated>2024-03-06T00:00:00+09:00</updated><id>http://localhost:4000/boj/BOJ%2012865%EB%B2%88</id><content type="html" xml:base="http://localhost:4000/boj/BOJ-12865%EB%B2%88/"><![CDATA[<p><a href="https://www.acmicpc.net/problem/12865">BOJ 12865-평범한 배낭</a></p>

<h2 id="문제">문제</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/a44cd234-e6ab-416d-ba26-dc7cc217c050" alt="image" /></p>

<div class="code-block1">
예제 입력
<div class="language-cpp highlighter-rouge">
<div class="highlight">
<pre class="highlight"><code>4 7
6 13
4 8
3 6
5 12</code></pre></div></div></div>

<div class="code-block2">
에제 출력
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight">
<code>14</code></pre></div></div></div>

<h2 id="풀이">풀이</h2>
<p>DP를 이용하는 <strong>냅색(Knapsack)</strong>문제다.</p>
<ul>
  <li>물건을 넣는 경우와 안넣는 경우 두가지에 대한 모든 경우의 수 중 무게가 k보다 안 높고 value가 가장 높은 경우를 구한다.</li>
  <li>필요없는 경우의 수를 제외하기 위해 flag[무게 합][탐색 중인 배낭 Index]의 값에 가장 높은 value값을 저장하고 만약 이 값보다 낮으면 탐색을 중단한다.</li>
</ul>

<h2 id="소스코드">소스코드</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"bits/stdc++.h"</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">weight</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">value</span><span class="p">[</span><span class="mi">101</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">100001</span><span class="p">][</span><span class="mi">101</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">DP</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">flag</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">));</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">DP</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">+</span> <span class="n">weight</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">v</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="n">x</span><span class="p">]));</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ios_base</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">DP</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Mohitto55</name></author><category term="boj" /><category term="boj" /><category term="백준" /><category term="solved" /><category term="문제풀이 12865번" /><category term="Knapsack" /><category term="Dynamic Programming" /><category term="DP" /><category term="C++" /><category term="배낭문제" /><summary type="html"><![CDATA[BOJ 12865-평범한 배낭]]></summary></entry><entry><title type="html">[UE5] Modifires로 여러 값 반환하기</title><link href="http://localhost:4000/ue5/UE5-Unhanced-Input-IMC-%EC%84%B8%EB%B6%80%EC%84%A4%EC%A0%95/" rel="alternate" type="text/html" title="[UE5] Modifires로 여러 값 반환하기" /><published>2024-03-04T00:00:00+09:00</published><updated>2024-03-04T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20Unhanced%20Input%20IMC%20%EC%84%B8%EB%B6%80%EC%84%A4%EC%A0%95</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-Unhanced-Input-IMC-%EC%84%B8%EB%B6%80%EC%84%A4%EC%A0%95/"><![CDATA[<h2 id="enhancedinput">EnhancedInput</h2>
<p>언리얼엔진5은 기존 InputSystem을 대체하는 Enhanced Input을 이용해 더 확장성 높고 사용하기 편한 입력 시스템을 만들었다. 이 시스템 중 <code class="language-plaintext highlighter-rouge">Input Mapping Context</code>는 하나 이상의 <code class="language-plaintext highlighter-rouge">Input Action</code>을 트리거 할 수 있게 해준다.</p>

<h3 id="mapping-context-설정">Mapping Context 설정</h3>
<p><code class="language-plaintext highlighter-rouge">Mapping Context</code>가 하는 일을 나열해 보자면</p>
<ul>
  <li>키 등록 - 어떤 키를 입력해야 <code class="language-plaintext highlighter-rouge">InputAction</code>이 실행되는지 설정</li>
  <li><code class="language-plaintext highlighter-rouge">Trigger</code> - 특정 키를 홀딩 등 키입력 조건을 설정</li>
  <li><code class="language-plaintext highlighter-rouge">Modifiers</code> - 반환 되는 값을 수정</li>
</ul>

<h2 id="하나의-액션으로-여러값-반환">하나의 액션으로 여러값 반환</h2>
<p>하나의 동작을 하는데 여러 종류의 반환 값이 필요한 경우가 있다. 예를 들면 <strong>이동</strong>이 있을 것이다. 이동은 상하좌우 총 <strong>4가지</strong> 종류의 행동을 할 수 있기에 4종류의 반환 값이 필요하다. 만약 InputAction을 4개를 만들어 각각 하나의 키를 맵핑 하는 방식으로 이동을 구현 한다면 상당히 번거로울 것이다.</p>

<p>하지만 <code class="language-plaintext highlighter-rouge">Modifiers</code>를 이용하면 하나의 <code class="language-plaintext highlighter-rouge">InputAction</code>으로 여러 값을 반환할 수 있다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">키</th>
      <th style="text-align: center">원하는 값</th>
      <th style="text-align: center">Modifire</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">w</td>
      <td style="text-align: center">(0, 1)</td>
      <td style="text-align: center">Swizzle Input Axis Values</td>
    </tr>
    <tr>
      <td style="text-align: center">A</td>
      <td style="text-align: center">(-1,0)</td>
      <td style="text-align: center">Negate</td>
    </tr>
    <tr>
      <td style="text-align: center">S</td>
      <td style="text-align: center">(0, -1)</td>
      <td style="text-align: center">Negate, Swizzle Input Axis Values</td>
    </tr>
    <tr>
      <td style="text-align: center">D</td>
      <td style="text-align: center">(1, 0)</td>
      <td style="text-align: center">None</td>
    </tr>
  </tbody>
</table>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/e65b77fc-c37f-487d-bb1f-74cd250c576d" alt="image" /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://docs.unrealengine.com/5.0/ko/enhanced-input-in-unreal-engine/">https://docs.unrealengine.com/5.0/ko/enhanced-input-in-unreal-engine/</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="Unrealengine5" /><category term="UE5" /><category term="EnhancedInput" /><category term="언리얼엔진5" /><summary type="html"><![CDATA[EnhancedInput 언리얼엔진5은 기존 InputSystem을 대체하는 Enhanced Input을 이용해 더 확장성 높고 사용하기 편한 입력 시스템을 만들었다. 이 시스템 중 Input Mapping Context는 하나 이상의 Input Action을 트리거 할 수 있게 해준다.]]></summary></entry></feed>