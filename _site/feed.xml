<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-10-07T22:38:08+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mohitto55 Note</title><subtitle>모히또의 노트</subtitle><author><name>Mohitto55</name></author><entry><title type="html">[Obsidian] Vercel을 활용한 Obsidian Digital Garden 블로그 만들기</title><link href="http://localhost:4000/obsidian/Vercel%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-Obsidian-Digital-Garden-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/" rel="alternate" type="text/html" title="[Obsidian] Vercel을 활용한 Obsidian Digital Garden 블로그 만들기" /><published>2024-10-07T00:00:00+09:00</published><updated>2024-10-07T00:00:00+09:00</updated><id>http://localhost:4000/obsidian/Vercel%EC%9D%84%20%ED%99%9C%EC%9A%A9%ED%95%9C%20Obsidian%20Digital%20Garden%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EB%A7%8C%EB%93%A4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/obsidian/Vercel%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-Obsidian-Digital-Garden-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/"><![CDATA[<h1 id="옵시디언으로-블로그를-만드는-이유">옵시디언으로 블로그를 만드는 이유</h1>
<p>지금까지 나는 지식을 정리하고 정리한 내용을 공유하기 위해 여러 종류의 블로그 사이트를 사용해 봤다. 맨처음에는 <strong>네이버</strong> 블로그였는데 한국인의 입장에선 확실히 네이버가 접근성이 좋긴하지만 한국인을 제외한 외국인들은 구글 검색에 뜨기가 쉽지않고 디자인이 마음에 들지않아 금방 포기했다.</p>

<p>그 다음은 <strong>티스토리</strong> 블로그였다. 개발관련 자료를 검색하면 많은 자료가 티스토리 혹은 Velog에 올라와 있었다. 나는 직접 커스텀하는 것을 좋아해서 Velog보다는 티스토리가 더 좋다 생각해서 티스토리에서 글을 작성했었다.</p>

<p>물론 편하고 기본적으로 깔끔해서 좋긴 하지만 글을 검색하거나 사이트를 설정하는데 마음에 들지 않아 자연스럽게 손대지 않게 되었다.</p>

<p>좀 더 자유도 높은 블로그가 있을까 찾아봤는데 <strong>GitBlog</strong>가 눈에 들어왔다.<br />
GItBlog는 처음부터 끝까지 기능을 다 커스텀가능하고 테마도 풍부해서 마음에 드는게 많았다. 그 중 Jekyll 테마가 인지도 있어보여서 사용해봤다. 처음에는 css도 직접짜고 여러가지 기능을 넣을 수 있어서 재밌었지만 생산성 부분에서 문제가 커져갔다.</p>

<p>기본적으로 GitBlog는 자유도가 높은 만큼 학습량이 많아 초반에 시간이 오래걸리고 무엇보다 띄어쓰기가 너무 큰 문제였다. Jekyll테마에서만 그런지는 몰라도 줄바꿈이 제대로 적용되지 않아 br 태그를 중간중간 써줘야하고 생각한대로 글이 이쁘게 나오지도 않아서 css를 수정하고 글자도 다시 수정하는 등 글 하나 작성하는데 시간이 오래걸린다. 그리고 나는 옵시디언을 통해 먼저 글을 작성하고 그 글을 정리해서 포스팅하는데 이게 옵시디언과 달리 HTML을 중간중간 써줘야 하다보니 이것도 시간이 많이 걸린다.</p>

<p>그리고 가장 중요한게 조회수인데 사이트맵이 제대로 적용이 안되는지 사람이 몇달간 제대로 들어오지 않곤했다. 그래서 금방 흥미를 잃게 되었다.</p>

<p>결국 포스팅 하는게 귀찮아져서 손을 안대게 됐는데 어떻게 해야 내가 블로그를 열심히 쓰게 될까 생각해 보았다.<br />
지금까지 블로그를 사용했던 경험을 토대로 내가 블로그에서 가장 중요하게 생각하는 걸 3가지를 정해봤다.</p>
<ol>
  <li>포스트 업로드가 쉬워야한다.</li>
  <li>옵시디언에서 작성한 글에서 수정을 거의 안해야한다.</li>
  <li>자유도가 있어야한다.</li>
</ol>

<p>위 조건들을 토대로 찾아본 결과 <strong>Digital Garden</strong> 플러그인을 이용해 옵시디언 노트를 통쨰로 포스팅하는 방식이 가장 적절해 보였다. 아직 시작 단계이지만 얼추 봤을때는 아래의 장점이 있었다.</p>
<ol>
  <li>버튼 몇번으로 업로드, 수정, 삭제가능하다.</li>
  <li>옵시디언 노트 내용이랑 똑같다.</li>
  <li>꾸미기 쉽다.</li>
</ol>

<p>내가 생각한 블로그의 조건이랑 딱 맞아 떨어져보여 한번 시작해보려고 한다.</p>

<h1 id="digital-garden으로-블로그-만들기">Digital Garden으로 블로그 만들기</h1>
<h3 id="플러그인-설치">플러그인 설치</h3>
<ul>
  <li>Community Plugin에 가서 <code class="language-plaintext highlighter-rouge">Digital Garden</code>을 검색해서 설치한다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/3949101f-9e1d-4715-aab9-d6f718819783" alt="image" /></p>

<h3 id="vercel-계정-생성">Vercel 계정 생성</h3>
<ul>
  <li> <a href="https://github.com/signup">Vercel</a>로 가서 GitHub 계정과 연동해준다.</li>
</ul>

<div class="callout-info-expanded">
<div class="callout-header">정보</div>
<p>
클라우드 플랫폼으로, 웹사이트 및 애플리케이션을 배포, 관리, 그리고 성능을 최적화하는 데 도움을 준다. 
주로 Next.js와 같은 프레임워크와 밀접하게 연동된다.
</p>
</div>

<hr />

<h3 id="리포지토리-생성">리포지토리 생성</h3>
<ul>
  <li>리포지토리 생성 후 <a href="https://github.com/oleeskild/digitalgarden">링크</a>로가서 Deploy 버튼 클릭한다</li>
  <li>이렇게 하면 Vercel이 열리고 GitHub 계정에 저장소의 사본이 생성된다. 사본 저장소의 이름을 작성하고 생성하면 Vercel의 단계에 따라 사이트를 인터넷에 게시된다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/8b371813-b355-4c2c-abe4-247c78591a32" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/fa8421f8-0d56-40f9-b1e0-410121ab0f18" alt="image" /></p>

<hr />

<h3 id="github-액세스토큰-생성">GitHub 액세스토큰 생성</h3>
<ul>
  <li>다음으로 GitHub 계정에 대한 액세스 토큰을 만들어야 한다.</li>
  <li>토큰은 저장소를 접근하기 위한 비밀번호 역할을 하여 토큰을 만들어야 작성한 글을 업로드할 수 있다.</li>
  <li>토큰 생성방법은  <a href="https://dg-docs.ole.dev/advanced/fine-grained-access-token/">링크</a>에서 확인할 수 있다. 설정값을 똑같이 넣어준다.</li>
  <li>토큰은 <a href="https://github.com/settings/tokens/new?scopes=repo">여기</a>서 생성할 수 있다. </li>
  <li><strong>토큰 값은 한번 생성됐을때 한번만 알려주니까</strong> 꼭 어딘가에 저장해놓자</li>
</ul>

<hr />

<h3 id="digital-garden-플러그인-설정">Digital Garden 플러그인 설정</h3>
<p>Digital Garden 플러그인에 깃허브 저장소 관련 정보를 넣어줘야한다.</p>
<ol>
  <li>Github repo name: 생성한 레포지토리 이름</li>
  <li>Github username: 깃허브 아이디</li>
  <li>Github token: 방금 생성한 토큰<br />
<img src="https://github.com/user-attachments/assets/47e4cadc-92f5-4432-813a-73bc23b0c3f7" alt="image" /></li>
</ol>

<h2 id="노트-연결하기">노트 연결하기</h2>
<ul>
  <li>프로퍼티를 통해 공개할 노트를 설정할 수 있다.</li>
  <li><strong>dg-publish</strong> : 노트를 다른 사람들에게 공개한다.</li>
  <li><strong>dg-home</strong> : 해당 노트를 메인 페이지로 설정한다.<br />
<img src="https://github.com/user-attachments/assets/ceb39f0c-4d75-41d1-bdf8-6a314375053d" alt="image" /></li>
</ul>

<h2 id="노트-푸시하기">노트 푸시하기</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Digital Garden: Publish Single Note</code>를 눌러서 노트를 공개할 수 있다.</li>
  <li>그리고 사이트 주소를<a href="https://vercel.com/dashboard">Vercel</a>에서 찾고 몇분 뒤면 푸시한 노트가 올라와 있을 것이다.</li>
</ul>

<h1 id="마무리">마무리</h1>
<ul>
  <li>옵시디언에서 글을 쓰고 그것을 그대로 웹사이트에 올리는 것은 분명 편하긴하다.</li>
  <li>하지만 사이드 카테고리가 너무 옵시디언이랑 똑같아 이 부분은 맘에 들지 않는다.</li>
  <li>그래서 대안으로 webpage export 플러그인을 알아봤는데 이건 분명 편해보이지만 깃허브와 연동하는 기능이 없어서 Digital Garden을 계속 쓸것같다.</li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://deepfield.blog/">https://deepfield.blog/kr/%EC%A7%80%EC%8B%9D%EB%82%98%EB%88%94/%EC%98%B5%EC%8B%9C%EB%94%94%EC%96%B8%EC%9C%BC%EB%A1%9C%20%EB%B8%94%EB%A1%9C%EA%B7%B8%20%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/</a>
<a href="https://dg-docs.ole.dev/getting-started/01-getting-started/">https://dg-docs.ole.dev/getting-started/01-getting-started/</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="obsidian" /><category term="UE5" /><category term="UnrealEngine5" /><category term="Fresnel" /><category term="물 셰이더" /><category term="물리 기반 렌더링" /><category term="쉐이더 그래프" /><category term="반사 효과" /><category term="UnrealEngine" /><category term="Shader" /><category term="물리 엔진" /><summary type="html"><![CDATA[옵시디언으로 블로그를 만드는 이유 지금까지 나는 지식을 정리하고 정리한 내용을 공유하기 위해 여러 종류의 블로그 사이트를 사용해 봤다. 맨처음에는 네이버 블로그였는데 한국인의 입장에선 확실히 네이버가 접근성이 좋긴하지만 한국인을 제외한 외국인들은 구글 검색에 뜨기가 쉽지않고 디자인이 마음에 들지않아 금방 포기했다. 그 다음은 티스토리 블로그였다. 개발관련 자료를 검색하면 많은 자료가 티스토리 혹은 Velog에 올라와 있었다. 나는 직접 커스텀하는 것을 좋아해서 Velog보다는 티스토리가 더 좋다 생각해서 티스토리에서 글을 작성했었다.]]></summary></entry><entry><title type="html">[UE5] 프레넬을 활용한 현실감 있는 물 셰이더 만들기</title><link href="http://localhost:4000/ue5/%EC%96%B8%EB%A6%AC%EC%96%BC-%EB%AC%BC%EC%85%B0%EC%9D%B4%EB%8D%94-%EB%B0%8F-%ED%94%84%EB%A0%88%EB%84%AC/" rel="alternate" type="text/html" title="[UE5] 프레넬을 활용한 현실감 있는 물 셰이더 만들기" /><published>2024-10-07T00:00:00+09:00</published><updated>2024-10-07T00:00:00+09:00</updated><id>http://localhost:4000/ue5/%EC%96%B8%EB%A6%AC%EC%96%BC%20%EB%AC%BC%EC%85%B0%EC%9D%B4%EB%8D%94%20%EB%B0%8F%20%ED%94%84%EB%A0%88%EB%84%AC</id><content type="html" xml:base="http://localhost:4000/ue5/%EC%96%B8%EB%A6%AC%EC%96%BC-%EB%AC%BC%EC%85%B0%EC%9D%B4%EB%8D%94-%EB%B0%8F-%ED%94%84%EB%A0%88%EB%84%AC/"><![CDATA[<h2 id="시작하기">시작하기</h2>
<ul>
  <li>언리얼을 이용해서 프로젝트를 시작했는데 컨셉은 청소기를 통해 물체들을 빨아들이는 건데 그 중에서 물같은 유체도 포함된다.</li>
  <li>팀원들에게 부탁하기에는 다들 바빠보여서 이번 기회에 공부할겸 한번 직접 제작해 볼까 한다.</li>
</ul>

<h2 id="fresnel-프레넬-이란">Fresnel 프레넬 이란?</h2>
<ul>
  <li>프레넬이란 모든 빛은 매질(media)에 따라 반사, 흡수, 굴절을 하게 되는데 이 프레넬 공식을 통해 빛의 움직을 계산한다.</li>
  <li>이를 사용하면 물체의 가장자리 빛이 더 강하게 반사되는 현상을 표현할 수 있다.</li>
</ul>

<hr />

<h3 id="골절률-refactive-index">골절률 (Refactive index)</h3>
<ul>
  <li>빛이 특정 매질을 통과해서 이동할때 얼마나 <strong>느려지는지</strong> 비율을 측정한 것이다.</li>
  <li>빛이 느려지면 이동 방향이 바뀌게 된다.</li>
  <li>빛은 여러 파장이 합쳐서 보이게 되는데 이런 파장에 따라 골절률이 달라진다.</li>
  <li>그렇기에 파장별로 골절률 계산을 해야한다.<br />
<img src="https://github.com/user-attachments/assets/8bfec418-635f-4c14-bb49-23067c2b2d10" alt="image" /></li>
</ul>

<hr />

<h3 id="스넬의-법칙snells-law">스넬의 법칙(Snell’s law)</h3>
<ul>
  <li>
    <p>매질에 따라 빛이 꺾이는 것을 알 수 있는 공식이다.<br />
<img src="https://github.com/user-attachments/assets/abc4be5e-62bf-4f95-b6aa-797076eb0a9f" alt="image|200" /></p>
  </li>
  <li>v 는 속도 (velocity)</li>
  <li>λ는 파장 (wavelength)</li>
  <li>n은 골절률 (IOR)</li>
  <li>
    <p>이런 관계를 설명한 것이 스넬의 법칙이다.<br />
<img src="https://github.com/user-attachments/assets/e9bb11eb-7e95-471a-b074-a88950b44b0c" alt="image" /></p>
  </li>
  <li>그래서 물과 기름이 만나면 아래처럼 파장이 변화한다.<br />
<img src="https://github.com/user-attachments/assets/6ffce623-64b5-4330-a11c-12f371b6b900" alt="image" /></li>
</ul>

<hr />

<h3 id="매질이-반사할수도-있다">매질이 반사할수도 있다.</h3>
<ul>
  <li>굴절률이 다른 매질을 만나게되면 특정 각도에서 굴절이 아니라 완전히 <strong>반사</strong>하는 경우가 있다.</li>
  <li>Critical angle처럼 특정 각도를 넘어가면 전반사가 발생한다.<br />
<img src="https://github.com/user-attachments/assets/0d33de0e-adad-403d-b55d-2e6193c57e6f" alt="image" /></li>
</ul>

<hr />

<h4 id="전반사-각도-구하기-공식">전반사 각도 구하기 공식</h4>
<ul>
  <li>대기의 굴절률이 1이고 아크릴의 굴절률이 1.5면 전반사 각은 41.8이 된다.<br />
<img src="https://github.com/user-attachments/assets/8f69a657-2cc3-4871-b42f-c8a925b3d7dd" alt="image" /><br />
<img src="https://github.com/user-attachments/assets/7a908200-6b73-4062-bc31-ea4148acd85a" alt="image" /></li>
</ul>

<hr />

<h3 id="프레넬-공식-fresnel-equation">프레넬 공식 (Fresnel equation)</h3>
<ul>
  <li>그래픽스에서 반사와 굴절을 계산하기 위해서 반사되는 빛의 양과 얼마나 빛이 굴절되는지 알아야한다.</li>
  <li>그 공식이 프레넬 공식인데 유도식은 너무 어려워서 패스
    <ul>
      <li>프레넬 공식은 스넬의 법칙, <a href="https://en.wikipedia.org/wiki/Law_of_reflection">반사 법칙</a> 등을 이용해서 유도된다</li>
    </ul>
  </li>
  <li>일반적으로 컴퓨터 그래픽스에서는 <strong>Schlick’s approximation</strong>을 사용한다. 근사계산 공식이다.
    <ul>
      <li>모든 각도에서의 굴절률(IOR)을 알 수 없기 때문에 근사계산을 해야한다.<br />
<img src="https://github.com/user-attachments/assets/7ea1103a-3294-4a98-ad21-01cf79fdfe96" alt="image" /></li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="그래프">그래프</h4>
<ul>
  <li>프레넬 공식을 그래프와 시키면 다음과 같다.</li>
  <li>가로축 : 시선과 노멀벡터의 각도</li>
  <li>세로축 : 반사율</li>
  <li>
    <p>수평(90도)일 수록 높은 반사율을 보인다.<br />
<img src="https://github.com/user-attachments/assets/f7b49942-a550-4f9d-aa8f-f392c247e2f5" alt="image" /></p>
  </li>
  <li>일반적으로 물체를 수직에서 바라본(0도) 반사율 값을 넣는 근사 계산식을 사용한다.</li>
  <li>R0값이 그래프에서의 0도의 반사율 값이라 보면된다.</li>
  <li>
    <p>대부분의 엔진에서는 F0이라고 표현한다(Fresnel at Degree 0 도 인듯 하다.)</p>
  </li>
  <li>아래는 대기속에 있다고 가정할때의 식이다.<br />
<img src="https://github.com/user-attachments/assets/99a0abe5-c784-4a51-99a7-a34cb82bcb05" alt="image" /></li>
  <li>물의 경우 1.33의 굴절률을 가진다.
    <ul>
      <li><a href="https://pixelandpoly.com/ior.html">매질의 굴절률 리스트</a></li>
    </ul>
  </li>
  <li><strong>일반적으로 이 F0 를 “Metallic” 핀에다가 넣어 주시면 된다</strong><br />
<img src="https://github.com/user-attachments/assets/899e8591-f5fb-49fe-bad0-a1f1e36ca3db" alt="image" /></li>
</ul>

<hr />

<h2 id="물-쉐이더-만들기">물 쉐이더 만들기</h2>
<h3 id="겉부분만-반사시키기">겉부분만 반사시키기</h3>
<p><img src="https://github.com/user-attachments/assets/d20c6596-7ec1-43e1-ab01-de0af6d447c5" alt="image" /></p>

<hr />

<h3 id="언리얼의-fresnal-노드">언리얼의 Fresnal 노드</h3>
<p><img src="https://github.com/user-attachments/assets/bff4eee8-7a85-4657-baf1-2f04446ce392" alt="image" /></p>
<ul>
  <li>Fresnal 노드는 빛의 굴절률 공식이지만 림라이트나 실루엣을 만들때 많이 사용한다.</li>
  <li>다만 이 노드는 Metalic으로 반영되는 Fresnel은 의미가 명확하지만 <strong>이건 그냥 효과</strong>이기 떄문이다.</li>
  <li>이 노드는 사용하면 비물리적인 결과를 산출할 수 있어서 보통 Metalic을 제거하고 <strong>Emissive</strong>를 사용한다.<br />
<img src="https://github.com/user-attachments/assets/441467ab-d6cd-46f0-87ad-d0da12824248" alt="image" /></li>
</ul>

<h2 id="타일링-오프셋">타일링 오프셋</h2>
<h3 id="타일링-오프셋-tiling-offset">타일링 오프셋 (Tiling Offset)</h3>
<ul>
  <li>언리얼은 타일링 오프셋 노드가 따로 없다</li>
  <li>그래서 직접 텍스처 좌표계나 월드 포지션을 통해 이동시켜야한다.<br />
<img src="https://github.com/user-attachments/assets/a435543f-4b38-4d54-8656-dd57233a9475" alt="image" /></li>
</ul>

<h2 id="시간에-따른-노이즈-생성">시간에 따른 노이즈 생성</h2>
<ul>
  <li>Absolute world Position
    <ul>
      <li>절대적인 월드 포지션<br />
<img src="https://github.com/user-attachments/assets/78ace0ae-c67a-42c6-8abe-b5e618cff88f" alt="image" /></li>
    </ul>
  </li>
</ul>

<h3 id="noise-node">Noise Node</h3>
<ul>
  <li>Function으로 노이즈 종류를 변경할 수 있다.<br />
<img src="https://github.com/user-attachments/assets/0a8dc7c5-cd87-402b-8fd8-d05314044d20" alt="image" /></li>
  <li>Output Value를 통해 흰색 검은색 부분 비율을 조절할 수 있다.<br />
<img src="https://github.com/user-attachments/assets/bf0c6d93-8095-4c8a-a699-b3e8049a2ca1" alt="image" /></li>
</ul>

<h2 id="노이즈-조절하기">노이즈 조절하기</h2>
<ul>
  <li>
    <p>Multiply로 Destortion(파괴) 값을 조절해서 노이즈 값을 연하게 해준다.<br />
<img src="https://github.com/user-attachments/assets/7ad0d9a6-ab4a-4d4f-9ec3-6353cffff0a9" alt="image" /></p>
  </li>
  <li>
    <p>Destortion 값이 1이면 노이즈가 눈에 보여서 줄이는 작업이 필요하다.<br />
<img src="https://github.com/user-attachments/assets/ea45e62a-9ee3-4566-9a7b-d180d8d2cdad" alt="image|300" /></p>
  </li>
</ul>

<h2 id="씬-컬러-적용">씬 컬러 적용</h2>
<ul>
  <li>스크린 포지션에 노이즈를 입히고 그렇게 만들어진 UV에 화면 색깔을 입히면 물처럼 일그러진 효과를 만들 수 있다.<br />
<img src="https://github.com/user-attachments/assets/b35009ce-f3ff-42af-93be-6b1ffe284b07" alt="image" /></li>
</ul>

<p><img src="https://github.com/user-attachments/assets/e3dbb263-152c-4202-bdff-19ba45f7968b" alt="image" /></p>

<h2 id="프레넬-빛-반사효과-추가">프레넬, 빛 반사효과 추가</h2>
<ul>
  <li>프레넬을 추가해서 빛 반사 효과를 준다.<br />
<img src="https://github.com/user-attachments/assets/2ba92d15-5152-47bd-b16d-a76c9f7021f5" alt="image" /></li>
</ul>

<h2 id="일렁임-효과-추가">일렁임 효과 추가</h2>
<ul>
  <li>노이즈 값과 NormalVector를 곱해서 일렁임 효과를 줄 수 있다.<br />
<img src="https://github.com/user-attachments/assets/7996c9ef-666d-4c8f-a041-df1b440b7cb7" alt="image" /></li>
</ul>

<h2 id="투과시키는-빛-일렁임">투과시키는 빛 일렁임</h2>
<ul>
  <li>투과되는 뒤쪽 배경을 일렁이고 싶다면 Refraction을 수정한다.<br />
<img src="https://github.com/user-attachments/assets/f33d512f-f98f-4d38-8247-147f1d715c76" alt="image" /></li>
</ul>

<h2 id="결과물">결과물</h2>
<p><img src="https://github.com/user-attachments/assets/bb2f1eec-6261-40c6-b6b9-639465e37762" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/0134427d-47d6-4b9b-baf9-34ac60a8e218" alt="image" /></p>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://lifeisforu.tistory.com/384">https://lifeisforu.tistory.com/384</a>
<a href="https://www.youtube.com/watch?v=3CcWus6d_B8&amp;t=611s">https://www.youtube.com/watch?v=3CcWus6d_B8&amp;t=611s</a>
<a href="https://www.youtube.com/watch?v=3CcWus6d_B8&amp;t=611s">https://www.youtube.com/watch?v=3CcWus6d_B8&amp;t=611s</a>
<a href="https://www.youtube.com/watch?v=z5VzzPkqtnA">https://www.youtube.com/watch?v=z5VzzPkqtnA</a>
<a href="https://www.youtube.com/watch?v=OFmWEIb_Z70">https://www.youtube.com/watch?v=OFmWEIb_Z70</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="UnrealEngine5" /><category term="Fresnel" /><category term="물 셰이더" /><category term="물리 기반 렌더링" /><category term="쉐이더 그래프" /><category term="반사 효과" /><category term="UnrealEngine" /><category term="Shader" /><category term="물리 엔진" /><summary type="html"><![CDATA[시작하기 언리얼을 이용해서 프로젝트를 시작했는데 컨셉은 청소기를 통해 물체들을 빨아들이는 건데 그 중에서 물같은 유체도 포함된다. 팀원들에게 부탁하기에는 다들 바빠보여서 이번 기회에 공부할겸 한번 직접 제작해 볼까 한다.]]></summary></entry><entry><title type="html">[CS] 페이징과 스와핑을 활용한 가상 메모리 관리 기법 이해하기</title><link href="http://localhost:4000/computerscience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/" rel="alternate" type="text/html" title="[CS] 페이징과 스와핑을 활용한 가상 메모리 관리 기법 이해하기" /><published>2024-08-27T00:00:00+09:00</published><updated>2024-08-27T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0%20%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/computerscience/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC/"><![CDATA[<p>컴퓨터 시스템에서 프로세스는 작업을 처리하기 위해 반드시 데이터를 메모리에 저장해야 한다. 하지만 물리적인 메모리 용량은 제한적이기 때문에, 모든 프로세스가 동시에 메모리에 상주할 수는 없다.</p>

<p>이를 해결하고자 운영체제는 다양한 메모리 관리 기법을 통해 메모리 자원을 효율적으로 배분하고 활용한다. 이러한 기법들은 프로세스의 메모리 사용량을 최적화하고, 실행 속도를 보장하며, 시스템의 안정성을 유지하는 데 중요한 역할을 한다.</p>

<p>오늘은 그중에서도 연속적 메모리 할당, 스와핑, 페이징 등 현대 운영체제에서 흔히 사용되는 메모리 관리 기법들을 자세히 살펴보며, 각각의 장단점과 적용 사례에 대해 알아보자.</p>

<p>이 과정을 통해 컴퓨터 시스템이 어떻게 메모리 자원을 관리하고, 이를 통해 성능을 극대화하는지 이해할 수 있을 것이다.</p>

<h2 id="연속적-메모리할당">연속적 메모리할당</h2>
<p><img src="https://github.com/user-attachments/assets/ef40bf7b-1bf2-469d-827d-c2d2e858536f" alt="image" /></p>
<ul>
  <li>프로세스 영역에 연속적으로 프로세스를 할당해 놓은 것을 의미한다.</li>
  <li>메모리를 차곡차곡 쌓아놓은 형태</li>
  <li>이러한 방식은 비효율적이며 후에 <strong>페이징</strong>이라는 방식으로 프로세스를 관리하는 것이 좋다.</li>
</ul>

<h2 id="스와핑">스와핑</h2>
<p><img src="https://github.com/user-attachments/assets/0a438116-b3bf-4a71-a986-60fdcde2f2d5" alt="image" /></p>
<ul>
  <li>현재 사용하지 않는(휴면상태)인 프로세스를 <strong>보조기억장치</strong>에넘겨서 효율적으로 메모리를 관리하는 기법
    <ul>
      <li><strong>스왑아웃</strong> : 무직백수 프로세스를 부조기억장치로 내쫓는 작업</li>
      <li><strong>스왑 인</strong> : 할일이 생긴 프로세스를 다시 메모리에 들여보내는 작업</li>
      <li><strong>스왑 영역</strong> : 무직백수 프로세스들이 모여지낼 <em>보조기억 장치의 일부 공간</em></li>
    </ul>
  </li>
</ul>

<h3 id="스와핑의-장점">스와핑의 장점</h3>
<p><img src="https://github.com/user-attachments/assets/b7043fb1-1309-4c59-a613-0cfea6ef443a" alt="image" /></p>
<ul>
  <li>내가 로아, 마크, 림월드 같은 큰 메모리를 필요로 하는 프로세스를 동시에 띄어 놓아야 하는 상황이있다.</li>
  <li>하지만 프로그램들의 메모리 용량은 물리 메모리의 허용된 용량보다 큰데 그럴때 빛을 발한다.</li>
  <li>실제로 사용하지 않는 프로세스는 보조기억장치에 넘기고 해당 자리에 다른 프로세스를 넣어서 모든 프로세스가 돌갈 수 있게 해준다.</li>
</ul>

<h3 id="명령어">명령어</h3>
<p><img src="https://github.com/user-attachments/assets/89fbc725-6d8e-4c50-8cc8-20800808f45c" alt="image" /></p>

<h2 id="연속-메모리-할당-방법">연속 메모리 할당 방법</h2>
<h3 id="최초-적합first-fit">최초 적합(first-fit)</h3>
<p><img src="https://github.com/user-attachments/assets/4bc86db6-3665-45ac-ac7e-b55213863e63" alt="Pasted image 20240731230854" /></p>

<ul>
  <li>프로세스를 적재할 공간을 발견하자마자 해당 공간에 적재하는 방식</li>
  <li>Greedy Algorithm같은 방식이다.</li>
  <li>빠르게 할당 가능하다.
    <h3 id="최적-적합best-fit">최적 적합(best-fit)</h3>
    <p><img src="https://github.com/user-attachments/assets/ccc12a6c-c5e0-42da-b37f-bb4cc29bef1d" alt="image" /></p>
  </li>
  <li>빈공간들 중 프로세스가 들어설 수 있는 가장 작은 공간에 할당하는 방</li>
</ul>

<h3 id="최악-적합worst-fit">최악 적합(worst-fit)</h3>
<p><img src="https://github.com/user-attachments/assets/0368ebfb-959d-454d-a24a-13b210ddac77" alt="image" /></p>
<ul>
  <li>가장 큰 공간에 할당하는 방법</li>
  <li><strong>외부 단편화</strong>문제 때문에 효율 낭비가 심한 방법이다.</li>
</ul>

<h2 id="외부-단편화">외부 단편화</h2>
<p><img src="https://github.com/user-attachments/assets/aad9f5ca-8b71-4f2d-b449-e6795dde2b0d" alt="image" /></p>
<ul>
  <li>외부 단편화란 메모리 중간중간 작은 빈 공간이 생겨나는 것을 뜻한다.</li>
  <li>이 현상의 단점은 CS MemoryStream과 같이 큰 용량의 프로세스는 여러개의 작은 공간에 할당 할 수 없는 문제가 생긴다.</li>
</ul>

<h3 id="해결법1--컴팩션">해결법1 : 컴팩션</h3>
<ul>
  <li>Garbage Collector의 메모리 컴팩션과 같은 원리다.</li>
  <li>띄엄띄엄 놓여진 프로세스 메모리들을 압축해서 하나로 연결한다.</li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li>오버헤드가 심하다.</li>
  <li>컴팩션중 프로세스 이용이 불가하다.</li>
</ul>

<h3 id="해결법2-페이징">해결법2: 페이징</h3>
<ul>
  <li>가상 메모리 기법으로 현대 운영체제 대부분이 사용하는 메모리 관리 기법이다.</li>
</ul>

<h1 id="14-2-페이징을-이용한-가상-메모리-관리">14-2 페이징을 이용한 가상 메모리 관리</h1>
<h2 id="페이징paging이란">페이징(paging)이란</h2>
<p><img src="https://github.com/user-attachments/assets/ca7ce90a-0410-4a70-bbb5-3db0c87f9226" alt="image" /></p>
<ul>
  <li>페이징이란 하나의 프로세스를 잘게 나눠서 <strong>외부 단편화</strong>된 메모리 공간에 프로세스를 할당함으로써 비연속적인 메모리 공간을 효율적으로 사용할 수 있게 해주는 메모리 관리 기법이다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/144c01fb-45a4-4f8d-bc29-944baf5fde83" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/251c4b27-6f4b-4c96-b97b-a90f61b39278" alt="image" /></p>

<ul>
  <li>좀 더 문서체로 말하자면 다음과 같다.
    <ul>
      <li>프로세스의 논리 주소 공간을 <strong>페이지(page)</strong> 단위로 자른다.
        <ul>
          <li>페이지 단위는 일정하나 일부 운영 체제에서는 Huge page라고 큰 용량의 페이지를 할당하는 경우도 있다.</li>
        </ul>
      </li>
      <li>메모리의 물리 주소 공간을 프레임(frame)라는 단위로 페이지와 같은 크기로 자른다.</li>
      <li>그리고 페이지를 프레임에 끼워 맞추는 방법이다.</li>
    </ul>
  </li>
</ul>

<h3 id="페이지-스와핑">페이지 스와핑</h3>
<p><img src="https://github.com/user-attachments/assets/5711310e-e824-4950-925b-1f16917d9208" alt="image" /></p>
<ul>
  <li>페이지를 스와핑 한다고? 그럼 프로그램이 제대로 돌아가지 않는거 아닌가?
    <ul>
      <li>그렇지 않다. 사실 프로세스가 실행되는 데는 모든 페이지가 필요한 것이아니다.</li>
      <li>일부 페이지를 보조기억 장치로 <strong>아웃</strong>시킴으로 써 논리 메모리 용량이 물리 메모리 용량 보다 더 크게 프로세스를 할당 할 수 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="페이지-테이블">페이지 테이블</h2>
<ul>
  <li>페이지 방식의 메모리 관리 기법은 불연속적으로 메모리가 존재한다.</li>
  <li>그럼 CPU에서는 해당 메모리 주소들을 어떻게 관리할까?</li>
  <li>분명 주소가 있어야 하는데 어디에 주소를 넣어놓는거지??</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/be314d5e-68d8-4366-b33c-5c54cbc4da3a" alt="image" /></p>
<ul>
  <li>그것이 바로 페이지 테이블(Page table)
    <ul>
      <li>페이지와 프레임 주소를 연결 시켜준다.</li>
    </ul>
  </li>
</ul>

<h3 id="내부-단편화">내부 단편화</h3>
<p><img src="https://github.com/user-attachments/assets/57449fba-db83-41e3-ad2f-ae6651e29ad7" alt="image" /></p>

<ul>
  <li>그런데 이런 페이지도 단점이 있다!</li>
  <li>바로 프로세스를 페이지로 자를 경우 마지막 페이지 부분이 프로세스 크기와 딱 맞아 떨어지지 않아서 빈 공간이 생기는 현상이다.</li>
  <li>외부 단편화가 물리 메모리주소에 단편화 현상이 발생한 거라면 내부 단편화는 프로세스 자체에 단편화 현상이 발생한 것이다.</li>
</ul>

<p><img src="https://github.com/user-attachments/assets/e67405c2-af02-4f2f-8e38-96a29cca8f88" alt="image" /></p>
<ul>
  <li>페이지 크기 명령</li>
</ul>

<h2 id="process-table-base-registerptbr">Process Table Base Register(PTBR)</h2>
<p><img src="https://github.com/user-attachments/assets/01c3a0fd-d783-4566-a6d7-5d91e3629aae" alt="image" /></p>

<ul>
  <li>페이지 테이블의 위치를 가리키는 주소
    <ul>
      <li>이것은 메모리가 아니라 [[CPU]]에 저장되어있다.</li>
    </ul>
  </li>
</ul>

<h3 id="뭔가-비효율-적인데">뭔가…? 비효율 적인데</h3>
<ul>
  <li>원하는 페이지에 접근하려면 페이지 테이블 &gt; 페이지 이렇게 두번 접근해야 한다.</li>
  <li>이는 굉장히 비효율적이다.</li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
혼자 공부하는 컴퓨터구조+운영체제
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="computerscience" /><category term="가상 메모리" /><category term="Virtual Memory" /><category term="페이징" /><category term="Paging" /><category term="스와핑" /><category term="Swapping" /><category term="메모리 관리 기법" /><category term="Memory Management" /><category term="컴퓨터 구조" /><category term="Computer Architecture" /><category term="운영체제" /><category term="Operating System" /><category term="메모리 단편화" /><category term="Memory Fragmentation" /><category term="프로세스 메모리 할당" /><category term="Process Memory Allocation" /><summary type="html"><![CDATA[컴퓨터 시스템에서 프로세스는 작업을 처리하기 위해 반드시 데이터를 메모리에 저장해야 한다. 하지만 물리적인 메모리 용량은 제한적이기 때문에, 모든 프로세스가 동시에 메모리에 상주할 수는 없다.]]></summary></entry><entry><title type="html">[UE5] 언리얼엔진 캐릭터 애니메이션 모션매칭 사용법</title><link href="http://localhost:4000/ue5/UE5-%EB%AA%A8%EC%85%98%EB%A7%A4%EC%B9%AD%EC%82%AC%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="[UE5] 언리얼엔진 캐릭터 애니메이션 모션매칭 사용법" /><published>2024-08-26T00:00:00+09:00</published><updated>2024-08-26T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20%EB%AA%A8%EC%85%98%EB%A7%A4%EC%B9%AD%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-%EB%AA%A8%EC%85%98%EB%A7%A4%EC%B9%AD%EC%82%AC%EC%9A%A9%EB%B2%95/"><![CDATA[<p>언리얼엔진이 5.4버전이 나오면서 모션매칭 기능이 새로 발표되었다.<br />
모션 매칭은 캐릭터 애니메이션을 위한 차세대 프레임워크다. 이 기술은 언리얼 엔진 5.4 버전에서 새롭게 도입되었으며, 캐릭터의 움직임을 더욱 자연스럽고 역동적으로 만드는 데 중점을 준다.</p>

<p><br /></p>
<p>
모션매칭을 이용한 애니메이션 제작은 기존 방식과 큰 차이가 있다. 모션 매칭의 주요 특징으로는 다음과 같다.<br />
<font color="dodgerred">1. 데이터 기반 접근</font>: 모션 매칭은 대규모의 캡처된 애니메이션 데이터베이스를 활용합니다.<br />
<font color="dodgerred">2. 실시간 검색</font>: 게임 내 캐릭터의 현재 모션 정보를 키로 사용하여 데이터베이스에서 가장 적합한 애니메이션을 실시간으로 검색합니다.<br />
<font color="dodgerred">3. 자연스러운 전환</font>: 복잡한 로직 없이도 다양한 애니메이션 클립 간의 자연스러운 전환이 가능합니다.<br />
<font color="dodgerred">4. 확장성</font>: 애니메이션 기능을 위한 확장 가능한 프레임워크를 제공합니다.<br />
</p>

<p><br /><br />
기존에는 특정 조건에 맞는 애니메이션을 하나하나 직접 설정해줘야 했지만 모션 매칭은 데이터 기반으로 현재 상태에서 가장 적합한 애니메이션을 자연스럽게 자동으로 설정해준다.</p>

<p><br /></p>
<h1 id="모션매칭-사전준비">모션매칭 사전준비</h1>
<h2 id="플러그인-설치">플러그인 설치</h2>
<ul>
  <li>아래 두 플러그인 설치하고 다시 시작한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/dbc4cc87-7a25-4b1d-ba26-266c97506563" alt="image" /><br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/7e725cda-a1ba-4064-a128-da6e780383ce" alt="image" /></li>
</ul>

<h2 id="애니메이션-시퀀스들-준비하기">애니메이션 시퀀스들 준비하기</h2>
<h3 id="모션-매칭-스키마-생성">모션 매칭 스키마 생성</h3>
<ul>
  <li>접두사는 PSS_</li>
  <li>각도 회전 값등 변수 설정하는 애셋이다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/331aea83-d937-4559-845f-ecc26b726c6c" alt="image" /></li>
</ul>

<hr />

<h3 id="database-생성">Database 생성</h3>
<ul>
  <li>
    <p>모션 매칭에 사용될 애니메이션들을 담는 데이터를 생성한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/6c101550-6a54-4a12-a0b9-da28e1352eeb" alt="image" /></p>
  </li>
  <li>적용할 스키마를 선택한다.</li>
  <li>접두사는 PSD_<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/04961922-19f6-47d4-88e8-5692eacf7047" alt="image" /></li>
</ul>

<hr />

<h4 id="psddatabase-화면">PSD(Database) 화면</h4>
<ul>
  <li>이제 여기에 사용할 애니메이션을 드래그 하면된다.</li>
  <li>그전에 <strong>루트모션</strong>을 사용 중인지 확인 해야한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/896d1c75-1c1b-4a07-b845-d8cf73b2a123" alt="image" /></li>
</ul>

<hr />

<h4 id="애니메이션-한번에-수정하기">애니메이션 한번에 수정하기</h4>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/5e49972c-c46e-436e-90dd-29f8af77b1ee" alt="image" /></p>

<ul>
  <li>컨트롤 a를 눌러 모두 선택후 EnableRootMotion을 활성화 한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/e10b9b6c-489e-4f8f-af60-5610d371c867" alt="image" /></li>
</ul>

<hr />

<h4 id="locomotion-psd-생성하기">Locomotion PSD 생성하기</h4>
<ul>
  <li>DB에서 애니메이션을 넣는다.</li>
  <li>각각 상하좌우 방향으로 시작, 진행 중, 멈출 때 해당하는 Walk 모션을 넣어준다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/36724702-59f2-4684-a817-0ae49418333f" alt="image" /></li>
</ul>

<p><br /></p>

<h1 id="모션매칭-활용하기">모션매칭 활용하기</h1>
<h2 id="abp-설정하기">ABP 설정하기</h2>
<ul>
  <li>Motion Matching 노드를 불러와 모션매칭 DataBase를 가져온다.</li>
  <li>그리고 현재 애니메이션에서 추적하기 위해 Trajectory(궤적)을 불러와야 한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/6c49c019-d49b-4f55-af2a-4ab987c59842" alt="image" /></li>
</ul>

<hr />

<h3 id="trajectory-컴포넌트-설치하기">Trajectory 컴포넌트 설치하기</h3>
<ul>
  <li>ABP를 사용할 BP에서 <code class="language-plaintext highlighter-rouge">Character Trajectory</code> 컴포넌트를 부착한다.</li>
</ul>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/31db32d6-577e-49b2-9075-bc079c638a43" alt="image" /></p>

<hr />

<h3 id="trajectory-정보-가져오기">Trajectory 정보 가져오기</h3>
<ul>
  <li>ABP와 BP의 Trajectory를 연결해야한다.</li>
  <li>그렇기 위해선 ABP의 EventGraph에서 자신을 사용하는 BP를 가져와야 한다.</li>
  <li>
    <p>자신을 사용중인 Actor를 가져와 그 액터 BP를 변수로 설정한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/128cb3a3-5f92-4268-a926-57aeb39bb0dd" alt="image" /></p>
  </li>
  <li>
    <p>변수화한 Owner Actor를 불러와 Trajectory를 매 프레임마다 변수화 시킨다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/c697f497-df56-46d3-bed8-1bb8e34fdb2f" alt="image" /></p>
  </li>
  <li>그리고 다시 AnimGraph로 돌아가서 Trajectory를 설정해준다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/a5b14922-a3a4-4367-b352-58a285a1615d" alt="image" /></li>
</ul>

<h2 id="디버깅-궤적-확인">디버깅 궤적 확인</h2>
<ul>
  <li>콘솔창에 <code class="language-plaintext highlighter-rouge">a.CharacterTrajectory.Debug 1</code> 을 하면 궤적이 보인다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/592c0d2d-152c-4334-864a-909b3613afec" alt="image" /></li>
</ul>

<h2><br /></h2>
<p><br /></p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://www.youtube.com/watch?v=4ag7fSlEeKA">https://www.youtube.com/watch?v=4ag7fSlEeKA</a>
<a href="https://www.youtube.com/watch?v=S4aBd64t-hY&amp;ab_channel=GorkaGames">https://www.youtube.com/watch?v=S4aBd64t-hY&amp;ab_channel=GorkaGames</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="UnrealEngine" /><category term="Animation" /><category term="MotionMatching" /><summary type="html"><![CDATA[언리얼엔진이 5.4버전이 나오면서 모션매칭 기능이 새로 발표되었다. 모션 매칭은 캐릭터 애니메이션을 위한 차세대 프레임워크다. 이 기술은 언리얼 엔진 5.4 버전에서 새롭게 도입되었으며, 캐릭터의 움직임을 더욱 자연스럽고 역동적으로 만드는 데 중점을 준다.]]></summary></entry><entry><title type="html">[Docker] Ubuntu에서 Docker로 Mysql설치하기</title><link href="http://localhost:4000/network/Docker%EC%97%90-mysql-%EC%84%A4%EC%B9%98/" rel="alternate" type="text/html" title="[Docker] Ubuntu에서 Docker로 Mysql설치하기" /><published>2024-08-17T00:00:00+09:00</published><updated>2024-08-17T00:00:00+09:00</updated><id>http://localhost:4000/network/Docker%EC%97%90%20mysql%20%EC%84%A4%EC%B9%98</id><content type="html" xml:base="http://localhost:4000/network/Docker%EC%97%90-mysql-%EC%84%A4%EC%B9%98/"><![CDATA[<h2 id="docker-설치">Docker 설치</h2>
<blockquote>
  <p>Docker 다운받기</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo wget -qO- http://get.docker.com/ | sh
</code></pre></div>  </div>
</blockquote>

<p><br /></p>

<blockquote>
  <p>Docker 버전 확인</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -v
</code></pre></div>  </div>
  <p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/5c72a46d-5327-48a0-bfbe-c5e80a298495" alt="image" /></p>
</blockquote>

<h2 id="mysql-설치">Mysql 설치</h2>
<p><br /></p>
<blockquote>
  <p>Docker 이미지 다운</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker pull mysql
</code></pre></div>  </div>
</blockquote>

<blockquote>
  <p>다운받아진 이미지 확인</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker images
</code></pre></div>  </div>
  <p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/64449571/2bd321ec-4107-480c-ab6f-6987f1401fd8" alt="image" /></p>
</blockquote>

<p><br /></p>

<blockquote>
  <p>컨테이너를 실행하기</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --name mysql-container -e MYSQL_ROOT_PASSWORD=&lt;password&gt; -d -p 3306:3306 mysql:latest
</code></pre></div>  </div>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">--name &lt;container_name&gt;</code> : <code class="language-plaintext highlighter-rouge">&lt;container_name&gt;</code> 이름의 컨테이너를 실행한다.<br /><br />
<code class="language-plaintext highlighter-rouge">-e</code> : 컨테이너 내에서 사용할 환경변수를 설정<br /><br />
<code class="language-plaintext highlighter-rouge">-e MYSQL_ROOT_PASSWORD=&lt;password&gt;</code> : MySQL의 root 권한의 비밀번호를 <code class="language-plaintext highlighter-rouge">&lt;password&gt;</code>로 설정한다.<br /><br />
<code class="language-plaintext highlighter-rouge">-d</code> : detach 모드로 컨테이너가 실행된다. 컨테이너가 백그라운드로 실행된다고 보면 된다.<br /><br />
<code class="language-plaintext highlighter-rouge">-p &lt;호스트 포트&gt; &lt;컨테이너 포트&gt;</code> : 호스트와 컨테이너의 포트를 연결한다.<br /><br />
mysql:latest : 컨테이너에 사용할 이미지<br /></p>

<hr />

<blockquote>
  <p>도커 목록 조회</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps -a
</code></pre></div>  </div>
  <p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/64449571/c333d5b9-6317-44e8-ae13-b4698f63f1be" alt="image" /></p>
</blockquote>

<p><br /><br /></p>

<h2 id="도커-이미지-런-오류">도커 이미지 런 오류</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unable to find image 'mysql-container:latest' locally
</code></pre></div></div>
<blockquote>
  <p>이미지 이름이 다르다.<br />
콘테이너랑 이미지는 다른 개념이다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker: Error response from daemon: pull access denied for mysql-container, repository does not exist or may require 'docker login': denied: requested access to the resource is denied.
</code></pre></div></div>
<blockquote>
  <p>로그인을 잘못했거나 이미지에 태그 된 이름이랑 다르거나 둘 중 하나다.</p>
</blockquote>

<p><br /></p>

<h2 id="도커-컨테이너-접속시-오류">도커 컨테이너 접속시 오류</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Error response from daemon: container 1a0ab9fe9da2301b1d7959614ad2e8335ae745cf9b72a2b0394474236526557c is not running
</code></pre></div></div>
<p>콘테이너가 실행되지 않아 발생하는 오류다.<br /><br />
아래 명령어를 통해 원하는 컨테이너를 실행하면 된다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker container start mysql-container
</code></pre></div></div>

<blockquote>
  <p>도커 컨테이너 접속하기</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker exec -it mysql-container bash
</code></pre></div>  </div>
</blockquote>

<blockquote>
  <p>루트권한에 접근하기</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql -u root -p
</code></pre></div></div>
<p><br /><br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/64449571/7d89434e-6c5a-44e6-b812-7794738c5831" alt="image" /></p>

<h2><br /></h2>
<p><br /></p>
<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://hipopatamus.tistory.com/109">https://hipopatamus.tistory.com/109</a>
<a href="https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90">https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="network" /><category term="Docket" /><category term="Ubuntu" /><category term="Linux" /><category term="컨테이너" /><summary type="html"><![CDATA[Docker 설치 Docker 다운받기 sudo wget -qO- http://get.docker.com/ | sh]]></summary></entry><entry><title type="html">[Docker] Docker Image 개념과 구조</title><link href="http://localhost:4000/network/Docker-Image-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="[Docker] Docker Image 개념과 구조" /><published>2024-08-17T00:00:00+09:00</published><updated>2024-08-17T00:00:00+09:00</updated><id>http://localhost:4000/network/Docker%20Image%20%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/network/Docker-Image-%EC%A0%95%EB%A6%AC/"><![CDATA[<h2 id="docker-이미지">Docker 이미지</h2>
<p>컨테이너를 만드는데 사용되는 Template이라 생각하면 된다.<br />
컨테이너는 이미지를 기반으로 생성된다.</p>

<p><br /><br />
이미지는 <code class="language-plaintext highlighter-rouge">Docker hub</code>에서 다운받아서 사용하는 방식으로 도커 계정을 가진 사람들끼리 이미지를 공유할 수 있다.</p>

<hr />

<h3 id="이미지-구조와-레이어">이미지 구조와 레이어</h3>
<p><img src="https://github.com/user-attachments/assets/4f99fce3-c1c1-4b4d-8077-65c5f3f53d2b" alt="image" /></p>

<p><br /><br />
이미지는 용량이 매우 큰데 기본 몇백MB다. 이미지를 업데이트하면 그 큰 용량을 매번 전부 다운 받는것은 비효율적이다. 그래서 Layer 구조를 통해 관리를 한다.</p>

<p><br /><br />
이미지는 기본적으로 <strong>읽기전용(Read-Only)</strong>의 레이어 여러개로 구성되어있다. 이 레이어들은 파일이 추가되거나 수정되면 새로운 레이어를 만든다. 즉 기존 Base레이어는 변경되지않고 새로운 Layer가 추가하면된다.</p>

<p><br /><br />
위 그림처럼 기본 Base Image를 이용해 만드는 새로운 Image는 Layer를 수정하지 않고 새 Layer를 생성한다. 이렇게하면 web app 이미지를 업데이트 할 때 web app layer만 수정하면된다.</p>

<p><br /><br />
맨 우측 그림을 보면 Docker Container에서 web app을 베이스로 이미지 생성을 하는데 해당 이미지 레이어들은 모두 <strong>읽기전용(Read-Only)</strong>으로 생성된다.</p>

<p><br /><br />
컨테이너가 생성될 때마다 Container Layer가 생성되는데 해당 레이어는 <strong>읽기쓰기</strong> 모두 가능하지만 Container가 삭제되면 Container Layer도 삭제된다.</p>

<p><img src="https://github.com/user-attachments/assets/4440ce1c-1063-4b1a-956a-d9d5b2f7b859" alt="image" /></p>

<h2><br /></h2>
<p><br /></p>
<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4">https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4</a>
<a href="https://creboring.net/blog/how-docker-divide-image-layer/">https://creboring.net/blog/how-docker-divide-image-layer/</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="network" /><category term="Docker" /><category term="Ubuntu" /><category term="Linux" /><category term="컨테이너" /><category term="Image" /><category term="Layer" /><summary type="html"><![CDATA[Docker 이미지 컨테이너를 만드는데 사용되는 Template이라 생각하면 된다. 컨테이너는 이미지를 기반으로 생성된다.]]></summary></entry><entry><title type="html">[Docker] Docker와 VM의 차이점</title><link href="http://localhost:4000/network/Docker%EC%99%80-VM-%EC%B0%A8%EC%9D%B4/" rel="alternate" type="text/html" title="[Docker] Docker와 VM의 차이점" /><published>2024-08-16T00:00:00+09:00</published><updated>2024-08-16T00:00:00+09:00</updated><id>http://localhost:4000/network/Docker%EC%99%80%20VM%20%EC%B0%A8%EC%9D%B4</id><content type="html" xml:base="http://localhost:4000/network/Docker%EC%99%80-VM-%EC%B0%A8%EC%9D%B4/"><![CDATA[<h2 id="docker">Docker</h2>
<p>Docker란 컨테이너를 이용한 오픈소스 가상화 플랫폼이다. <br />
컨테이너는 OS레벨의 가상화로 프로세스를 격리시켜 동작하는 것을 말한다. OS자체를 가상화 하던 방식과는 다른데 무슨 차이가 있는것일까?</p>

<h2 id="vm-가상화-vs-docker-가상화">VM 가상화 vs Docker 가상화</h2>
<h3 id="vm">VM</h3>
<ul>
  <li>기존에는 하나의 서버에 하나의 어플리케이션만 구동시켰다.
    <ul>
      <li>이는 남는 자원이 많아진다.</li>
      <li>이를 극복하기 위해 나온것이 가상화다</li>
    </ul>
  </li>
  <li>하이퍼바이저 기반의 가상화가 많이 이용됐다.
    <ul>
      <li>논리적으로 분리된 공간에서 VM이라는 독립된 가상환경 만든다.</li>
      <li>그리고 호스트 시스템에서 VM에 게스트 OS를 구동 및 모니터링 한다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/def35409-b1d9-4484-9a43-c6abd80140ab" alt="image" /><em>VM 구조</em></p>

<h3 id="docker-1">Docker</h3>
<ul>
  <li>Docker은 Guest OS가 필요없다.
    <ul>
      <li>Host OS의 커널을 공유하기 때문이다.</li>
    </ul>
  </li>
  <li>가상화를 할 때마다 OS를 할당해주면 자원 낭비가 된다.</li>
  <li>그래서 Container라는 개념으로 필요한 기능을 모듈화 시켜뗏다 붙여다 하는 식으로 운영이 가능하다.</li>
  <li>Docker의 컨테이너들은 리눅스 OS를 이용한다.
    <ul>
      <li>Host OS가 윈도우나 맥이면 어떻게 하는 것인가?</li>
      <li>WSL 같은 리눅스환경 VM을 사용한다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/user-attachments/assets/15360da2-1cef-4a8d-b2c0-8041522094db" alt="image" /><br />
<br /></p>
<div class="callout-info-expanded">
<div class="callout-header">차이점 요약</div>
<p>
1. VM은 하이퍼 바이저 기능을 이용해 Guest OS를 할당한다.<br />
2. Docker은 Host OS의 커널을 공유해 사용한다<br />
3. VM은 새 환경을 구성할 때 마다 새로운 OS를 다운받아야하지만 Docker은 컨테이너를 늘릴 때마다 OS를 다운할 필요없어 자원 효율성이 더 좋다.
</p>
</div>

<h2 id="사용하는-이유">사용하는 이유</h2>
<h3 id="개발환경-구성">개발환경 구성</h3>
<p>개발하고 서버에 올리면 끝인 상황이다. 그런데 서버에 올리면 작동 하지 않는 경우가 있다.왜 그런가 알아보니 컴퓨터 윈도우, 서버는 리눅스라는 각각 다른 OS를 사용하여 발생하는 오류였다. 각 OS마다 호환되는 기능이 다르기에 발생하는 문제였다.<br />
<br /><br /><br />
하지만 도커를 사용하면 다른 머신에서도 같은 환경 구성이 가능하다.<br />
방법은 간단하다 윈도우, 서버에 둘다 Docker 설치하고 구성하고 싶은 환경 설정하면 된다.<br />
<br /><br /></p>

<p>도커는 파일을 읽고 필요한걸 다운 받고 같은 환경을 컨테이너에 구성한다.<br />
그래서 컴퓨터에서 서버로 코드 업로드하면(Docker와 같이) 잘 작동 한다.<br />
<br /><br /></p>

<p>또 각 컨테이너는 각기 분리되어 있다.컨테이너들은 독립적이다. 이덕에 한개의 서버에서 수많은 컨테이너 가질 수 있다. 만약 자바 애플리케이션이 인기 많으면 자바 컨테이너 늘리고 사용자가 줄면 컨테이너를 줄임으로써 매번 서버를 사고 팔 이유가 없어진다.</p>

<p><br /></p>
<div class="callout-info-expanded">
<div class="callout-header">사용하는 이유 요약</div>
<p>
1. 원하는 개발 환경을 파일에 저장하면 어떤 머신에든 해당 환경 구성해준다.<br />
2. 각 환경을 독립적이기 때문에 무슨 환경이든 모듈식 관리 가능하다.
</p>
</div>

<h2><br /></h2>
<p><br /></p>
<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90">https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90</a>
<a href="https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4">https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="network" /><category term="Docker" /><category term="Ubuntu" /><category term="Linux" /><category term="컨테이너" /><category term="VM" /><category term="가상환경" /><category term="가상머신" /><category term="도커" /><category term="하이퍼바이저" /><category term="HyperVisor" /><category term="Virtual Machine" /><summary type="html"><![CDATA[Docker Docker란 컨테이너를 이용한 오픈소스 가상화 플랫폼이다. 컨테이너는 OS레벨의 가상화로 프로세스를 격리시켜 동작하는 것을 말한다. OS자체를 가상화 하던 방식과는 다른데 무슨 차이가 있는것일까?]]></summary></entry><entry><title type="html">[Window] 구글캘린더 바탕화면에 위젯 생성하기</title><link href="http://localhost:4000/os/%EA%B5%AC%EA%B8%80%EC%BA%98%EB%A6%B0%EB%8D%94-%EC%95%84%EC%9B%83%EB%A3%A9-%EC%97%B0%EB%8F%99-%EB%B0%94%ED%83%95%ED%99%94%EB%A9%B4/" rel="alternate" type="text/html" title="[Window] 구글캘린더 바탕화면에 위젯 생성하기" /><published>2024-08-05T00:00:00+09:00</published><updated>2024-08-05T00:00:00+09:00</updated><id>http://localhost:4000/os/%EA%B5%AC%EA%B8%80%EC%BA%98%EB%A6%B0%EB%8D%94%20%EC%95%84%EC%9B%83%EB%A3%A9%20%EC%97%B0%EB%8F%99%20%EB%B0%94%ED%83%95%ED%99%94%EB%A9%B4</id><content type="html" xml:base="http://localhost:4000/os/%EA%B5%AC%EA%B8%80%EC%BA%98%EB%A6%B0%EB%8D%94-%EC%95%84%EC%9B%83%EB%A3%A9-%EC%97%B0%EB%8F%99-%EB%B0%94%ED%83%95%ED%99%94%EB%A9%B4/"><![CDATA[<h2 id="들어가며">들어가며</h2>
<p>나는 <strong>Todoist, Google Calendar, Obsidian</strong>을 통해 일정관리를 한다.<br />
나는 일정관리에서 제일 중요하다 생각하는 부분이 언제 어디서든 최소한의 액션으로 간편하게 일정을 확인할 수 있어야 한다고 생각한다.<br />
그래서 휴대폰에는 바탕화면에 구글 캘린더 위젯을 생성하고 옵시디언에서 <strong>Full Calendar 플러그인</strong>을 통해 구글 캘린더를 확인할 수 있다.</p>

<p><br /></p>

<p>다만 윈도우의 경우에는 구글캘린더를 바탕화면 위젯으로 생성가능한 기능을 제공하지 않는다. 물론 클릭 몇번이면 브라우저에서 구글 캘린더로 가는건 어렵지 않은 일이지만 일정을 의식적으로 생각해서 확인하는 일은 귀찮은 일이라 바탕화면에서 달력을 확인할 수 있는 방법을 여러가지 모색했다.</p>

<p><br /></p>

<p>그중 달력 위젯 중 가장 유명한 <a href="https://desktop-calendar.softonic.kr/">Desktop Calendar</a>을 사용해보기도 했지만 이것은 구글캘린더와 연동이 되지 않아 금방 삭제했다. 어떻게 해야 구글캘린더를 바탕화면에 표시할까 알아보다 아웃룩과 연동하고 외부 프로그램을 이용하면 가능한 것을 알게되었다. 해당 방법을 아래에 소개하겠다.</p>

<h2 id="1-구글캘린더-주소-복사하기">1. 구글캘린더 주소 복사하기</h2>
<p>구글캘린더에서 우측 상단 톱니바퀴 모양을 눌러 <strong>설정</strong>에 들어가고 왼쪽 탭에서 아웃룩과 연동할 캘린더를 선택해 설정에 들어간다.<br />
아래로 내려서 <strong>Scret address in iCal format</strong> 내용을 우측 복사하기 버튼을 눌러서 클립보드에 복사한다.<br />
<img src="https://github.com/user-attachments/assets/167750ad-2261-47a8-83b0-64c032a5841b" alt="image" /></p>

<h2 id="2-아웃룩과-캘린더-연동">2. 아웃룩과 캘린더 연동</h2>
<p>아웃룩에 들어가 <code class="language-plaintext highlighter-rouge">파일 &gt; 계정 설정 &gt; 인터넷 일정 &gt; 새로만들기</code> 를 누른다.<br />
<img src="https://github.com/user-attachments/assets/9db6166c-05e8-4cc0-8386-fd8413c0260f" alt="image" /><br />
<img src="https://github.com/user-attachments/assets/1dd2aac0-6806-4d7a-a263-a410d6f074c6" alt="image" /></p>

<p><br /></p>

<p>그리고 1에서 복사한 구글캘린더 주소로 일정 등록을 한다.<br />
<img src="https://github.com/user-attachments/assets/72a156f6-3796-4454-b5c9-3d5efe544aa1" alt="image" /></p>

<hr />

<h3 id="연동성공">연동성공</h3>

<p><img src="https://github.com/user-attachments/assets/c2fcdf82-f946-4d14-87e5-37a5ce708b80" alt="image" /></p>

<h2 id="3-ootd-설치하기">3. OOTD 설치하기</h2>
<p>아웃룩을 바탕화면에서 보려면 외부 프로그램을 설치해야한다.</p>

<p><a href="https://outlookonthedesktop.com/release-notes">링크</a>에 들어가서 OOTD앱을 다운 받는다. 실행하면 아래와 같이 바탕화면에 아웃룩 위젯이 생성된다.<br />
<img src="https://github.com/user-attachments/assets/b3d83c1f-374c-4680-8a09-39624d1a96a2" alt="image" /></p>

<p><br /></p>

<p>우측 하단에서 Ootd를 우클릭하고 Select Folder을 누른다.</p>

<p>그리고 인터넷 일정에서 위젯에 보일 일정을 설정하면 바탕화면에서도 일정을 확인할 수 있다.<br />
<img src="https://github.com/user-attachments/assets/ab1a6c4c-0bb1-4ed7-960b-c0043ce75647" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/7e429fb1-c180-497f-b345-ef8bf87cff4e" alt="image" /></p>

<hr />

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://mainia.tistory.com/1830">https://mainia.tistory.com/1830</a>
<a href="https://luckylucy.tistory.com/103">https://luckylucy.tistory.com/103</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="os" /><category term="Window" /><category term="Google Calendar" /><category term="Outlook" /><category term="Widget" /><category term="Calendar" /><category term="윈도우" /><category term="구글캘린더" /><category term="아웃룩" /><summary type="html"><![CDATA[들어가며 나는 Todoist, Google Calendar, Obsidian을 통해 일정관리를 한다. 나는 일정관리에서 제일 중요하다 생각하는 부분이 언제 어디서든 최소한의 액션으로 간편하게 일정을 확인할 수 있어야 한다고 생각한다. 그래서 휴대폰에는 바탕화면에 구글 캘린더 위젯을 생성하고 옵시디언에서 Full Calendar 플러그인을 통해 구글 캘린더를 확인할 수 있다.]]></summary></entry><entry><title type="html">[CS] 컴퓨터에서 문자를 표현하는 방법</title><link href="http://localhost:4000/computerscience/%EB%AC%B8%EC%9E%90%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C/" rel="alternate" type="text/html" title="[CS] 컴퓨터에서 문자를 표현하는 방법" /><published>2024-07-23T00:00:00+09:00</published><updated>2024-07-23T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%EB%AC%B8%EC%9E%90%EB%A5%BC%20%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94%20%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC%20%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C</id><content type="html" xml:base="http://localhost:4000/computerscience/%EB%AC%B8%EC%9E%90%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C/"><![CDATA[<h2 id="문자-집합과-인코딩">문자 집합과 인코딩</h2>
<ul>
  <li><strong>문자집합</strong>
    <ul>
      <li>컴퓨터가 인식할 수 있는 문자의 모음이다.</li>
    </ul>
  </li>
  <li>인코딩
    <ul>
      <li>문자를 0과 1로 변환해 컴퓨터가 이해할 수 있는 정보로 변환하는 과정이다.</li>
    </ul>
  </li>
  <li>디코딩
    <ul>
      <li>0과1을 사람이 이해하는 문자로 변환하는 과정이다.
        <h2 id="아스키-코드">아스키 코드</h2>
      </li>
    </ul>
  </li>
  <li>초창기 문자집합이다.</li>
  <li>7비트로 표현할 수 있는 문자는 총 128개이다.</li>
  <li>표현 가능한 수가 적기 때문에 한글을 표현할 수 없다.</li>
  <li>확장 아스키도 나왔지만 그래도 256개로 요전히 적다.
    <h2 id="ecu-kr">ECU-KR</h2>
  </li>
  <li>한글 인코딩은 두 종류가 있다.</li>
  <li><strong>완성형</strong>과 <strong>조립협</strong>인코딩이 있다.
    <ul>
      <li>완성형은 하나의 글자에 고유한 코드를 부여하고</li>
      <li>조립형은 초성, 중성, 종성에 해당하는 코드를 부여하고 조립하는 형태다.</li>
    </ul>
  </li>
  <li>ECU-KR은 KS X 1001, KS X 1003 이라는 문자 집합 기반으로 하는 <strong>완성형</strong>인코딩 방식이다.</li>
  <li>한글은 각 글자에 2바이트가 부여되어 16비트가 필요하다.</li>
</ul>

<h3 id="한글깨짐-문제">한글깨짐 문제</h3>
<ul>
  <li>2350개로 표현할 수 있지만 그럼에도 모든 한글 조합을 표현할 수 없다.</li>
  <li>그래서 쀍 같은 글자는 깨진다.</li>
  <li>이런 문제를 해결하기 위해 Microsoft의 CP949라는 EUC-KR 확장판이 나왔다.</li>
  <li>다만 이것도 다 표현할 수 없다.</li>
</ul>

<h2 id="인코딩의-문제점">인코딩의 문제점</h2>
<ul>
  <li>ECU-KR처럼 모든 언어별로 인코딩을 해야한다면 프로그램에서 나라별 인코딩언어를 모두 알아내야 한다.</li>
  <li>하지만 통일된 표준 인코딩 방식이 있다면 번거로움이 없을것이다.</li>
</ul>

<h2 id="유니코드와-utf-8">유니코드와 UTF-8</h2>
<ul>
  <li><strong>유니코드</strong>는 대부분의 나라의 문자, 특수문자, 이모티콘도 표현가능한 문자집합이다.</li>
</ul>

<h3 id="인코딩-방식">인코딩 방식</h3>
<ul>
  <li>아스키나 EUC-KR은 글자에 부여된 값으로 인코딩을 한다.</li>
  <li>유니코드는 부여된 값을 활용해 여러 방법으로 인코딩 한다.</li>
  <li>이 방법들 중 UTF-8, UTF-16, UTF-32등이 있다.</li>
</ul>

<h3 id="utf-8">UTF-8</h3>
<ul>
  <li>1바이트부터 4바이트까지의 인코딩 결과를 만든다.</li>
  <li>즉 값이 1바이트가 될 수 도 있고 2, 3, 4 바이트 중 될 수 있다는 것이다.</li>
  <li>이는 유니코드 문자에 부여된 값에 따라 결정된다.</li>
</ul>]]></content><author><name>Mohitto55</name></author><category term="computerscience" /><category term="인코딩" /><category term="디코딩" /><category term="유니코드" /><category term="아스키코드" /><category term="Unicode" /><category term="ASCII" /><category term="Encode" /><category term="Decode" /><category term="ECU-KR" /><category term="UTF-8" /><category term="UTF-16" /><category term="UTF-32" /><summary type="html"><![CDATA[문자 집합과 인코딩 문자집합 컴퓨터가 인식할 수 있는 문자의 모음이다. 인코딩 문자를 0과 1로 변환해 컴퓨터가 이해할 수 있는 정보로 변환하는 과정이다. 디코딩 0과1을 사람이 이해하는 문자로 변환하는 과정이다. 아스키 코드 초창기 문자집합이다. 7비트로 표현할 수 있는 문자는 총 128개이다. 표현 가능한 수가 적기 때문에 한글을 표현할 수 없다. 확장 아스키도 나왔지만 그래도 256개로 요전히 적다. ECU-KR 한글 인코딩은 두 종류가 있다. 완성형과 조립협인코딩이 있다. 완성형은 하나의 글자에 고유한 코드를 부여하고 조립형은 초성, 중성, 종성에 해당하는 코드를 부여하고 조립하는 형태다. ECU-KR은 KS X 1001, KS X 1003 이라는 문자 집합 기반으로 하는 완성형인코딩 방식이다. 한글은 각 글자에 2바이트가 부여되어 16비트가 필요하다.]]></summary></entry><entry><title type="html">[Graphics] 렌더링 파이프라인 정리</title><link href="http://localhost:4000/computergraphics/%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="[Graphics] 렌더링 파이프라인 정리" /><published>2024-06-26T00:00:00+09:00</published><updated>2024-06-26T00:00:00+09:00</updated><id>http://localhost:4000/computergraphics/%EB%A0%8C%EB%8D%94%EB%A7%81%20%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8%20%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/computergraphics/%EB%A0%8C%EB%8D%94%EB%A7%81-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8-%EC%A0%95%EB%A6%AC/"><![CDATA[<h1 id="렌더링-파이프라인">렌더링 파이프라인</h1>
<ul>
  <li>
    <p>3차원 모델을 2차원 화면에 투영하는 렌더링 과정을 말한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/4064224e-0a97-4ad3-b679-ac2329a3f7f8" alt="image" /></p>
  </li>
  <li>
    <p>벌칸 엔진의 렌더링 파이프라인 과정<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/6f13fec2-3d78-4771-91b1-64dd7055770b" alt="image" /></p>
  </li>
</ul>

<h2 id="application">Application</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/8e8fe83c-2539-48a3-9966-e72aed9cf2fd" alt="image" /></p>

<h2 id="좌표계-정하기">좌표계 정하기</h2>
<ul>
  <li>2차원은 왼손 좌표계</li>
  <li>3차원은 오른손 좌표계를 이용한다.</li>
</ul>

<h2 id="geometry-processing">Geometry Processing</h2>
<ul>
  <li><strong>정점 정보를 3D 공간으로 변환하는 단계</strong></li>
  <li>모델, 뷰행렬</li>
  <li>투영, 클립핑 등등</li>
  <li>화면에 표시할 기하학적 요소들을 화면상에 투영시키는 과정</li>
</ul>

<h2 id="resterization">Resterization</h2>
<ul>
  <li><strong>정점 정보를 픽셀 데이터로 변환하는 과정</strong></li>
  <li>프로그래밍이 <strong>불가능</strong>한 단계이다.</li>
  <li>첫번째 단계인 정점 정보를 입력으로 받는다.</li>
  <li>클립 공간으로 변환된 정점들을 통해서 정점, 선분, 삼각형 단위로 처리한다.</li>
  <li>주로 하는 일은 다음과 같다.
    <ul>
      <li>Clipping</li>
      <li>Perspective Division</li>
      <li>Back-face Culling</li>
      <li>Viewport Transformation</li>
      <li>Scan Transformation</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="clipping">Clipping</h3>
<ul>
  <li>절두체 외부 폴리곤은 버려졌지만 내부에 걸친 폴리곤을 잘라내는 작업이다.</li>
</ul>

<hr />

<h3 id="perpective-division">Perpective Division</h3>
<ul>
  <li>원근감을 구현하는 작업</li>
  <li>클립 공간 요소들을 W로 나눈다.</li>
  <li>이렇게 원근 분할을 마친 좌표계를 NDC(Normalized Device Coordinates)라고 한다.</li>
</ul>

<hr />

<h4 id="ndc">NDC</h4>
<ul>
  <li>X,Y 좌표가 모두 -1~1, Z좌표는 0~1인 좌표계</li>
  <li>스크린 좌표로 변환할 수 있도록 하기위한 마지막 좌표계다.</li>
</ul>

<hr />
<h3 id="back-face-culling">Back-face Culling</h3>
<ul>
  <li>보이지 않는 물체의 뒷부분을 제거한다.</li>
</ul>

<hr />

<h3 id="viewport-transformation">Viewport Transformation</h3>
<ul>
  <li>NDC 공간 좌표를 2D 스크린좌표로 변환한다.</li>
</ul>

<hr />

<h3 id="scan-transformation">Scan Transformation</h3>
<ul>
  <li>프리미티브를 통해서 프래그먼트를 생성하고 프래그 먼트를 채우는 픽셀들을 찾는다.</li>
  <li>각 필셀마다 정점 데이터들을 보간하여 할당한다.<br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/4083a7a1-c746-45f8-a497-039313cbdf04" alt="image" /></li>
</ul>

<hr />

<h2 id="vertex-shader-pixel-processing">Vertex Shader, Pixel Processing</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/69a4d28d-f171-4364-b430-6d63338cbcb0" alt="image" /></p>

<ul>
  <li>정점 정보를 3D 공간으로 변환하는 단계</li>
</ul>

<hr />

<h3 id="local-space">Local Space</h3>
<ul>
  <li>3D 물체의 본인이 중심인 좌표계</li>
</ul>

<hr />

<h4 id="model-matrix">Model Matrix</h4>
<ul>
  <li>Local 좌표계를 World 좌표계로 변환하기 위한 행렬</li>
  <li>모든 물체를 화면상에 보이기 위해선 모든 물체의 중심을 월드의 한 점으로 지정해야한다.</li>
  <li>그러기 위해선 Local 좌표계의 정점 정보를 World의 한 점을 기준으로 잡아서 변환 해주어야 한다.</li>
  <li><strong>이동, 회전, 크기</strong> 행렬을 통해 변환해준다. 이 행렬을 <em>변환행렬</em>이라고 한다.</li>
</ul>

<hr />

<h5 id="이동-행렬-translate-matrix">이동 행렬 (Translate Matrix)</h5>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">## 이동 행렬
</span>    <span class="n">moveX</span> <span class="o">=</span> <span class="o">-</span><span class="mi">500</span>
    <span class="n">moveY</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">moveZ</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">moveMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">moveX</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">moveY</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">moveZ</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>
</code></pre></div></div>

<hr />

<h5 id="회전-행렬-rotate-matrix">회전 행렬 (Rotate Matrix)</h5>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">## 회전 행렬
</span>    <span class="c1">### yaw
</span>    <span class="n">rotateX</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rxMathSin</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateX</span><span class="p">))</span>
    <span class="n">rxMathCos</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateX</span><span class="p">))</span>
    <span class="n">rightRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
    <span class="p">[</span><span class="n">rxMathCos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rxMathSin</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="n">rxMathSin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rxMathCos</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="c1">### pitch
</span>    <span class="n">rotateY</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ryMathSin</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateY</span><span class="p">))</span>
    <span class="n">ryMathCos</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateY</span><span class="p">))</span>
    <span class="n">upRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ryMathCos</span><span class="p">,</span> <span class="o">-</span><span class="n">ryMathSin</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ryMathSin</span><span class="p">,</span> <span class="n">ryMathCos</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="c1">### roll
</span>    <span class="n">rotateZ</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rzMathSin</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateZ</span><span class="p">))</span>
    <span class="n">rzMathCos</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateZ</span><span class="p">))</span>
    <span class="n">forwardRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
    <span class="p">[</span><span class="n">rzMathCos</span><span class="p">,</span> <span class="o">-</span><span class="n">rzMathSin</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="n">rzMathSin</span><span class="p">,</span> <span class="n">rzMathCos</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>
    
    <span class="c1">### Yaw Pitch Roll 순으로 계산한다.
</span>    <span class="n">eulerRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">upRotationMatrix</span><span class="p">,</span> <span class="n">rightRotationMatrix</span><span class="p">)</span>
    <span class="n">eulerRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">forwardRotationMatrix</span><span class="p">,</span> <span class="n">eulerRotationMatrix</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">eulerRotationMatrix</span>
    <span class="c1">### 4차원으로 변환
</span>    <span class="n">eulerRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">])</span>
</code></pre></div></div>

<hr />

<h5 id="크기-행렬-scale-matrix">크기 행렬 (Scale Matrix)</h5>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">## 크기 행렬
</span>    <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">scaleMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>
</code></pre></div></div>

<ul>
  <li>해당 행렬들을 곱할 떄는 순서를 주의해야한다.</li>
  <li>순서가 바뀌면 제대로 적용이 되지 않는다.</li>
  <li>열 기준 행렬 - 이동 회전 크기</li>
  <li>행 기준 행렬 - 크기 회전 이동</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">srMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">scaleMatrix</span><span class="p">,</span> <span class="n">eulerRotationMatrix</span><span class="p">)</span>
    <span class="n">srmMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">moveMatrix</span><span class="p">,</span> <span class="n">srMatrix</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h3 id="world-space">World Space</h3>
<ul>
  <li>특정 점을 기준으로 좌표들이 위치한 공간</li>
</ul>

<hr />

<h4 id="view-matrix">View Matrix</h4>
<ul>
  <li>월드 공간에 있는 객체를 보기 위해선 카메라 관점으로 바라봐야한다.</li>
  <li>그러기 위해 카메라 위치를 기준으로 객체들 좌표를 맞춰줘야한다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 뷰 변환 행렬
</span>  <span class="n">cameraPosition</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">500</span><span class="p">]</span>
  <span class="n">viewMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">cameraPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">cameraPosition</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">cameraPosition</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="p">])</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<h3 id="view-space">View Space</h3>
<ul>
  <li>카메라 위치를 기준으로 객체들이 정렬된 공간
    <h4 id="projection-matrix">Projection Matrix</h4>
  </li>
  <li>공간상에 추상적으로 정의되어 있는 정점들을 직관적으로 2D 스크린상에 투영시켜야한다.</li>
  <li>후에 스크린 비율에 맞게 변환하는 작업도 필요해서 NDC도 해야한다.</li>
  <li>객체들을 평면에 투영해서 스크린에 표현 할 수 있는 2D 좌표로 만든다.</li>
</ul>

<div class="callout-info-expanded">
<div class="callout-header">원근투영, 직교투영</div>
<p>
진행전 어떤 투영을 할지 결정해야한다. 아래는 원근투영 기준이다.
</p>
</div>

<hr />

<h4 id="ndc-normalized-device-coordinate">NDC (Normalized device coordinate)</h4>
<ul>
  <li>Projection후 정규화하는 작업</li>
  <li>Why?
    <ul>
      <li>후에 View port 변환시 스크린 해상도에 맞게 화면을 늘리기 때문</li>
      <li>기기마다 해상도가 달라서 맞춰줘야 한다.</li>
      <li>카메라의 FOV와 해상도는 다르다.
        <ul>
          <li>FOV는 화면에 보이는 물체들의 범위를 늘리는 것</li>
          <li>약간 사람과 잠자리의 시야 범위 느낌</li>
          <li>해상도는 기기의 화면 넓이다.</li>
          <li>유튜브에서 사람의 사야랑 잠자리의 시야를 똑같은 해상도의 기기에서 볼 수 있는 것과 같다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># 투영 행렬 정의
</span>    <span class="c1"># fov를 구하는 이유
</span>    <span class="c1"># 1. 투영 평면과 카메라 사이거리 d, 2. 투영 평면의 높이
</span>    <span class="n">fov</span> <span class="o">=</span> <span class="mi">90</span>
    <span class="n">near</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">far</span> <span class="o">=</span> <span class="mf">1000.0</span>

    <span class="c1"># 투영 행렬, 원근투영
</span>    <span class="c1"># 투영 평면과의 거리
</span>    <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">math</span><span class="p">.</span><span class="nf">tan</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">fov</span><span class="p">)</span><span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># 스크린 종횡비 k
</span>    <span class="n">reverseAspect</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">aspect</span>
    <span class="c1"># 카메라에서 near 까지의 거리 n
</span>    <span class="n">n</span> <span class="o">=</span> <span class="n">near</span>
    <span class="c1"># 카메라에서 far 까지의 거리 f
</span>    <span class="n">f</span> <span class="o">=</span> <span class="n">far</span>
    
    <span class="c1"># NDC까지 적용한 원근투영 행렬
</span>    <span class="c1"># NDC는 스크린의 종횡비를 변화하려는 축의 값만 변경하면 된다 d/-p1z(p1x/k, p1y)
</span>    <span class="c1"># 그러나 이걸 최종 투영 + NDC를 적용한 최종행렬에 적용하려면 행렬식 내부에 -P1z가 들어가서
</span>    <span class="c1"># 매 행렬계산마다 행렬을 새로 만들어주어야 한다.
</span>    <span class="c1"># 이를 방지하기 위해 P1z를 3X3 행렬로 만들고 p1z를 연산벡터(정점 좌표값 벡터)에 넘겨준다.
</span>    <span class="c1"># 그후 나온 결과 행렬의 z값(-P1z)을 나눠주면 NDC구현 완료다.
</span>    <span class="n">projectionMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">d</span> <span class="o">*</span> <span class="n">reverseAspect</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span> <span class="n">f</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">f</span><span class="p">)],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">])</span>
</code></pre></div></div>

<h2 id="resterization-1">Resterization</h2>
<h3 id="clip-space">Clip Space</h3>
<ul>
  <li>뷰 공간에서 화면에 투영하기 위해 사용되는 공간</li>
  <li>좌표 값은 정규화되어 있어서 -1,1 범위이다.</li>
</ul>

<hr />

<h4 id="viewport-tansform">Viewport Tansform</h4>
<ul>
  <li>디스플레이에 2D 결과 화면을 가시화하는 단계</li>
  <li>depth buffer를 통해 보일 객체를 선택한다.</li>
</ul>

<h2 id="전체-코드">전체 코드</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pygame</span>
<span class="kn">import</span> <span class="n">math</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># 화면 설정
</span><span class="n">screenWidth</span> <span class="o">=</span> <span class="mi">1280</span>
<span class="n">screenHeight</span> <span class="o">=</span> <span class="mi">720</span>
<span class="n">aspect</span> <span class="o">=</span> <span class="n">screenWidth</span> <span class="o">/</span> <span class="n">screenHeight</span>
<span class="n">halfWidth</span> <span class="o">=</span> <span class="n">screenWidth</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">halfHeight</span> <span class="o">=</span> <span class="n">screenHeight</span> <span class="o">/</span> <span class="mi">2</span>

<span class="c1"># 정육면체 설정
</span><span class="n">rectWidth</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">rectHeight</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># 함수 정의
</span><span class="k">def</span> <span class="nf">TransMatrix</span><span class="p">(</span><span class="n">matrixs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">matrixs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">halfWidth</span> <span class="o">+</span> <span class="n">halfWidth</span><span class="p">,</span> <span class="o">-</span><span class="n">matrixs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">halfHeight</span> <span class="o">+</span> <span class="n">halfHeight</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">DrawLine</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
    <span class="n">pygame</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="nf">line</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">DrawCube</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="nc">DrawLine</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="p">)</span>

<span class="c1"># Pygame 초기화
</span><span class="n">pygame</span><span class="p">.</span><span class="nf">init</span><span class="p">()</span>
<span class="n">BACKGROUND_COLOR</span> <span class="o">=</span> <span class="p">(</span><span class="mi">245</span><span class="p">,</span> <span class="mi">245</span><span class="p">,</span> <span class="mi">245</span><span class="p">)</span>
<span class="n">LINE_COLOR</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="p">.</span><span class="n">display</span><span class="p">.</span><span class="nf">set_mode</span><span class="p">((</span><span class="n">screenWidth</span><span class="p">,</span> <span class="n">screenHeight</span><span class="p">))</span>
<span class="n">pygame</span><span class="p">.</span><span class="n">display</span><span class="p">.</span><span class="nf">set_caption</span><span class="p">(</span><span class="sh">"</span><span class="s">Graphics Programming</span><span class="sh">"</span><span class="p">)</span>
<span class="n">running</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">while</span> <span class="n">running</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="p">.</span><span class="n">event</span><span class="p">.</span><span class="nf">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="p">.</span><span class="n">QUIT</span><span class="p">:</span>
            <span class="n">running</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">screen</span><span class="p">.</span><span class="nf">fill</span><span class="p">(</span><span class="n">BACKGROUND_COLOR</span><span class="p">)</span>

    <span class="c1"># 정육면체 정점 및 간선 정의
</span>    <span class="n">cubeVertices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="o">-</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">rectHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">rectHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rectHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rectHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">rectHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">rectHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rectHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rectHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">rectWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="n">cubeEdges</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># 변환 행렬 정의
</span>    
    <span class="c1">## 회전 행렬
</span>    <span class="c1">### yaw
</span>    <span class="n">rotateX</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rxMathSin</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateX</span><span class="p">))</span>
    <span class="n">rxMathCos</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateX</span><span class="p">))</span>
    <span class="n">rightRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
    <span class="p">[</span><span class="n">rxMathCos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rxMathSin</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="n">rxMathSin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rxMathCos</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="c1">### pitch
</span>    <span class="n">rotateY</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ryMathSin</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateY</span><span class="p">))</span>
    <span class="n">ryMathCos</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateY</span><span class="p">))</span>
    <span class="n">upRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ryMathCos</span><span class="p">,</span> <span class="o">-</span><span class="n">ryMathSin</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ryMathSin</span><span class="p">,</span> <span class="n">ryMathCos</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="c1">### roll
</span>    <span class="n">rotateZ</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rzMathSin</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateZ</span><span class="p">))</span>
    <span class="n">rzMathCos</span> <span class="o">=</span> <span class="n">math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">rotateZ</span><span class="p">))</span>
    <span class="n">forwardRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
    <span class="p">[</span><span class="n">rzMathCos</span><span class="p">,</span> <span class="o">-</span><span class="n">rzMathSin</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="n">rzMathSin</span><span class="p">,</span> <span class="n">rzMathCos</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>
    
    <span class="c1">### Yaw Pitch Roll 순으로 계산한다.
</span>    <span class="n">eulerRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">upRotationMatrix</span><span class="p">,</span> <span class="n">rightRotationMatrix</span><span class="p">)</span>
    <span class="n">eulerRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">forwardRotationMatrix</span><span class="p">,</span> <span class="n">eulerRotationMatrix</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">eulerRotationMatrix</span>
    <span class="c1">### 4차원으로 변환
</span>    <span class="n">eulerRotationMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">])</span>
    

    <span class="c1">## 크기 행렬
</span>    <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">scaleMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>
    <span class="c1">## 이동 행렬
</span>    <span class="n">moveX</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">moveY</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">moveZ</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">moveMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">moveX</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">moveY</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">moveZ</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>
    <span class="n">srMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">scaleMatrix</span><span class="p">,</span> <span class="n">eulerRotationMatrix</span><span class="p">)</span>
    <span class="n">srmMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">moveMatrix</span><span class="p">,</span> <span class="n">srMatrix</span><span class="p">)</span>

    <span class="c1"># 뷰 변환 행렬 정의
</span>    <span class="n">cameraPosition</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">500</span><span class="p">]</span>
    <span class="n">viewMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">cameraPosition</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">cameraPosition</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">cameraPosition</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="n">srmvMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span> <span class="n">srmMatrix</span><span class="p">)</span>

    <span class="c1"># Clip 변환
</span>    <span class="c1"># 뷰 공간에서 화면에 투영하기 위해 사용되는 공간
</span>    <span class="c1"># 카메라 기준으로 정렬된 좌표 값들을 화면상에 보여주기 위해서 -1,1 범위에 정규화해서
</span>    <span class="c1"># 모든 해상도에 대해서 대비를 하게되는 공간
</span>    <span class="c1"># 주로 해상도 비율 맞추는 일을 한다.
</span>    <span class="c1"># Clip 변환에는 두가지 연산이 들어간다.
</span>    <span class="c1"># 하나는 Projection, 다른 하나는 NDC
</span>    <span class="c1"># Projection에선 좌표값들을 평면상에 나타내게 만들고
</span>    <span class="c1"># NDC는 화면 해상도 비율에 따라 어긋난 좌표 값들을 동일하게 맞춰주는 작업이다.
</span>
    <span class="c1"># 투영 행렬 정의
</span>    <span class="c1"># fov를 구하는 이유
</span>    <span class="c1"># 1. 투영 평면과 카메라 사이거리 d, 2. 투영 평면의 높이
</span>    <span class="n">fov</span> <span class="o">=</span> <span class="mi">90</span>
    <span class="n">near</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">far</span> <span class="o">=</span> <span class="mf">1000.0</span>
    
    <span class="c1"># GPT의 답변
</span>    <span class="c1"># 뭔가 많이 다르다
</span>    <span class="c1"># 인터넷에서 뭔갈 긁어온것 같은데 별로인 것 같다.
</span>    <span class="c1"># top = near * math.tan(math.radians(fov) / 2)
</span>    <span class="c1"># bottom = -top
</span>    <span class="c1"># right = top * aspect
</span>    <span class="c1"># left = -right
</span>    <span class="c1"># projectionMatrix = np.array([
</span>    <span class="c1">#     [(2 * near) / (right - left), 0, 0, 0],
</span>    <span class="c1">#     [0, (2 * near) / (top - bottom), 0, 0],
</span>    <span class="c1">#     [(right + left) / (right - left), (top + bottom) / (top - bottom), -(far + near) / (far - near), -1],
</span>    <span class="c1">#     [0, 0, -(2 * far * near) / (far - near), 0]
</span>    <span class="c1"># ])
</span>    
    <span class="c1"># 내가 쓴 것
</span>    <span class="c1"># 투영 행렬, 원근투영
</span>    <span class="c1"># 투영 평면과의 거리
</span>    <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">math</span><span class="p">.</span><span class="nf">tan</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">radians</span><span class="p">(</span><span class="n">fov</span><span class="p">)</span><span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># 스크린 종횡비 k
</span>    <span class="n">reverseAspect</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">aspect</span>
    <span class="c1"># 카메라에서 near 까지의 거리 n
</span>    <span class="n">n</span> <span class="o">=</span> <span class="n">near</span>
    <span class="c1"># 카메라에서 far 까지의 거리 f
</span>    <span class="n">f</span> <span class="o">=</span> <span class="n">far</span>

    <span class="c1"># NDC까지 적용한 원근투영 행렬
</span>    <span class="c1"># NDC는 스크린의 종횡비를 변화하려는 축의 값만 변경하면 된다 d/-p1z(p1x/k, p1y)
</span>    <span class="c1"># 그러나 이걸 최종 투영 + NDC를 적용한 최종행렬에 적용하려면 행렬식 내부에 -P1z가 들어가서
</span>    <span class="c1"># 매 행렬계산마다 행렬을 새로 만들어주어야 한다.
</span>    <span class="c1"># 이를 방지하기 위해 P1z를 3X3 행렬로 만들고 p1z를 연산벡터(정점 좌표값 벡터)에 넘겨준다.
</span>    <span class="c1"># 그후 나온 결과 행렬의 z값(-P1z)을 나눠주면 NDC구현 완료다.
</span>    <span class="n">projectionMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">d</span> <span class="o">*</span> <span class="n">reverseAspect</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span> <span class="n">f</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">f</span><span class="p">)],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="c1"># 투영 후 NDC를 적용하는 건줄 알았는데 사실 투영, NDC 모두 한번에 하고 있던 것이였다....
</span>    <span class="c1"># NDC는 마지막 결과 행렬의 Z값을 행렬에 나누는 걸로 완성하는 것
</span>    <span class="c1"># ndcMatrix = np.array([
</span>    <span class="c1">#     [d * reverseAspect, 0, 0, 0],
</span>    <span class="c1">#     [0, d, 0, 0],
</span>    <span class="c1">#     [0, 0, -1, 0],
</span>    <span class="c1">#     [0, 0, -0, -1]
</span>    <span class="c1"># ])
</span>
    <span class="c1"># View port 변환
</span>    <span class="c1"># 최종적으로 디스플레이에 2D 결과화면을 나타내는 단계
</span>    <span class="c1"># depth를 통해 보일 객체를 선별한다.
</span>    <span class="c1"># View Space == 카메라 기준 공간
</span>    <span class="c1"># View port 변환 == Depth를 통한 클리핑 작업
</span>    <span class="n">viewportX</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">viewportY</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">viewportMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">screenWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">screenWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">viewportX</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">screenHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">screenHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">viewportY</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>
    
    <span class="c1"># 정육면체 변환 및 투영
</span>    <span class="n">result_screen_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">cubeVertices</span><span class="p">:</span>
        <span class="c1"># 로컬 &gt; 월드 &gt; 뷰 까지 적용하기
</span>        <span class="n">transViewMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">srmvMatrix</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
        <span class="c1"># 투영NDC 행렬 적용하여 ClipSpace 만들기
</span>        <span class="n">transProjectionMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">projectionMatrix</span><span class="p">,</span> <span class="n">transViewMatrix</span><span class="p">)</span>
        <span class="c1"># NDC 적용하여 ClipSpace 완성하기
</span>        <span class="n">transProjectionMatrix</span> <span class="o">=</span> <span class="n">transProjectionMatrix</span> <span class="o">/</span> <span class="n">transProjectionMatrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">tpViewportMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">viewportMatrix</span><span class="p">,</span> <span class="n">transProjectionMatrix</span><span class="p">);</span>

        <span class="c1"># 원래는 각 행렬요소에 스크린 길이 만큼 더해야했다.
</span>        <span class="c1"># 하지만 뷰포트 행렬을 적용해서 더는 할 필요 없어졌다
</span>        <span class="n">screen_point</span> <span class="o">=</span> <span class="n">tpViewportMatrix</span><span class="p">[:</span><span class="mi">2</span><span class="p">];</span>
        <span class="c1"># screen_point = TransMatrix(tpViewportMatrix)
</span>        <span class="n">result_screen_points</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">screen_point</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># 정육면체 그리기
</span>    <span class="nc">DrawCube</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="n">result_screen_points</span><span class="p">,</span> <span class="n">cubeEdges</span><span class="p">,</span> <span class="n">LINE_COLOR</span><span class="p">)</span>
    <span class="n">pygame</span><span class="p">.</span><span class="n">display</span><span class="p">.</span><span class="nf">update</span><span class="p">()</span>

<span class="n">pygame</span><span class="p">.</span><span class="nf">quit</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/1cec5498-c610-486e-b3ab-f7ae476c6927" alt="202113110_전진성" /></p>

<h1 id="재질과-텍스처">재질과 텍스처</h1>
<h2 id="재질">재질</h2>
<blockquote>
  <p>객체 표면의 속성을 정의해 주는 요소</p>
</blockquote>

<ul>
  <li>색상 (Color)</li>
  <li>투명도(Transparency)</li>
  <li>텍스처(Texture)</li>
  <li>표면 속성들
    <ul>
      <li>Specular</li>
      <li>Roughness</li>
      <li>Metalness</li>
    </ul>
  </li>
</ul>

<h2 id="텍스처">텍스처</h2>
<blockquote>
  <p>2D 이미지로써 객체 표면의 색상을 표현해주는 요소. Map이라고도 한다.</p>
</blockquote>

<ul>
  <li>Diffuse Texture : 가장 기본이 되는 텍스처.</li>
  <li>Specular Texture : 빛의 반사에 대한 처리를 위한 덱스처</li>
  <li>Normal Texture : 입체감, 질감 표현 텍스처</li>
</ul>

<h3 id="텍스처-맵핑">텍스처 맵핑</h3>
<ul>
  <li>2D 텍스처를 폴리곤에 입히는 과정</li>
  <li>폴리곤의 위치와 텍스처의 위치를 지정 필요하다.</li>
  <li>3D 모델의 정점에 2D텍스처의 위치를 UV값을 통해 지정</li>
</ul>

<h2 id="텍스처-로딩">텍스처 로딩</h2>
<ul>
  <li>Texture는 일반적으로 좌상단이 0,0으로 색상 정보가 저장되어 있다.</li>
  <li>UV는 보통 좌하단<br />
![[UV and Texture.excalidraw|300]]
    <h3 id="uv좌표-계산하기">UV좌표 계산하기</h3>
    <h4 id="무게중심좌표계">무게중심좌표계</h4>
  </li>
  <li>삼각형안 x,y 지점 바탕으로 uv 값을 계산해야한다.
    <ul>
      <li>삼각형의 좌표값 가중치 정의 : A1 + A2 + A3 = 1</li>
      <li>해당 꼭짓점이 특정 점 P에 얼마나 기여한지 나타낸다.</li>
      <li>저 A들을 람다라고한다.</li>
    </ul>
  </li>
  <li>점, 특정 지점 식
    <ul>
      <li>P1 = A1 X V1 + A2 X V2 + A3 X V3</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="정리">정리</h3>
<ul>
  <li>이미지 파일 가져오기
    <ul>
      <li>텍스처의 원점은 좌상단</li>
    </ul>
  </li>
  <li>삼각형 위치에 맞는 UV값 가져오기
    <ul>
      <li>무게 중심 좌표계 이용</li>
      <li>FinalUV = (1- λ1 –λ2)𝐕𝟏𝒖𝒗 + λ𝟏𝑽𝟐𝒖𝒗 + λ𝟐𝑽𝟑𝒖𝒗</li>
    </ul>
  </li>
  <li>텍스처 맵핑하기
    <ul>
      <li>UV와 텍스처 사이즈의 규격 맞추기
        <ul>
          <li>UV좌표 값 * 텍스처 좌표값</li>
          <li>V는 위아래를 바꿔줘야 하기에 1-(V X 텍스처Y)로 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://colory-games.net/site/en/ue5-debug_packaged_project-en/">https://colory-games.net/site/en/ue5-debug_packaged_project-en/</a>
<a href="https://velog.io/@liha_engineer/ue4start-4">https://velog.io/@liha_engineer/ue4start-4</a>
<a href="https://mingyu0403.tistory.com/298">https://mingyu0403.tistory.com/298</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="computergraphics" /><category term="UE5" /><category term="Unreal Engine5" /><category term="Unreal Engine" /><category term="Debug" /><category term="Package" /><summary type="html"><![CDATA[렌더링 파이프라인 3차원 모델을 2차원 화면에 투영하는 렌더링 과정을 말한다.]]></summary></entry></feed>