<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-17T21:42:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mohitto55 Note</title><subtitle>모히또의 노트</subtitle><author><name>Mohitto55</name></author><entry><title type="html">[Docker] Docker Image 개념과 구조</title><link href="http://localhost:4000/network/Docker-Image-%EC%A0%95%EB%A6%AC/" rel="alternate" type="text/html" title="[Docker] Docker Image 개념과 구조" /><published>2024-08-17T00:00:00+09:00</published><updated>2024-08-17T00:00:00+09:00</updated><id>http://localhost:4000/network/Docker%20Image%20%EC%A0%95%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/network/Docker-Image-%EC%A0%95%EB%A6%AC/"><![CDATA[<h2 id="docker-이미지">Docker 이미지</h2>
<p>컨테이너를 만드는데 사용되는 Template이라 생각하면 된다.
컨테이너는 이미지를 기반으로 생성된다.</p>

<p><br />
이미지는 <code class="language-plaintext highlighter-rouge">Docker hub</code>에서 다운받아서 사용하는 방식으로 도커 계정을 가진 사람들끼리 이미지를 공유할 수 있다.</p>

<hr />

<h3 id="이미지-구조와-레이어">이미지 구조와 레이어</h3>
<p><img src="https://github.com/user-attachments/assets/4f99fce3-c1c1-4b4d-8077-65c5f3f53d2b" alt="image" /></p>

<p><br />
이미지는 용량이 매우 큰데 기본 몇백MB다. 이미지를 업데이트하면 그 큰 용량을 매번 전부 다운 받는것은 비효율적이다. 그래서 Layer 구조를 통해 관리를 한다.</p>

<p><br />
이미지는 기본적으로 <strong>읽기전용(Read-Only)</strong>의 레이어 여러개로 구성되어있다. 이 레이어들은 파일이 추가되거나 수정되면 새로운 레이어를 만든다. 즉 기존 Base레이어는 변경되지않고 새로운 Layer가 추가하면된다.</p>

<p><br />
위 그림처럼 기본 Base Image를 이용해 만드는 새로운 Image는 Layer를 수정하지 않고 새 Layer를 생성한다. 이렇게하면 web app 이미지를 업데이트 할 때 web app layer만 수정하면된다.</p>

<p><br />
맨 우측 그림을 보면 Docker Container에서 web app을 베이스로 이미지 생성을 하는데 해당 이미지 레이어들은 모두 <strong>읽기전용(Read-Only)</strong>으로 생성된다.</p>

<p><br />
컨테이너가 생성될 때마다 Container Layer가 생성되는데 해당 레이어는 <strong>읽기쓰기</strong> 모두 가능하지만 Container가 삭제되면 Container Layer도 삭제된다.</p>

<p><img src="https://github.com/user-attachments/assets/4440ce1c-1063-4b1a-956a-d9d5b2f7b859" alt="image" /></p>

<h2><br /></h2>
<p><br /></p>
<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4">https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4</a>
<a href="https://creboring.net/blog/how-docker-divide-image-layer/">https://creboring.net/blog/how-docker-divide-image-layer/</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="network" /><category term="Docker" /><category term="Ubuntu" /><category term="Linux" /><category term="컨테이너" /><category term="Image" /><category term="Layer" /><summary type="html"><![CDATA[Docker 이미지 컨테이너를 만드는데 사용되는 Template이라 생각하면 된다. 컨테이너는 이미지를 기반으로 생성된다.]]></summary></entry><entry><title type="html">[Docker] Ubuntu에서 Docker로 Mysql설치하기</title><link href="http://localhost:4000/network/Docker%EC%97%90-mysql-%EC%84%A4%EC%B9%98/" rel="alternate" type="text/html" title="[Docker] Ubuntu에서 Docker로 Mysql설치하기" /><published>2024-08-17T00:00:00+09:00</published><updated>2024-08-17T00:00:00+09:00</updated><id>http://localhost:4000/network/Docker%EC%97%90%20mysql%20%EC%84%A4%EC%B9%98</id><content type="html" xml:base="http://localhost:4000/network/Docker%EC%97%90-mysql-%EC%84%A4%EC%B9%98/"><![CDATA[<h2 id="docker-설치">Docker 설치</h2>
<blockquote>
  <p>Docker 다운받기</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo wget -qO- http://get.docker.com/ | sh
</code></pre></div>  </div>
</blockquote>

<p><br /></p>

<blockquote>
  <p>Docker 버전 확인</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -v
</code></pre></div>  </div>
  <p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/5c72a46d-5327-48a0-bfbe-c5e80a298495" alt="image" /></p>
</blockquote>

<h2 id="mysql-설치">Mysql 설치</h2>
<p><br /></p>
<blockquote>
  <p>Docker 이미지 다운</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker pull mysql
</code></pre></div>  </div>
</blockquote>

<blockquote>
  <p>다운받아진 이미지 확인</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker images
</code></pre></div>  </div>
  <p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/64449571/2bd321ec-4107-480c-ab6f-6987f1401fd8" alt="image" /></p>
</blockquote>

<p><br /></p>

<blockquote>
  <p>컨테이너를 실행하기</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --name mysql-container -e MYSQL_ROOT_PASSWORD=&lt;password&gt; -d -p 3306:3306 mysql:latest
</code></pre></div>  </div>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">--name &lt;container_name&gt;</code> : <code class="language-plaintext highlighter-rouge">&lt;container_name&gt;</code> 이름의 컨테이너를 실행한다.<br />
<code class="language-plaintext highlighter-rouge">-e</code> : 컨테이너 내에서 사용할 환경변수를 설정<br />
<code class="language-plaintext highlighter-rouge">-e MYSQL_ROOT_PASSWORD=&lt;password&gt;</code> : MySQL의 root 권한의 비밀번호를 <code class="language-plaintext highlighter-rouge">&lt;password&gt;</code>로 설정한다.<br />
<code class="language-plaintext highlighter-rouge">-d</code> : detach 모드로 컨테이너가 실행된다. 컨테이너가 백그라운드로 실행된다고 보면 된다.<br />
<code class="language-plaintext highlighter-rouge">-p &lt;호스트 포트&gt; &lt;컨테이너 포트&gt;</code> : 호스트와 컨테이너의 포트를 연결한다.<br />
mysql:latest : 컨테이너에 사용할 이미지<br /></p>

<hr />

<blockquote>
  <p>도커 목록 조회</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps -a
</code></pre></div>  </div>
  <p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/64449571/c333d5b9-6317-44e8-ae13-b4698f63f1be" alt="image" /></p>
</blockquote>

<p><br /><br /></p>

<h2 id="도커-이미지-런-오류">도커 이미지 런 오류</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unable to find image 'mysql-container:latest' locally
</code></pre></div></div>
<blockquote>
  <p>이미지 이름이 다르다.
콘테이너랑 이미지는 다른 개념이다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker: Error response from daemon: pull access denied for mysql-container, repository does not exist or may require 'docker login': denied: requested access to the resource is denied.
</code></pre></div></div>
<blockquote>
  <p>로그인을 잘못했거나 이미지에 태그 된 이름이랑 다르거나 둘 중 하나다.</p>
</blockquote>

<p><br /></p>

<h2 id="도커-컨테이너-접속시-오류">도커 컨테이너 접속시 오류</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Error response from daemon: container 1a0ab9fe9da2301b1d7959614ad2e8335ae745cf9b72a2b0394474236526557c is not running
</code></pre></div></div>
<p>콘테이너가 실행되지 않아 발생하는 오류다.<br />
아래 명령어를 통해 원하는 컨테이너를 실행하면 된다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker container start mysql-container
</code></pre></div></div>

<blockquote>
  <p>도커 컨테이너 접속하기</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo docker exec -it mysql-container bash
</code></pre></div>  </div>
</blockquote>

<blockquote>
  <p>루트권한에 접근하기</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql -u root -p
</code></pre></div></div>
<p><br />
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/64449571/7d89434e-6c5a-44e6-b812-7794738c5831" alt="image" /></p>

<h2><br /></h2>
<p><br /></p>
<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://hipopatamus.tistory.com/109">https://hipopatamus.tistory.com/109</a>
<a href="https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90">https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="network" /><category term="Docket" /><category term="Ubuntu" /><category term="Linux" /><category term="컨테이너" /><summary type="html"><![CDATA[Docker 설치 Docker 다운받기 sudo wget -qO- http://get.docker.com/ | sh]]></summary></entry><entry><title type="html">[Docker] Docker와 VM의 차이점</title><link href="http://localhost:4000/network/Docker%EC%99%80-VM-%EC%B0%A8%EC%9D%B4/" rel="alternate" type="text/html" title="[Docker] Docker와 VM의 차이점" /><published>2024-08-16T00:00:00+09:00</published><updated>2024-08-16T00:00:00+09:00</updated><id>http://localhost:4000/network/Docker%EC%99%80%20VM%20%EC%B0%A8%EC%9D%B4</id><content type="html" xml:base="http://localhost:4000/network/Docker%EC%99%80-VM-%EC%B0%A8%EC%9D%B4/"><![CDATA[<h2 id="docker">Docker</h2>
<p>Docker란 컨테이너를 이용한 오픈소스 가상화 플랫폼이다. 
컨테이너는 OS레벨의 가상화로 프로세스를 격리시켜 동작하는 것을 말한다. OS자체를 가상화 하던 방식과는 다른데 무슨 차이가 있는것일까?</p>

<h2 id="vm-가상화-vs-docker-가상화">VM 가상화 vs Docker 가상화</h2>
<h3 id="vm">VM</h3>
<ul>
  <li>기존에는 하나의 서버에 하나의 어플리케이션만 구동시켰다.
    <ul>
      <li>이는 남는 자원이 많아진다.</li>
      <li>이를 극복하기 위해 나온것이 가상화다</li>
    </ul>
  </li>
  <li>하이퍼바이저 기반의 가상화가 많이 이용됐다.
    <ul>
      <li>논리적으로 분리된 공간에서 VM이라는 독립된 가상환경 만든다.</li>
      <li>그리고 호스트 시스템에서 VM에 게스트 OS를 구동 및 모니터링 한다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/def35409-b1d9-4484-9a43-c6abd80140ab" alt="image" /><em>VM 구조</em></p>

<h3 id="docker-1">Docker</h3>
<ul>
  <li>Docker은 Guest OS가 필요없다.
    <ul>
      <li>Host OS의 커널을 공유하기 때문이다.</li>
    </ul>
  </li>
  <li>가상화를 할 때마다 OS를 할당해주면 자원 낭비가 된다.</li>
  <li>그래서 Container라는 개념으로 필요한 기능을 모듈화 시켜뗏다 붙여다 하는 식으로 운영이 가능하다.</li>
  <li>Docker의 컨테이너들은 리눅스 OS를 이용한다.
    <ul>
      <li>Host OS가 윈도우나 맥이면 어떻게 하는 것인가?</li>
      <li>WSL 같은 리눅스환경 VM을 사용한다.</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/user-attachments/assets/15360da2-1cef-4a8d-b2c0-8041522094db" alt="image" />
<br /></p>
<div class="callout-info-expanded">
<div class="callout-header">차이점 요약</div>
<p>
1. VM은 하이퍼 바이저 기능을 이용해 Guest OS를 할당한다.<br />
2. Docker은 Host OS의 커널을 공유해 사용한다<br />
3. VM은 새 환경을 구성할 때 마다 새로운 OS를 다운받아야하지만 Docker은 컨테이너를 늘릴 때마다 OS를 다운할 필요없어 자원 효율성이 더 좋다.
</p>
</div>

<h2 id="사용하는-이유">사용하는 이유</h2>
<h3 id="개발환경-구성">개발환경 구성</h3>
<p>개발하고 서버에 올리면 끝인 상황이다. 그런데 서버에 올리면 작동 하지 않는 경우가 있다.왜 그런가 알아보니 컴퓨터 윈도우, 서버는 리눅스라는 각각 다른 OS를 사용하여 발생하는 오류였다. 각 OS마다 호환되는 기능이 다르기에 발생하는 문제였다.
<br /><br />
하지만 도커를 사용하면 다른 머신에서도 같은 환경 구성이 가능하다.
방법은 간단하다 윈도우, 서버에 둘다 Docker 설치하고 구성하고 싶은 환경 설정하면 된다.
<br /><br /></p>

<p>도커는 파일을 읽고 필요한걸 다운 받고 같은 환경을 컨테이너에 구성한다.
그래서 컴퓨터에서 서버로 코드 업로드하면(Docker와 같이) 잘 작동 한다.
<br /><br /></p>

<p>또 각 컨테이너는 각기 분리되어 있다.컨테이너들은 독립적이다. 이덕에 한개의 서버에서 수많은 컨테이너 가질 수 있다. 만약 자바 애플리케이션이 인기 많으면 자바 컨테이너 늘리고 사용자가 줄면 컨테이너를 줄임으로써 매번 서버를 사고 팔 이유가 없어진다.</p>

<p><br /></p>
<div class="callout-info-expanded">
<div class="callout-header">사용하는 이유 요약</div>
<p>
1. 원하는 개발 환경을 파일에 저장하면 어떤 머신에든 해당 환경 구성해준다.<br />
2. 각 환경을 독립적이기 때문에 무슨 환경이든 모듈식 관리 가능하다.
</p>
</div>

<h2><br /></h2>
<p><br /></p>
<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90">https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90</a>
<a href="https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4">https://velog.io/@kdaeyeop/%EB%8F%84%EC%BB%A4-Docker-%EC%99%80-VM%EC%9D%98-%EC%B0%A8%EC%9D%B4</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="network" /><category term="Docker" /><category term="Ubuntu" /><category term="Linux" /><category term="컨테이너" /><category term="VM" /><category term="가상환경" /><category term="가상머신" /><category term="도커" /><category term="하이퍼바이저" /><category term="HyperVisor" /><category term="Virtual Machine" /><summary type="html"><![CDATA[Docker Docker란 컨테이너를 이용한 오픈소스 가상화 플랫폼이다. 컨테이너는 OS레벨의 가상화로 프로세스를 격리시켜 동작하는 것을 말한다. OS자체를 가상화 하던 방식과는 다른데 무슨 차이가 있는것일까?]]></summary></entry><entry><title type="html">[Window] 구글캘린더 바탕화면에 위젯 생성하기</title><link href="http://localhost:4000/os/%EA%B5%AC%EA%B8%80%EC%BA%98%EB%A6%B0%EB%8D%94-%EC%95%84%EC%9B%83%EB%A3%A9-%EC%97%B0%EB%8F%99-%EB%B0%94%ED%83%95%ED%99%94%EB%A9%B4/" rel="alternate" type="text/html" title="[Window] 구글캘린더 바탕화면에 위젯 생성하기" /><published>2024-08-05T00:00:00+09:00</published><updated>2024-08-05T00:00:00+09:00</updated><id>http://localhost:4000/os/%EA%B5%AC%EA%B8%80%EC%BA%98%EB%A6%B0%EB%8D%94%20%EC%95%84%EC%9B%83%EB%A3%A9%20%EC%97%B0%EB%8F%99%20%EB%B0%94%ED%83%95%ED%99%94%EB%A9%B4</id><content type="html" xml:base="http://localhost:4000/os/%EA%B5%AC%EA%B8%80%EC%BA%98%EB%A6%B0%EB%8D%94-%EC%95%84%EC%9B%83%EB%A3%A9-%EC%97%B0%EB%8F%99-%EB%B0%94%ED%83%95%ED%99%94%EB%A9%B4/"><![CDATA[<h2 id="들어가며">들어가며</h2>
<p>나는 <strong>Todoist, Google Calendar, Obsidian</strong>을 통해 일정관리를 한다.
나는 일정관리에서 제일 중요하다 생각하는 부분이 언제 어디서든 최소한의 액션으로 간편하게 일정을 확인할 수 있어야 한다고 생각한다.
그래서 휴대폰에는 바탕화면에 구글 캘린더 위젯을 생성하고 옵시디언에서 <strong>Full Calendar 플러그인</strong>을 통해 구글 캘린더를 확인할 수 있다.</p>

<p><br /></p>

<p>다만 윈도우의 경우에는 구글캘린더를 바탕화면 위젯으로 생성가능한 기능을 제공하지 않는다. 물론 클릭 몇번이면 브라우저에서 구글 캘린더로 가는건 어렵지 않은 일이지만 일정을 의식적으로 생각해서 확인하는 일은 귀찮은 일이라 바탕화면에서 달력을 확인할 수 있는 방법을 여러가지 모색했다.</p>

<p><br /></p>

<p>그중 달력 위젯 중 가장 유명한 <a href="https://desktop-calendar.softonic.kr/">Desktop Calendar</a>을 사용해보기도 했지만 이것은 구글캘린더와 연동이 되지 않아 금방 삭제했다. 어떻게 해야 구글캘린더를 바탕화면에 표시할까 알아보다 아웃룩과 연동하고 외부 프로그램을 이용하면 가능한 것을 알게되었다. 해당 방법을 아래에 소개하겠다.</p>

<h2 id="1-구글캘린더-주소-복사하기">1. 구글캘린더 주소 복사하기</h2>
<p>구글캘린더에서 우측 상단 톱니바퀴 모양을 눌러 <strong>설정</strong>에 들어가고 왼쪽 탭에서 아웃룩과 연동할 캘린더를 선택해 설정에 들어간다.
아래로 내려서 <strong>Scret address in iCal format</strong> 내용을 우측 복사하기 버튼을 눌러서 클립보드에 복사한다.
<img src="https://github.com/user-attachments/assets/167750ad-2261-47a8-83b0-64c032a5841b" alt="image" /></p>

<h2 id="2-아웃룩과-캘린더-연동">2. 아웃룩과 캘린더 연동</h2>
<p>아웃룩에 들어가 <code class="language-plaintext highlighter-rouge">파일 &gt; 계정 설정 &gt; 인터넷 일정 &gt; 새로만들기</code> 를 누른다.
<img src="https://github.com/user-attachments/assets/9db6166c-05e8-4cc0-8386-fd8413c0260f" alt="image" />
<img src="https://github.com/user-attachments/assets/1dd2aac0-6806-4d7a-a263-a410d6f074c6" alt="image" /></p>

<p><br /></p>

<p>그리고 1에서 복사한 구글캘린더 주소로 일정 등록을 한다.
<img src="https://github.com/user-attachments/assets/72a156f6-3796-4454-b5c9-3d5efe544aa1" alt="image" /></p>

<hr />

<h3 id="연동성공">연동성공</h3>

<p><img src="https://github.com/user-attachments/assets/c2fcdf82-f946-4d14-87e5-37a5ce708b80" alt="image" /></p>

<h2 id="3-ootd-설치하기">3. OOTD 설치하기</h2>
<p>아웃룩을 바탕화면에서 보려면 외부 프로그램을 설치해야한다.</p>

<p><a href="https://outlookonthedesktop.com/release-notes">링크</a>에 들어가서 OOTD앱을 다운 받는다. 실행하면 아래와 같이 바탕화면에 아웃룩 위젯이 생성된다.
<img src="https://github.com/user-attachments/assets/b3d83c1f-374c-4680-8a09-39624d1a96a2" alt="image" /></p>

<p><br /></p>

<p>우측 하단에서 Ootd를 우클릭하고 Select Folder을 누른다.</p>

<p>그리고 인터넷 일정에서 위젯에 보일 일정을 설정하면 바탕화면에서도 일정을 확인할 수 있다.
<img src="https://github.com/user-attachments/assets/ab1a6c4c-0bb1-4ed7-960b-c0043ce75647" alt="image" /></p>

<p><img src="https://github.com/user-attachments/assets/7e429fb1-c180-497f-b345-ef8bf87cff4e" alt="image" /></p>

<hr />

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://mainia.tistory.com/1830">https://mainia.tistory.com/1830</a>
<a href="https://luckylucy.tistory.com/103">https://luckylucy.tistory.com/103</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="os" /><category term="Window" /><category term="Google Calendar" /><category term="Outlook" /><category term="Widget" /><category term="Calendar" /><category term="윈도우" /><category term="구글캘린더" /><category term="아웃룩" /><summary type="html"><![CDATA[들어가며 나는 Todoist, Google Calendar, Obsidian을 통해 일정관리를 한다. 나는 일정관리에서 제일 중요하다 생각하는 부분이 언제 어디서든 최소한의 액션으로 간편하게 일정을 확인할 수 있어야 한다고 생각한다. 그래서 휴대폰에는 바탕화면에 구글 캘린더 위젯을 생성하고 옵시디언에서 Full Calendar 플러그인을 통해 구글 캘린더를 확인할 수 있다.]]></summary></entry><entry><title type="html">[CS] 컴퓨터에서 문자를 표현하는 방법</title><link href="http://localhost:4000/computerscience/%EB%AC%B8%EC%9E%90%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C/" rel="alternate" type="text/html" title="[CS] 컴퓨터에서 문자를 표현하는 방법" /><published>2024-07-23T00:00:00+09:00</published><updated>2024-07-23T00:00:00+09:00</updated><id>http://localhost:4000/computerscience/%EB%AC%B8%EC%9E%90%EB%A5%BC%20%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94%20%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC%20%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C</id><content type="html" xml:base="http://localhost:4000/computerscience/%EB%AC%B8%EC%9E%90%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%EC%9D%B8%EC%BD%94%EB%94%A9%EA%B3%BC-%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C/"><![CDATA[<h2 id="문자-집합과-인코딩">문자 집합과 인코딩</h2>
<ul>
  <li><strong>문자집합</strong>
    <ul>
      <li>컴퓨터가 인식할 수 있는 문자의 모음이다.</li>
    </ul>
  </li>
  <li>인코딩
    <ul>
      <li>문자를 0과 1로 변환해 컴퓨터가 이해할 수 있는 정보로 변환하는 과정이다.</li>
    </ul>
  </li>
  <li>디코딩
    <ul>
      <li>0과1을 사람이 이해하는 문자로 변환하는 과정이다.
        <h2 id="아스키-코드">아스키 코드</h2>
      </li>
    </ul>
  </li>
  <li>초창기 문자집합이다.</li>
  <li>7비트로 표현할 수 있는 문자는 총 128개이다.</li>
  <li>표현 가능한 수가 적기 때문에 한글을 표현할 수 없다.</li>
  <li>확장 아스키도 나왔지만 그래도 256개로 요전히 적다.
    <h2 id="ecu-kr">ECU-KR</h2>
  </li>
  <li>한글 인코딩은 두 종류가 있다.</li>
  <li><strong>완성형</strong>과 <strong>조립협</strong>인코딩이 있다.
    <ul>
      <li>완성형은 하나의 글자에 고유한 코드를 부여하고</li>
      <li>조립형은 초성, 중성, 종성에 해당하는 코드를 부여하고 조립하는 형태다.</li>
    </ul>
  </li>
  <li>ECU-KR은 KS X 1001, KS X 1003 이라는 문자 집합 기반으로 하는 <strong>완성형</strong>인코딩 방식이다.</li>
  <li>한글은 각 글자에 2바이트가 부여되어 16비트가 필요하다.</li>
</ul>

<h3 id="한글깨짐-문제">한글깨짐 문제</h3>
<ul>
  <li>2350개로 표현할 수 있지만 그럼에도 모든 한글 조합을 표현할 수 없다.</li>
  <li>그래서 쀍 같은 글자는 깨진다.</li>
  <li>이런 문제를 해결하기 위해 Microsoft의 CP949라는 EUC-KR 확장판이 나왔다.</li>
  <li>다만 이것도 다 표현할 수 없다.</li>
</ul>

<h2 id="인코딩의-문제점">인코딩의 문제점</h2>
<ul>
  <li>ECU-KR처럼 모든 언어별로 인코딩을 해야한다면 프로그램에서 나라별 인코딩언어를 모두 알아내야 한다.</li>
  <li>하지만 통일된 표준 인코딩 방식이 있다면 번거로움이 없을것이다.</li>
</ul>

<h2 id="유니코드와-utf-8">유니코드와 UTF-8</h2>
<ul>
  <li><strong>유니코드</strong>는 대부분의 나라의 문자, 특수문자, 이모티콘도 표현가능한 문자집합이다.</li>
</ul>

<h3 id="인코딩-방식">인코딩 방식</h3>
<ul>
  <li>아스키나 EUC-KR은 글자에 부여된 값으로 인코딩을 한다.</li>
  <li>유니코드는 부여된 값을 활용해 여러 방법으로 인코딩 한다.</li>
  <li>이 방법들 중 UTF-8, UTF-16, UTF-32등이 있다.</li>
</ul>

<h3 id="utf-8">UTF-8</h3>
<ul>
  <li>1바이트부터 4바이트까지의 인코딩 결과를 만든다.</li>
  <li>즉 값이 1바이트가 될 수 도 있고 2, 3, 4 바이트 중 될 수 있다는 것이다.</li>
  <li>이는 유니코드 문자에 부여된 값에 따라 결정된다.</li>
</ul>]]></content><author><name>Mohitto55</name></author><category term="computerscience" /><category term="인코딩" /><category term="디코딩" /><category term="유니코드" /><category term="아스키코드" /><category term="Unicode" /><category term="ASCII" /><category term="Encode" /><category term="Decode" /><category term="ECU-KR" /><category term="UTF-8" /><category term="UTF-16" /><category term="UTF-32" /><summary type="html"><![CDATA[문자 집합과 인코딩 문자집합 컴퓨터가 인식할 수 있는 문자의 모음이다. 인코딩 문자를 0과 1로 변환해 컴퓨터가 이해할 수 있는 정보로 변환하는 과정이다. 디코딩 0과1을 사람이 이해하는 문자로 변환하는 과정이다. 아스키 코드 초창기 문자집합이다. 7비트로 표현할 수 있는 문자는 총 128개이다. 표현 가능한 수가 적기 때문에 한글을 표현할 수 없다. 확장 아스키도 나왔지만 그래도 256개로 요전히 적다. ECU-KR 한글 인코딩은 두 종류가 있다. 완성형과 조립협인코딩이 있다. 완성형은 하나의 글자에 고유한 코드를 부여하고 조립형은 초성, 중성, 종성에 해당하는 코드를 부여하고 조립하는 형태다. ECU-KR은 KS X 1001, KS X 1003 이라는 문자 집합 기반으로 하는 완성형인코딩 방식이다. 한글은 각 글자에 2바이트가 부여되어 16비트가 필요하다.]]></summary></entry><entry><title type="html">[UE5] Loading PreDefault Modules for Plugin 오류 해결하기</title><link href="http://localhost:4000/ue5/UE5-Modules-for-Plugin-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/" rel="alternate" type="text/html" title="[UE5] Loading PreDefault Modules for Plugin 오류 해결하기" /><published>2024-06-25T00:00:00+09:00</published><updated>2024-06-25T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20Modules%20for%20Plugin%20%EC%98%A4%EB%A5%98%20%ED%95%B4%EA%B2%B0</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-Modules-for-Plugin-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/"><![CDATA[<h2 id="에러-현상">에러 현상</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/cdba9f11-665f-4a29-a248-84da8582661d" alt="image" />
사용하던 5.3프로젝트를 5.4로 변경하고 Motion Matching을 연습 중이였는데 빌드하고 재시작하니 위와 같이 75%에서 계속 멈추고 진행이 되지 않았다.</p>

<p><br /></p>
<h2 id="해결-과정">해결 과정</h2>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Warning</span>      <span class="n">LogAnimation</span>              <span class="n">SkeletalMesh</span> <span class="n">SkeletalMesh</span> <span class="o">/</span><span class="n">Game</span><span class="o">/</span><span class="n">Characters</span><span class="o">/</span><span class="n">Mannequin_UE4</span><span class="o">/</span><span class="n">Meshes</span><span class="o">/</span><span class="n">SK_Mannequin</span><span class="p">.</span><span class="n">SK_Mannequin</span> <span class="n">has</span> <span class="n">no</span> <span class="n">skeleton</span><span class="p">.</span> <span class="n">This</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">fixed</span> <span class="n">before</span> <span class="n">an</span> <span class="n">animation</span> <span class="n">can</span> <span class="n">be</span> <span class="n">set</span>
<span class="n">Warning</span>      <span class="n">LogLinker</span>                 <span class="p">[</span><span class="n">AssetLog</span><span class="p">]</span> <span class="n">C</span><span class="o">:</span><span class="err">\</span><span class="n">Users</span><span class="err">\</span><span class="n">admin</span><span class="err">\</span><span class="n">git</span><span class="err">\</span><span class="n">UE5</span><span class="err">\</span><span class="n">Multi</span><span class="err">\</span><span class="n">Content</span><span class="err">\</span><span class="n">MCO_Mocap_Basics</span><span class="err">\</span><span class="n">Character</span><span class="err">\</span><span class="n">Mesh</span><span class="err">\</span><span class="n">UE4_Mannequin_Skeleton</span><span class="p">.</span><span class="n">uasset</span><span class="o">:</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">load</span> <span class="err">'</span><span class="o">/</span><span class="n">Engine</span><span class="o">/</span><span class="n">EngineMeshes</span><span class="o">/</span><span class="n">Humanoid</span><span class="err">'</span><span class="o">:</span> <span class="n">Can</span><span class="err">'</span><span class="n">t</span> <span class="n">find</span> <span class="n">file</span><span class="p">.</span>
<span class="n">Warning</span>      <span class="n">LogLinker</span>                 <span class="p">[</span><span class="n">AssetLog</span><span class="p">]</span> <span class="n">C</span><span class="o">:</span><span class="err">\</span><span class="n">Users</span><span class="err">\</span><span class="n">admin</span><span class="err">\</span><span class="n">git</span><span class="err">\</span><span class="n">UE5</span><span class="err">\</span><span class="n">Multi</span><span class="err">\</span><span class="n">Content</span><span class="err">\</span><span class="n">MCO_Mocap_Basics</span><span class="err">\</span><span class="n">Character</span><span class="err">\</span><span class="n">Mesh</span><span class="err">\</span><span class="n">UE4_Mannequin_Skeleton</span><span class="p">.</span><span class="n">uasset</span><span class="o">:</span> <span class="n">VerifyImport</span><span class="o">:</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">load</span> <span class="n">package</span> <span class="k">for</span> <span class="n">import</span> <span class="n">object</span> <span class="err">'</span><span class="n">Package</span> <span class="o">/</span><span class="n">Engine</span><span class="o">/</span><span class="n">EngineMeshes</span><span class="o">/</span><span class="n">Humanoid</span><span class="err">'</span>
<span class="n">Warning</span>      <span class="n">LogAnimation</span>              <span class="n">SkeletalMesh</span> <span class="n">SkeletalMesh</span> <span class="o">/</span><span class="n">Game</span><span class="o">/</span><span class="n">Characters</span><span class="o">/</span><span class="n">Mannequin_UE4</span><span class="o">/</span><span class="n">Meshes</span><span class="o">/</span><span class="n">SK_Mannequin</span><span class="p">.</span><span class="n">SK_Mannequin</span> <span class="n">has</span> <span class="n">no</span> <span class="n">skeleton</span><span class="p">.</span> <span class="n">This</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">fixed</span> <span class="n">before</span> <span class="n">an</span> <span class="n">animation</span> <span class="n">can</span> <span class="n">be</span> <span class="n">set</span>
</code></pre></div></div>
<p>라이더에서 warning로그를 보니 캐릭터 메쉬쪽 오류로 보였다.
모션매칭을 하느라 애니메이션, Animation Blueprint등을 이것저것 만졌는데 그게 오류가 발생한 것으로 생각되어 수정한 에셋들을 하나씩 꺼내보며 확인했다.</p>

<p><br /></p>
<h2 id="발생-원인-및-해결">발생 원인 및 해결</h2>
<ul>
  <li>ABP가 깨져서 생긴 미싱 문제때문에 빌드가 멈춘 것이였다.</li>
  <li>삭제하고 새로운 ABP를 만드니 제대로 작동된다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/ed7901e8-c95e-408e-a1d6-49db1e766d87" alt="image" /></li>
</ul>

<hr />

<div class="Reference">
<div class="callout-header"> </div>
<p>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="Unreal Engine5" /><category term="Unreal Engine" /><category term="Plugin" /><category term="Error" /><category term="Motion Matching" /><summary type="html"><![CDATA[에러 현상 사용하던 5.3프로젝트를 5.4로 변경하고 Motion Matching을 연습 중이였는데 빌드하고 재시작하니 위와 같이 75%에서 계속 멈추고 진행이 되지 않았다.]]></summary></entry><entry><title type="html">[UE5] 패키지된 게임 디버그 하는 법</title><link href="http://localhost:4000/ue5/UE5-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%94%94%EB%B2%84%EA%B7%B8/" rel="alternate" type="text/html" title="[UE5] 패키지된 게임 디버그 하는 법" /><published>2024-06-21T00:00:00+09:00</published><updated>2024-06-21T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20%ED%8C%A8%ED%82%A4%EC%A7%80%20%EB%94%94%EB%B2%84%EA%B7%B8</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%94%94%EB%B2%84%EA%B7%B8/"><![CDATA[<h1 id="개요">개요</h1>
<p>네트워크 기능이 있는 게임을 만들었는데 PIE상에서는 괜찮았는데 패키지를 하니 버그가 발생했다.
이게 네트워크에서 발생한 것인지 아니면 내부 구조 로직에서 충돌이 일어난 것인지 알길이 없어서 디버그를 해야만 했다.<br /> 언리얼 디버그에 관한 지식이 전무 했었기 때문에 이 기회에 패키지된 게임을 디버그하는 방법을 공부하여 정리하는 시간을 가져보았다.</p>

<hr />

<h1 id="사전-준비">사전 준비</h1>
<h2 id="디버깅을-위한-편집기-심볼">디버깅을 위한 편집기 심볼</h2>
<ul>
  <li>엔진에서 디버깅에 필요한 심볼 기호들이 저장되어있다.</li>
  <li>엔진 레벨에서 어떻게 동작하는지 알고 싶다면 체크해야 한다.</li>
  <li>용량이 30기가 이상으로 굉장히 크다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/cbec9f66-8e47-4727-81d8-db08c793fbc9" alt="image" /></li>
</ul>

<hr />

<h3 id="디버그-심볼">디버그 심볼</h3>
<p>디버그에 필요한 정보. 이 디버그 심볼이 들은걸 디버그 심볼 파일(프로그램 데이터베이스 파일, PDB) 이라고 한다.</p>
<ul>
  <li>디버그 심볼은 ‘정보’ 이기 때문에, 빌드 종류에 따라 달라지는 <strong>최적화 정도에 따라서 일부 혹은 전부가 ‘손실’</strong> 된다.</li>
  <li>왜냐하면 <strong>최적화 과정에서 컴파일러가 심볼을 삭제하기 때문이다.</strong></li>
  <li>그렇기에 디버그 모드로 패키지를 해야 자세한 디버그가 가능하다..</li>
</ul>

<h2 id="디버그-모드로-패키징-하기">디버그 모드로 패키징 하기</h2>
<ul>
  <li>디버깅을 자세하게 하고 싶으면 패키징 구성을 DebugGame으로 설정한다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/0922c39c-b084-4b2b-97a8-2e366f004a86" alt="image" /></li>
</ul>

<h1 id="디버그-방법들">디버그 방법들</h1>
<h2 id="1-텍스트-파일-로그-확인하기">1. 텍스트 파일 로그 확인하기</h2>
<ul>
  <li>Build&gt;Windows&gt;MultiShooter&gt;Saved&gt;Logs
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/4c09e66a-1257-43fb-9b0c-0eae6ab08548" alt="image" /></li>
</ul>

<h2 id="2-visual-studio-창에서-실시간-확인">2. Visual Studio 창에서 실시간 확인</h2>
<ul>
  <li>비쥬얼 스튜디오를 킨다.</li>
  <li>
    <p>디버그 탭 &gt; 프로세스에 연결 을 누른다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/36bdc818-5c14-469a-b7cc-bb6c2665d5b6" alt="image" /></p>
  </li>
  <li>패키징한 프로그램을 실행한다.</li>
  <li>창이 뜨면 현재 실행중인 프로세스들이 확인된다.</li>
  <li>
    <p>그중 패키킹 프로그램의 이름 + Debuggame.exe 파일을 선택한다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/9de0581a-1ca4-4283-acc5-074d2551c9e4" alt="image" /></p>
  </li>
  <li>그러면 실시간으로 로그가 보이는 것을 알 수 있다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/2dbb4c76-92c4-4efa-b04a-1753331b1ad3" alt="image" /></li>
</ul>

<h2 id="3-직접-로그창-열지-않고-에러창이-나오게-하기">3. 직접 로그창 열지 않고 에러창이 나오게 하기</h2>
<ul>
  <li>
    <p>Project Setting &gt; Packaging &gt; Project &gt; Build Configuration
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/0a0af894-e830-49d3-95d6-638f01c44331" alt="image" /></p>
  </li>
  <li>
    <p>직접 로그창을 열지 않아도 자동으로 크래쉬 로그가 뜬다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/8d7e477f-8425-424c-8dfe-0fa8a2087c27" alt="image|400" /></p>
  </li>
</ul>

<h2 id="4-덤프파일을-통해-상황-재현하기">4. 덤프파일을 통해 상황 재현하기</h2>
<ul>
  <li>언리얼 엔진에서 크래시가 나는 경우 minidump 파일을 Saved/Crashes 디렉터리에 스테이징한다.</li>
  <li>덤프파일을 이용하면 크래시가 난 시점의 메모리 상태로 디버깅을 진행할 수 있다.</li>
  <li>이 파일을 visual studio에 드래그하고 오른쪽 네이티브 전용(으)로 디버그 버튼을 누르면 디버깅을 진행할 수 있다.</li>
</ul>

<hr />

<h1 id="그-외">그 외</h1>
<p><br /></p>
<h3 id="소스코드로-디버그-관리하기">소스코드로 디버그 관리하기</h3>
<p>스택트레이스를 로그로 남길 수 있다.</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FDebug</span><span class="p">::</span><span class="nf">DumpStackTraceToLog</span><span class="p">(</span><span class="n">ELogVerbosity</span><span class="p">::</span><span class="n">Type</span><span class="p">::</span><span class="n">Error</span><span class="p">);</span>
</code></pre></div></div>

<p>현재 호출되는 스레드 ID를 알 수 있다.</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uint32</span> <span class="n">ThreadId</span> <span class="p">=</span> <span class="n">FPlatformTLS</span><span class="p">::</span><span class="nf">GetCurrentThreadId</span><span class="p">();</span> 
<span class="n">FString</span> <span class="n">ThreadName</span> <span class="p">=</span> <span class="n">FThreadManager</span><span class="p">::</span><span class="nf">Get</span><span class="p">().</span><span class="nf">GetThreadName</span><span class="p">(</span><span class="n">ThreadId</span><span class="p">);</span>
</code></pre></div></div>

<p>FullName과 Outer 객체를 활용하여 현재 오브젝트의 인스턴스를 확인할 수 있다.</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FString</span> <span class="n">FullName</span> <span class="p">=</span> <span class="nf">GetFullName</span><span class="p">();</span>
	<span class="n">FString</span> <span class="n">OuterFullName</span> <span class="p">=</span> <span class="nf">GetOuter</span><span class="p">()-&gt;</span><span class="nf">GetFullName</span><span class="p">();</span>
	<span class="n">FString</span> <span class="nf">FuncName</span><span class="p">(</span><span class="n">__FUNCTION__</span><span class="p">);</span>
	<span class="nf">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span> <span class="n">Error</span><span class="p">,</span> <span class="nf">TEXT</span><span class="p">(</span><span class="s">"%s  FullName : %s  OuterFullName : %s"</span><span class="p">),</span>
		<span class="p">*</span><span class="n">FuncName</span><span class="p">,</span> <span class="p">*</span><span class="n">FullName</span><span class="p">,</span> <span class="p">*</span><span class="n">OuterFullName</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<h3 id="debuggame-editor">DebugGame Editor</h3>
<p>Editor가 안 붙은 것을 선택하고 디버거를 돌리면 exe 파일이 만들어지는데, Editor가 붙은 것을 선택하고 디버거를 돌리면 dll 파일이 만들어진다.<br />
이것을 선택하면 언리얼 에디터를 켠 다음에 dll만 교체해서 컨텐츠를 엔진에 올리는 식으로 동작을 하기 때문에, 아까처럼 글로벌 셰이더가 없다는 식의 alert가 뜨지 않는다.</p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href="https://colory-games.net/site/en/ue5-debug_packaged_project-en/">https://colory-games.net/site/en/ue5-debug_packaged_project-en/</a>
<a href="https://velog.io/@liha_engineer/ue4start-4">https://velog.io/@liha_engineer/ue4start-4</a>
<a href="https://mingyu0403.tistory.com/298">https://mingyu0403.tistory.com/298</a>
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="Unreal Engine5" /><category term="Unreal Engine" /><category term="Debug" /><category term="Package" /><summary type="html"><![CDATA[개요 네트워크 기능이 있는 게임을 만들었는데 PIE상에서는 괜찮았는데 패키지를 하니 버그가 발생했다. 이게 네트워크에서 발생한 것인지 아니면 내부 구조 로직에서 충돌이 일어난 것인지 알길이 없어서 디버그를 해야만 했다. 언리얼 디버그에 관한 지식이 전무 했었기 때문에 이 기회에 패키지된 게임을 디버그하는 방법을 공부하여 정리하는 시간을 가져보았다.]]></summary></entry><entry><title type="html">[UE5] C++ 폴더 추가하는 법</title><link href="http://localhost:4000/ue5/UE5-C++-%ED%8F%B4%EB%8D%94-%EC%83%9D%EC%84%B1%EB%B2%95/" rel="alternate" type="text/html" title="[UE5] C++ 폴더 추가하는 법" /><published>2024-05-20T00:00:00+09:00</published><updated>2024-05-20T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20C++%20%ED%8F%B4%EB%8D%94%20%EC%83%9D%EC%84%B1%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-C++-%ED%8F%B4%EB%8D%94-%EC%83%9D%EC%84%B1%EB%B2%95/"><![CDATA[<h1 id="개요">개요</h1>
<p>언리얼엔진은 C++ Class 폴더가 존재한다. 이 폴더에서 프로젝트에 적용하는 모든 C++ 파일들이 들어가게 되는데 해당 폴더안에 폴더를 새로 생성하면 인식이 되지 않는 경우가 있다.</p>

<p>이를 해결하기 위해선 언리얼이 감지할 수 있게 범위를 지정해 주어야한다.</p>

<h2 id="폴더-감지-설정">폴더 감지 설정</h2>

<p>C++ 파일은 모두 All/C++Classes 폴더 아래에 생성된다.
언리얼엔진은 이 폴더안에 있는 C++ 파일은 감지하지만 안에 있는 폴더는 감지하지 못한다. 그래서 하위폴더도 감지할 수 있게 작업해 줘야한다.</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/26460e8d-af22-41d4-83a3-b6da36e10d42" alt="image" /></p>
<blockquote>
  <p>프로젝트이름.Build.cs 파일로 이동해서 아래 코드 사진과 같이 삽입하기
이는 이름에서 알 수 있듯이 언리얼 엔진의 Include 경로를 추가하는 코드다.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PublicIncludePaths</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"StudyExample"</span> <span class="p">});</span>
</code></pre></div></div>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/0e087686-7bf8-4c2b-84aa-bd4071416da0" alt="image" /><em>코드 삽입시 모습</em></p>

<div class="callout-info-expanded">
<div class="callout-header">Build.cs 파일이 뭔가요?</div>
<p>
언리얼에는 모듈이라는 개념이 있는데 이는 언리얼 엔진의 기본 구성요소다.
모듈을 여러개로 분리한 이유는 사용하지 않는 모듈도 컴파일 하면 빌드 시간이 오래 걸리에 분리한다. 

Build.cs 파일은 이러한 모듈을 관리하는 cs파일로 모듈뿐 아니라 컴파일에 이용 하는 여러 설정을 제어한다.
</p>
</div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="Unreal Engine5" /><category term="Unreal Engine" /><category term="C++" /><summary type="html"><![CDATA[개요 언리얼엔진은 C++ Class 폴더가 존재한다. 이 폴더에서 프로젝트에 적용하는 모든 C++ 파일들이 들어가게 되는데 해당 폴더안에 폴더를 새로 생성하면 인식이 되지 않는 경우가 있다.]]></summary></entry><entry><title type="html">[UE5] 트레이스 채널 사용법</title><link href="http://localhost:4000/ue5/UE5-%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8A%A4-%EC%B1%84%EB%84%90-%EC%82%AC%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="[UE5] 트레이스 채널 사용법" /><published>2024-05-20T00:00:00+09:00</published><updated>2024-05-20T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8A%A4%20%EC%B1%84%EB%84%90%20%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8A%A4-%EC%B1%84%EB%84%90-%EC%82%AC%EC%9A%A9%EB%B2%95/"><![CDATA[<h2 id="개요">개요</h2>
<ul>
  <li>트레이스 채널 생성 for 액션 판정 - ABAction</li>
  <li>캐릭터 캡슐용 프로필 : ABAction 트레이스 채널에 반응 타입은 Pawn이다.</li>
  <li>스켈레탈 메시용 프로필 - 주로 랙돌 구현</li>
  <li>트리거용 프로필 : 폰 캡슐에만 반응, 타입은 WorldStaticd</li>
</ul>

<hr />

<h3 id="트레이스-채널-추가">트레이스 채널 추가</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Project Setting &gt; Engine &gt; Collision &gt; New Trace Channel</code>
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/790c3cdb-0cc0-47c8-951b-2684e9ff83e0" alt="image" /></li>
</ul>

<hr />
<h3 id="프리셋-추가">프리셋 추가</h3>

<ul>
  <li>아래 쪽 New를 통해 새 프리셋을 제작가능하다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/4a377dfa-33c4-4d18-8413-a3b5894a3416" alt="image" /></li>
</ul>

<h3 id="트레이스-채널-확인법">트레이스 채널 확인법</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Config -&gt; DefaultEngine.ini</code> 에서 확인할 수 있다.</li>
</ul>

<h2 id="트레이싱-함수-선택">트레이싱 함수 선택</h2>
<h3 id="카테고리-1-처리방법">카테고리 1: 처리방법</h3>

<hr />

<h3 id="카테고리2-대상">카테고리2: 대상</h3>
<ul>
  <li>Test : 무언가 감지되었는지 테스트</li>
  <li>Single, AnyTest : 감지된 단일 물체 정보 반환</li>
  <li>Multi : 감지된 모든 물체 정보 배열로 봔혼</li>
</ul>

<hr />

<h3 id="카테고리3-처리설정">카테고리3: 처리설정</h3>
<ul>
  <li>ByChannel : 채널 이용한 감지</li>
  <li>ByObjectType : 물리 타입 감지</li>
  <li>ByProfile : 프로필 감지</li>
</ul>

<h2 id="공격-판정-구현">공격 판정 구현</h2>
<ul>
  <li>캐릭터 위치서 시선 방향 쪽 물체 감지</li>
  <li>작은 구체 제작, 시선 방향 으로 투사</li>
  <li>하나의 물체만 감지</li>
  <li>트레이스 감지</li>
</ul>

<h2 id="터렛-애셋-구하기">터렛 애셋 구하기</h2>
<p><a href="https://www.artstation.com/marketplace/p/8gMjY/capital-ship-turret">ArtStation - capital ship Turret | Game Assets</a></p>

<hr />

<h1 id="터렛-만들기">터렛 만들기</h1>
<ul>
  <li>플레이어가 일정 거리 안에 오면 플레이어 방향으로 회전하게 한다.</li>
  <li>플레이어가 거리안에 오면 일정시간마다 공격을 한다.</li>
  <li>터렛의 공격은 LineTrace로 판정하며 벽을 다 무시하고 오직 플레이어만 맞도록 한다.</li>
</ul>

<h2 id="공격-판정-구현-1">공격 판정 구현</h2>

<h3 id="트레이스-채널-추가-1">트레이스 채널 추가</h3>
<ul>
  <li>트레이스 : 레이캐스트, 스위프 같이 트레이스를 통한 판정여부를 확인할 때 해당 채널에 대해서만 충돌 검사하도록 지정하는 레이어</li>
  <li><code class="language-plaintext highlighter-rouge">Project Setting -&gt; Engine -&gt; Collision -&gt; New Trace Channel</code> 에서 채널을 추가한다.</li>
  <li>트레이스 이름은 Attack와 디폴트 반응으로 Ignore설정</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Default Response</th>
      <th><center>설명</center></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Block</td>
      <td>트레이스에 대해 모든 물체가 반응한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">Overlap</td>
      <td>충돌은 일어나지 않지만 트리거 반응을 감지한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">Ignore</td>
      <td>완전히 무시한다.</td>
    </tr>
  </tbody>
</table>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/4a93d8e7-9c7d-4583-93de-a421a3ca3455" alt="image" /></p>

<hr />

<h3 id="프로필-추가">프로필 추가</h3>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/9ceb5829-48e8-4536-bd61-55f9046cdf8f" alt="image" /></p>

<blockquote>
  <p>프로필 - 특정 ObjectType이 다른 트레이스, 오브젝트간 충돌판정 여부가 있는 데이터</p>
</blockquote>

<ul>
  <li>아래 쪽 Preset New를 통해 새 프로필 제작가능</li>
  <li>CollisionEnabled : <font color="dodgerred">Collision</font>을 처리하는 방법에
    <ul>
      <li>
        <font color="dodgerred">No Collision</font>
        <p>: 충돌 없음. 움직이는 오브젝트에서 최적의 퍼포먼스를 낸다.</p>
      </li>
      <li>
        <font color="dodgerred">Query Only</font>
        <p>: 두 물체의 충돌 영역이 서로 겹치는지 테스트하는 설정. 충돌 영역의 겹침을 감지하는 것을 오버랩(Overlap) 이라고 부르며, 충돌 영역이 겹치면 관련 컴포넌트에 <em>BeginOverlap</em> 이벤트가 발생한다. 지정한 영역에 물체가 충돌하는지 탐지하는 레이캐스트(Raycast) 나 스윕(Sweep) 기능도 Query 에 속한다.</p>
      </li>
      <li>
        <font color="dodgerred">Physics Only</font>
        <p>: Simulate (RigidBody, Constraint) 에만 충돌을 처리. 본 단위의 감지가 필요치는 않은 캐릭터의 2차 시뮬레이션에 좋습니다.</p>
      </li>
      <li>
        <font color="dodgerred">Collision Enabled</font>
        <p>: Query와 Simulate를 다 사용합니다.</p>
      </li>
    </ul>
  </li>
  <li>ObjectType : 해당 프로필을 사용하는 콜리전 채널 설정
    <ul>
      <li>
        <font color="dodgerred">WorldStatic</font>
        <p>: 이동하지 않는 액터.</p>
      </li>
      <li>
        <font color="dodgerred">WorldDynamic</font>
        <p> : 열리는 문과 같이 애니메이션 또는 Kinematic 같은 코드의 영향을 받아 움직이는 액터 유형.</p>
      </li>
      <li>
        <font color="dodgerred">Pawn</font>
        <p>: 플레이어 캐릭터같은 Pawn 유형.</p>
      </li>
      <li>
        <font color="dodgerred">PhysicsBody</font>
        <p>: Physics Simulation으로 인해 움직이게 되는 캐릭터.</p>
      </li>
      <li>
        <font color="dodgerred">Vehicle</font>
        <p>: Vehicle 유형.</p>
      </li>
      <li>
        <font color="dodgerred">Destructible</font>
        <p>: 부술 수 있는 어떠한 오브젝트.</p>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h4 id="attack-트레이스-감지용-프리셋-설정">Attack 트레이스 감지용 프리셋 설정</h4>
<ul>
  <li>Name : UECapsule</li>
  <li>CollisionEnabled : Query Only</li>
  <li>ObjectType : Pawn</li>
</ul>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/9b48a11c-f0da-4f85-8b47-c3f8f685bcab" alt="Pasted image 20240421002830" /></p>

<hr />

<h3 id="트레이스-채널-확인법-1">트레이스 채널 확인법</h3>
<ul>
  <li>Config -&gt; DefaultEngine.ini 에서 확인</li>
  <li>트레이스 채널 이름으로 검색하면 DefaultChannelResponses 부분에 <code class="language-plaintext highlighter-rouge">ECC_GameTraceChannel1</code>와 같은 트레이스 채널이 적혀있다.</li>
</ul>

<div class="callout-warning-expanded">
<div class="callout-header">주의사항</div>
<p>
ECC트레이스 채널 이름 중 ECC_Engine과 같이 비슷한 이름들이 많다.
ECC_GameTraceChannel 유형의 채널들을 선택해야한다.
</p>
</div>

<hr />
<h3 id="캐릭터의-트레이스-프로파일-설정">캐릭터의 트레이스 프로파일 설정</h3>
<h4 id="에디터">에디터</h4>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/42a8a974-0448-4406-9f75-5149e86ac974" alt="image" /></p>

<h4 id="코드">코드</h4>

<blockquote>
  <p>프로필 이름을 통해 프로필을 설정해준다. 생성자에서 작성한다.
GetCapsuleComponent는 Character를 상속받는 폰에서만 사용 가능하다.
상속받지 않는다면 직접 Collision 컴포넌트를 생성해 설정해주어야 한다.</p>
</blockquote>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">GetCapsuleComponent</span><span class="p">()-&gt;</span><span class="nf">SetCollisionProfileName</span><span class="p">(</span><span class="nf">TEXT</span><span class="p">(</span><span class="s">"UECapsule"</span><span class="p">));</span>
</code></pre></div></div>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="Unreal Engine5" /><category term="Unreal Engine" /><category term="Trace Channel" /><summary type="html"><![CDATA[개요 트레이스 채널 생성 for 액션 판정 - ABAction 캐릭터 캡슐용 프로필 : ABAction 트레이스 채널에 반응 타입은 Pawn이다. 스켈레탈 메시용 프로필 - 주로 랙돌 구현 트리거용 프로필 : 폰 캡슐에만 반응, 타입은 WorldStaticd]]></summary></entry><entry><title type="html">[UE5] Unreal Insights 사용법</title><link href="http://localhost:4000/ue5/UE5-%EC%9D%B8%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%82%AC%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="[UE5] Unreal Insights 사용법" /><published>2024-05-20T00:00:00+09:00</published><updated>2024-05-20T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20%EC%9D%B8%EC%82%AC%EC%9D%B4%ED%8A%B8%20%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-%EC%9D%B8%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%82%AC%EC%9A%A9%EB%B2%95/"><![CDATA[<h2 id="프로파일링-profiling">프로파일링 (Profiling)</h2>
<ul>
  <li>프로그래밍에서의 프로파일링이란 소프트웨어의 성능 분석을 말한다.</li>
  <li>프로그램의 메모리, CPU 사용량, 여러 이벤트 발생률들을 통계적으로 요약하여 보여준다.</li>
  <li>프로파일링 툴을 이용하여 성능 취약점 부분을 찾아내어 보다 쉬운 최적화가 가능하다.</li>
</ul>

<h2 id="언리얼-인사이트">언리얼 인사이트</h2>
<ul>
  <li>언리얼의 프로파일링 툴이다.</li>
  <li>다양한 퍼포먼스 데이터를 체크할 수 있다.</li>
  <li>네트워크 통신 상태도 확인 가능하다.</li>
</ul>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/e9651a4e-a15b-4aa3-9d51-8d53c662a740" alt="image" /></p>

<h2 id="로컬-게임-설정법">로컬 게임 설정법</h2>
<h3 id="인사이트-실행하기">인사이트 실행하기</h3>
<ul>
  <li>언리얼 엔진 설치 폴더 확인
    <ul>
      <li>프로젝트 폴더가 아닌 <font color="dodgerred">프로그램 설치위치</font></li>
      <li><code class="language-plaintext highlighter-rouge">C:\Program Files\Epic Games\UE_5.3\Engine\Binaries\Win64\UnrealInsights.exe</code>
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/b2b71b52-4bf7-4383-8992-10772f62a3cd" alt="image" /></li>
    </ul>
  </li>
  <li>인사이트 프로그램의 숏컷 생성
    <ul>
      <li>Win64 폴더안에 <code class="language-plaintext highlighter-rouge">UnrealInsights.exe</code> 파일 찾기</li>
      <li>바로가기 만들거나 작업 표시줄 생성
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/385f22a8-04ec-4722-9231-fb4dc54e743f" alt="image" /></li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="환경-설정하기">환경 설정하기</h3>
<ul>
  <li>언리얼 에디터 실행 파일의 PATH 설정
    <ul>
      <li>설정 &gt; 시스템 &gt; 정보 &gt; 고급 시스템 설정 &gt; <font color="dodgerred">환경변수</font> &gt; admin 사용자 변수에서 <em>Path</em> 추가 혹은 편집으로 <code class="language-plaintext highlighter-rouge">C:\Program Files\Epic Games\UE_5.3\Engine\Binaries\Win64</code> 넣기</li>
    </ul>
  </li>
</ul>

<div class="callout-info-expanded">
<div class="callout-header">환경변수</div>
<p>
환경 변수(Environment Variable) 란 프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는, 동적인 값들의 모임이다.
환경변수 PATH는 실행시키려는 프로그램의 기본 경로를 말한다.
</p>
</div>

<hr />

<h3 id="인사이트-변수-설정">인사이트 변수 설정</h3>
<ul>
  <li>언리얼 에디터를 구동하기  위한 <font color="dodgerred">배치 파일</font> 제작
    <ul>
      <li>프로젝트 루트 폴더로 이동</li>
      <li>NetworkInsightsEditor.bat 생성</li>
      <li><code class="language-plaintext highlighter-rouge">UnrealEditor.exe %cd%\프로젝트.uproject 추가옵션</code> 작성</li>
      <li>배치 파일 실행</li>
      <li>경로 중에 뛰어쓰기가 있으면 안된다</li>
    </ul>
  </li>
</ul>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/89aab183-06c8-4bf0-bff2-5e81e43a07cb" alt="image" /><em>루트 폴더에 있는 bat 파일</em></p>

<ul>
  <li>-trace
    <ul>
      <li>활성화할 <font color="dodgerred">트레이스 채널</font>을 정하는 옵션이다.</li>
      <li>아래는 활성 가능한 트레이스 채널종류이다.</li>
      <li><code class="language-plaintext highlighter-rouge">Log,Bookmark,Frame,CPU,GPU,LoadTime,File,Net</code></li>
      <li>트레이스 시스템을 이용해 최소한의 오버헤드로 높은 빈도의 이벤트 처리가 가능하다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/74bdc30e-ea52-45aa-891f-2dbdf7494fae" alt="image" /></li>
    </ul>
  </li>
  <li>트레이스 명령 옵션에 대한 자세한 설명은 아래 링크에서 확인
    <ul>
      <li><a href="https://docs.unrealengine.com/4.27/ko/TestingAndOptimization/PerformanceAndProfiling/UnrealInsights/Reference/">Trace Document</a></li>
    </ul>
  </li>
</ul>

<h2 id="트레이스-기록-확인-호스트-설정">트레이스 기록 확인 호스트 설정</h2>
<ul>
  <li>이벤트 스트림은 소켓을 통해 호스팅되는 서버로 전송될 수 있다. (원격 프로파일링)</li>
  <li>굳이 원격호스팅이 아니고 로컬이여도 프로파일링을 기록하기 위해선 본인 기기의 IP를 적용해주어야 한다.</li>
</ul>

<h4 id="변수-설정단계에서-지정하기">변수 설정단계에서 지정하기</h4>
<ul>
  <li>로컬 호스트가 아닌 다른 컴퓨터에서 실행되는 경우 <code class="language-plaintext highlighter-rouge">-tracehost=주소</code> 를 통해 호스트 주소 지정이 가능하다</li>
</ul>

<hr />

<h4 id="gui에서-지정하기">GUI에서 지정하기</h4>
<ul>
  <li>Connection에 가서 호스트 IP 주소 입력후 Connect를 클릭한다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/9f6bae44-7032-446f-bfdb-4537019192a6" alt="image" /></li>
</ul>

<hr />

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/c35ce651-f6fd-4230-a23c-b756f584228e" alt="스크린샷 2024-03-23 212051" /><em>Recoder 목록</em></p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/ce1cdba3-f6bb-44ea-947a-a77eae1d85eb" alt="스크린샷 2024-03-23 212108" /><em>CPU Stream</em></p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/eaf72e9b-3b19-4cf4-b328-09929d0bb771" alt="스크린샷 2024-03-23 212513" /><em>Net Stream</em></p>]]></content><author><name>Mohitto55</name></author><category term="ue5" /><category term="UE5" /><category term="Unreal Engine5" /><category term="Unreal Engine" /><category term="Unreal Insights" /><summary type="html"><![CDATA[프로파일링 (Profiling) 프로그래밍에서의 프로파일링이란 소프트웨어의 성능 분석을 말한다. 프로그램의 메모리, CPU 사용량, 여러 이벤트 발생률들을 통계적으로 요약하여 보여준다. 프로파일링 툴을 이용하여 성능 취약점 부분을 찾아내어 보다 쉬운 최적화가 가능하다.]]></summary></entry></feed>