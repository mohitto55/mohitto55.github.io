<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-24T16:16:53+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Mohitto55 Note</title><subtitle>모히또의 노트</subtitle><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><entry><title type="html">[Git Blog] jekyll에서 emoji사용하기</title><link href="http://localhost:4000/gitblog/Jekyll-%EC%9D%B4%EB%AA%A8%EC%A7%80-%EC%A0%81%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="[Git Blog] jekyll에서 emoji사용하기" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-02-22T00:00:00+09:00</updated><id>http://localhost:4000/gitblog/Jekyll%20%EC%9D%B4%EB%AA%A8%EC%A7%80%20%EC%A0%81%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/gitblog/Jekyll-%EC%9D%B4%EB%AA%A8%EC%A7%80-%EC%A0%81%EC%9A%A9%EB%B2%95/"><![CDATA[<h2 id="emoji">Emoji?</h2>
<p>Jekyll 테마는 github의 <code class="language-plaintext highlighter-rouge">gemoji</code> 같이 <font color="red">::</font> 사이에 이름를 넣어 Emoji를 사용 할 수 있는 기능인 <code class="language-plaintext highlighter-rouge">jemoji</code>를 제공한다. 다만 기본적으로 제공하는 건 아니고 플러그인을 추가해줘야 한다.</p>

<h3 id="jemoji-적용">jemoji 적용</h3>
<p><code class="language-plaintext highlighter-rouge">Gemfile</code>에 jemoji를 추가한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem "jemoji"
</code></pre></div></div>
<p>그리고 <code class="language-plaintext highlighter-rouge">_config.yml</code>에도 jemoji 플러그인을 추가한다.</p>
<blockquote>
  <p>gem은 Ruby에서 지원하는 패키지 시스템이다.</p>
</blockquote>

<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugins:
	...
	- jemoji
</code></pre></div></div>

<p>그럼 <font color="red">::</font> 사이에 사용할 Emoji 이름을 넣어주면 된다. 예를 들어 white_check_mark를 넣으면 다음과 같이 나온다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/032a9bbf-5bac-480e-9582-ef77e53c0aef" alt="image" /></p>

<h2 id="커스텀-emoji-사용하기">커스텀 Emoji 사용하기</h2>
<p>Jekyll에서 제공하는 Emoji는 GitHub.com CDN에서 가져오는 것들이다. 그래서 마음에 들지 않는 Emoji가 있을 수 있는데 자신이 원하는 Emoji를 로컬저장소에서 불러오는 방식으로 커스터마이징 할 수 있다. <code class="language-plaintext highlighter-rouge">_config.yml</code>파일에 아래 소스를 추가한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>emoji:
  src: "/assets/images"
</code></pre></div></div>
<p>그리고 <code class="language-plaintext highlighter-rouge">/assets/images/emoji/unicode</code>위치로가서 <code class="language-plaintext highlighter-rouge">유니코드.png</code>의 이미지 파일을 놓아주면 된다. 그러면 방금처럼 <code class="language-plaintext highlighter-rouge">:white_check_mark:</code>를 써보면 <img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/032a9bbf-5bac-480e-9582-ef77e53c0aef" alt="image" />였던 것이 :white_check_mark: 로 바뀐 것을 볼 수 있다.</p>

<hr />
<h3 id="유니코드-확인법">유니코드 확인법</h3>
<p>유니코드는 이모지 유니코드 사이트에서 직접 찾거나</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle install
bundle exec jekyll serve
</code></pre></div></div>
<p>로컬서버를 돌린 뒤 에러메시지로 사용할려는 Emoji의 유니코드.png가 없다고 나오는 걸 보고 적용해주면 된다.</p>

<hr />
<h2 id="page_with_curl-reference">:page_with_curl: Reference</h2>
<blockquote>
  <p><a href="https://github.com/jekyll/jemoji?tab=readme-ov-file">jemoji</a></p>

  <p><a href="https://github.com/wooorm/gemoji">gemoji</a></p>
</blockquote>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="gitblog" /><category term="jekyll" /><category term="minimal-mistake" /><category term="emoji" /><category term="이모지" /><category term="jemoji" /><category term="gemoji" /><summary type="html"><![CDATA[Emoji? Jekyll 테마는 github의 gemoji 같이 :: 사이에 이름를 넣어 Emoji를 사용 할 수 있는 기능인 jemoji를 제공한다. 다만 기본적으로 제공하는 건 아니고 플러그인을 추가해줘야 한다.]]></summary></entry><entry><title type="html">SOLID 객체지향 5대원칙</title><link href="http://localhost:4000/c++/SOLID-%EC%9B%90%EC%B9%99/" rel="alternate" type="text/html" title="SOLID 객체지향 5대원칙" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-02-22T00:00:00+09:00</updated><id>http://localhost:4000/c++/SOLID%20%EC%9B%90%EC%B9%99</id><content type="html" xml:base="http://localhost:4000/c++/SOLID-%EC%9B%90%EC%B9%99/"><![CDATA[<h2 id="설명">설명</h2>
<p>OOP(객체지향언어)를 개발 하면서 지켜야 할 5가지 원칙을 말한다. 많은 Design Pattern이 SOLID 원칙을 토대로 만들어졌기에 이 원칙을 숙지하면 Design Pattern 및 구조 설계를 하기 수월해진다.</p>

<p>모든 코드에 반드시 적용할 필요는 없지만 좋은 설계를 위해선 해당 사항들을 의식하면서 작성하면 좋다.</p>

<hr />

<h3 id="장점">장점</h3>
<ul>
  <li>수정과 유지보수가 수월하다</li>
</ul>

<h3 id="단일-책임-원칙srp">단일 책임 원칙(<font color="dodgerred">S</font>RP)</h3>
<ul>
  <li>객체는 하나의 목적만 가지기</li>
  <li><strong>모듈이 변경되는 이유는 한가지여야함</strong></li>
  <li>모듈 다른 모듈에 대한 책임지면 안됨</li>
</ul>

<h3 id="개방-폐쇄-원칙ocp">개방 폐쇄 원칙(<font color="dodgerred">O</font>CP)</h3>
<ul>
  <li>모듈은 확장에 열려있고 수정엔 닫혀야함</li>
  <li>추상화에 의존해야함</li>
  <li><strong>인터페이스를 통해 과정이 어떻든 결과만 받기</strong></li>
  <li>Inject 같은 느낌</li>
  <li>과정이 어떻게 바뀌든 결과만 받으면 되니 확장이 용이하다</li>
</ul>

<h3 id="리스코프-치환-원칙lsp">리스코프 치환 원칙(<font color="dodgerred">L</font>SP)</h3>
<ul>
  <li>상위 클래스는 하위 클래스로 대체 될 수 있어야함</li>
  <li>직사각형을 부모로 둔 정사각형이 resize로 가로 세로를 다르게 설정 못함</li>
  <li>이럴 경우 resize못하게 막거나 [[C++ Overriding]]</li>
  <li><strong>항상 사용하는 클라이언트 기준으로 생각하기</strong></li>
</ul>

<h3 id="인터페이스-분리-원칙isp">인터페이스 분리 원칙(<font color="dodgerred">I</font>SP)</h3>
<ul>
  <li>클라이언트 용도에 맞는 인터페이스만 제공</li>
  <li><strong>하나의 Interface보단 구체적인 여러 Interface가 좋다</strong></li>
  <li>그러면 불필요한 간섭이 줄어든다</li>
  <li>다른 인터페이스에선 필요없는 정보를 안 알아도 되게 된다</li>
</ul>

<h3 id="의존-역전-원칙dip">의존 역전 원칙(<font color="dodgerred">D</font>IP)</h3>
<ul>
  <li>상위 모듈이 하위 모듈에 의존하면 안됨</li>
  <li>상위가 갑 하위가 을 까라면 까기</li>
  <li>상위-입출력과 먼 내부</li>
  <li>하위-입풀력과 가까운 겉부분</li>
  <li><strong>Interface, Virtual</strong>를 통해 모듈이 어떻든 값만 받기</li>
  <li>OCP와 연관깊다</li>
  <li>인터페이스는 적당히 만들기</li>
</ul>

<hr />

<h2 id="page_with_curl-reference">:page_with_curl: Reference</h2>
<blockquote>
  <p><a href="https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID">Inpa Dev - 객체 지향 설계의 5가지 원칙 - S.O.L.I.D</a></p>

  <p><a href="https://dev-cool.tistory.com/18">혼잣말하는 개발자 - 객체지향의 5대 원칙 SOLID</a></p>
</blockquote>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="c++" /><category term="SOLID" /><category term="OOP" /><category term="객체지향" /><category term="객체지향5대원칙" /><category term="디자인패턴" /><category term="Design Pattern" /><summary type="html"><![CDATA[설명 OOP(객체지향언어)를 개발 하면서 지켜야 할 5가지 원칙을 말한다. 많은 Design Pattern이 SOLID 원칙을 토대로 만들어졌기에 이 원칙을 숙지하면 Design Pattern 및 구조 설계를 하기 수월해진다.]]></summary></entry><entry><title type="html">[Git Blog] Jekyll 코드블럭 테마 설정하기</title><link href="http://localhost:4000/gitblog/Jekyll-%EC%BD%94%EB%93%9C%EB%B8%94%EB%9F%AD-%ED%85%8C%EB%A7%88-%EB%B0%94%EA%BE%B8%EA%B8%B0/" rel="alternate" type="text/html" title="[Git Blog] Jekyll 코드블럭 테마 설정하기" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-02-22T00:00:00+09:00</updated><id>http://localhost:4000/gitblog/Jekyll%20%EC%BD%94%EB%93%9C%EB%B8%94%EB%9F%AD%20%ED%85%8C%EB%A7%88%20%EB%B0%94%EA%BE%B8%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/gitblog/Jekyll-%EC%BD%94%EB%93%9C%EB%B8%94%EB%9F%AD-%ED%85%8C%EB%A7%88-%EB%B0%94%EA%BE%B8%EA%B8%B0/"><![CDATA[<h3 id="1-테마-설치하기">1. 테마 설치하기</h3>
<p>먼저 아래 코드블럭 테마 사이트에 가서 원하는 테마의 이름을 복사한다.
:point_right: <a href="https://spsarolkar.github.io/rouge-theme-preview/">테마 사이트</a></p>

<h3 id="2-rouge설치">2. rouge설치</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem install rouge
</code></pre></div></div>
<p>CMD에서 root폴더에 위와 같이 입력해서 테마를 설치한다.</p>

<h3 id="3-_configyml-수정">3. <code class="language-plaintext highlighter-rouge">_config.yml</code> 수정.</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Conversion
markdown: kramdown
highlighter: rouge

# Markdown Processing
kramdown:
  input: GFM
</code></pre></div></div>

<h3 id="4-css파일-다운받기">4. css파일 다운받기</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rougify style 테마이름 &gt; assets/css/syntax.css
</code></pre></div></div>
<p>원하는 테마의 syntax.css파일이 assets/css 경로에 생성된다.</p>

<h3 id="5-테마-적용하기">5. 테마 적용하기</h3>
<p>syntax.css 파일을 _scss 폴더에 놓거나 혹은 _syntax.scss 파일이 있을 경우 해당 파일에 덮어씌우기</p>

<h2 id="page_with_curl-reference">:page_with_curl: Reference</h2>
<blockquote>
  <p>https://onda2me.github.io/blog/codeblock/</p>
</blockquote>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="gitblog" /><category term="Git" /><category term="Blog" /><category term="Jekyll" /><category term="minimal-mistakes" /><category term="코드블럭" /><summary type="html"><![CDATA[1. 테마 설치하기 먼저 아래 코드블럭 테마 사이트에 가서 원하는 테마의 이름을 복사한다. :point_right: 테마 사이트]]></summary></entry><entry><title type="html">[Git Blog] Custom CSS 작성법</title><link href="http://localhost:4000/gitblog/Jekyll-%EC%BB%A4%EC%8A%A4%ED%85%80CSS-%EC%A0%81%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="[Git Blog] Custom CSS 작성법" /><published>2024-02-22T00:00:00+09:00</published><updated>2024-02-22T00:00:00+09:00</updated><id>http://localhost:4000/gitblog/Jekyll%20%EC%BB%A4%EC%8A%A4%ED%85%80CSS%20%EC%A0%81%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/gitblog/Jekyll-%EC%BB%A4%EC%8A%A4%ED%85%80CSS-%EC%A0%81%EC%9A%A9%EB%B2%95/"><![CDATA[<p>###</p>

<h2 id="page_with_curl-reference">:page_with_curl: Reference</h2>
<blockquote>
  <p>https://jekyllrb-ko.github.io/docs/step-by-step/07-assets/</p>
</blockquote>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="gitblog" /><category term="SOLID" /><category term="OOP" /><category term="객체지향" /><category term="객체지향5대원칙" /><category term="디자인패턴" /><category term="Design Pattern" /><summary type="html"><![CDATA[###]]></summary></entry><entry><title type="html">[UE5] Enhanced Input</title><link href="http://localhost:4000/ue5/UE5-Enhanced-Input/" rel="alternate" type="text/html" title="[UE5] Enhanced Input" /><published>2024-02-21T00:00:00+09:00</published><updated>2024-02-21T00:00:00+09:00</updated><id>http://localhost:4000/ue5/UE5%20Enhanced%20Input</id><content type="html" xml:base="http://localhost:4000/ue5/UE5-Enhanced-Input/"><![CDATA[<h2 id="enhancedinput">EnhancedInput?</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/a97835eb-26a9-4120-8bd5-e04c51590fd8" alt="image" />
EnhancedInput 시스템은 Unreal Engine5에 등장한 새로운 Input 시스템으로 기존 InputSystem 보다 더 나은 기능 및 확장성을 가졌다. 이 포스팅에서는 코드로 EngancedInput를 사용하는 법을 작성할 것이다.</p>

<h2 id="enhancedinput-모듈준비">EnhancedInput 모듈준비</h2>
<p>EnhancedInput은 코드로 작성할 수 있다. EnhancedInput 시스템을 사용하기 전에 먼저 모듈을 추가시켜줘야 한다.</p>

<h3 id="1모듈이란">1.모듈이란</h3>
<p>UEnhancedInputLocalPlayerSubSystem는 EnhancedInputSubsystems.h 헤더 안에 있다 이 헤더를 쓰기 위해선 모듈을 추가해줘야 한다.</p>

<h3 id="2모듈추가">2.모듈추가</h3>
<p>모듈은 플러그인을 빌드에 포함시키게 해주는 것으로 언리얼이 모든 플러그인이 아닌 필요한 플러그인만 빌드 시키게 함으로써 성능 향상 시켜준다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/4f373422-5831-4b69-8cd3-cef821f8f859" alt="스크린샷 2024-02-21 125554" /></p>

<p>플러그인은 <code class="language-plaintext highlighter-rouge">Engine/UE5/Plugins</code> 안에 있는 파일들에 볼 수 있으며 <code class="language-plaintext highlighter-rouge">프로젝트이름.Build.cs</code>파일에서 모듈을 관리할 수 있다.</p>

<h3 id="3빌드-및-임시파일-초기화">3.빌드 및 임시파일 초기화</h3>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/009474f9-35d1-42c5-b3df-e0fdcc9f2e49" alt="스크린샷 2024-02-21 130600" /></p>

<p>추가 후 CTRL+SHIFT+B로 빌드 해주면 헤더를 사용할 수 있다.
안되는 경우 컴파일시 생성되는 임시파일을 삭제해줘야 한다. 프로젝트 폴더에 가서 Binaries, Intermediate, Saved 폴더를 삭제한다.</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/b3854688-4d87-46c1-8ef0-8fb827ebf289" alt="스크린샷 2024-02-21 130747" /></p>

<p>그리고 프로젝트파일 우클릭 후 Generate Visual Studio project files를 눌러 삭제한 폴더들을 다시 만든다.</p>

<hr />

<h2 id="코드로-enhancedinput-작성">코드로 EnhancedInput 작성</h2>
<h3 id="1-1-mappingcontext">1-1. MappingContext</h3>
<p>코드로 사용하기 위해선 로컬플레이어 Input Subsystem인 <a href="https://docs.unrealengine.com/4.27/en-US/API/Plugins/EnhancedInput/UEnhancedInputLocalPlayerSubsyst-/">UEnhancedInputLocalPlayerSubSystem</a>이 필요하다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">UMyPlayer</span><span class="o">::</span><span class="n">BeginPlay</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">BeginPlay</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">APlayerController</span><span class="o">*</span> <span class="n">PlayerController</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">APlayerController</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GetController</span><span class="p">()))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">UEnhancedInputLocalPlayerSubsystem</span><span class="o">*</span> <span class="n">Subsystem</span> <span class="o">=</span> <span class="n">ULocalPlayer</span><span class="o">::</span><span class="n">GetSubsystem</span><span class="o">&lt;</span> <span class="n">UEnhancedInputLocalPlayerSubsystem</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PlayerController</span><span class="o">-&gt;</span><span class="n">GetLocalPlayer</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">Subsystem</span><span class="o">-&gt;</span><span class="n">AddMappingContext</span><span class="p">(</span><span class="s">"MAPPING CONTEXT VARIABLE"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<hr />
<h3 id="1-2-component에서-사용할-시">1-2. Component에서 사용할 시</h3>
<p><code class="language-plaintext highlighter-rouge">GetControll</code>메타함수는 <code class="language-plaintext highlighter-rouge">Pawn</code> 이하 클래스에서만 사용 할 수 있다. Component는 컨트롤러를 가지고 있지 않기 때문에 Pawn의 컨트롤러를 가져와야한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">AController</span><span class="o">*</span> <span class="n">UGrabber</span><span class="o">::</span><span class="n">GetOwnerController</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
	<span class="n">AActor</span><span class="o">*</span> <span class="n">Owner</span> <span class="o">=</span> <span class="n">GetOwner</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">Owner</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">APawn</span><span class="o">*</span> <span class="n">PawnOwner</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">APawn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Owner</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PawnOwner</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">PawnOwner</span><span class="o">-&gt;</span><span class="n">GetController</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>다만 게임설계상 컴포넌트에서 직접 하는 것 보단 컴포넌트를 관리하는 Actor에서 Input을 관리하는 것이 더 좋다.</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/80ee01ac-c280-40ee-9989-3b32e152886b" alt="스크린샷 2024-02-21 170725" />
위 과정을 BP로 할 경우 이렇다.</p>

<hr />

<h3 id="2-inputaction-사용">2. InputAction 사용</h3>
<p>이제 <code class="language-plaintext highlighter-rouge">MappingContext</code>를 시스템에 적용했으니 키를 누르면 InputAction 입력 값이 나올 것이다.
InputAction의 값을 쓰고 싶으면 <a href="https://docs.unrealengine.com/4.26/en-US/API/Plugins/EnhancedInput/FInputActionValue/">FInputActionValue</a>타입 변수를 써야한다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"InputActionValue.h"</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">Grab</span><span class="p">(</span><span class="k">const</span> <span class="n">FInputActionValue</span><span class="o">&amp;</span> <span class="n">Value</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<h3 id="3-바인딩-추가">3. 바인딩 추가</h3>
<p>키가 입력 됬을 때 특정 함수를 실행 시키고 싶다면 <a href="https://docs.unrealengine.com/4.27/en-US/API/Plugins/EnhancedInput/UEnhancedInputComponent/">EnhancedInputComponent</a>를 사용하면 된다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"EnhancedInputComponent.h"</span><span class="cp">
#include</span> <span class="cpf">"Components/InputComponent.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="n">UMyPlayer</span><span class="o">::</span><span class="n">SetupPlayerInputComponent</span><span class="p">(</span><span class="k">class</span> <span class="nc">UInputComponent</span><span class="o">*</span> <span class="n">PlayerInputComponent</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UEnhancedInputComponent</span><span class="o">*</span> <span class="n">EnhancedInputComponent</span> <span class="o">=</span> <span class="n">CastChecked</span><span class="o">&lt;</span><span class="n">UEnhancedInputComponent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">PlayerInputComponent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">EnhancedInputComponent</span><span class="o">-&gt;</span><span class="n">BindAction</span><span class="p">(</span><span class="n">GrabAction</span><span class="p">,</span><span class="n">ETriggerEvent</span><span class="o">::</span><span class="n">Started</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">UGrabber</span><span class="o">::</span><span class="n">Grab</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>PlayerController에 의해 호출되는  <a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Engine/GameFramework/APawn/SetupPlayerInputComponent/">APawn::SetupPlayerInputComponent</a>함수에서 InputComponent를 EnhancedInputComponent로 캐스팅 후 키 입력시 발생할 함수를 바인딩 해준다.</p>

<p>만약 CastChecked가 실패할 경우 게임이 크래시되어 종료한다.</p>

<h2 id="page_with_curl-reference">:page_with_curl: Reference</h2>
<blockquote>
  <p><a href="https://www.youtube.com/watch?v=fW1pXOAIviw">UE5 C++ Enhanced Input-2 Bind C++ Functions to Input Actions</a></p>

  <p><a href="https://docs.unrealengine.com/5.0/ko/enhanced-input-in-unreal-engine/">UE5 - EnhancedInput 공식문서</a></p>
</blockquote>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="ue5" /><category term="UnrealEngine5" /><category term="Actor" /><category term="Component" /><category term="C++" /><summary type="html"><![CDATA[EnhancedInput? EnhancedInput 시스템은 Unreal Engine5에 등장한 새로운 Input 시스템으로 기존 InputSystem 보다 더 나은 기능 및 확장성을 가졌다. 이 포스팅에서는 코드로 EngancedInput를 사용하는 법을 작성할 것이다.]]></summary></entry><entry><title type="html">[Git Blog] 사이드 카테고리 추가하기</title><link href="http://localhost:4000/gitblog/Blog-side-category-%EC%B6%94%EA%B0%80/" rel="alternate" type="text/html" title="[Git Blog] 사이드 카테고리 추가하기" /><published>2024-02-02T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/gitblog/Blog%20side%20category%20%EC%B6%94%EA%B0%80</id><content type="html" xml:base="http://localhost:4000/gitblog/Blog-side-category-%EC%B6%94%EA%B0%80/"><![CDATA[<p>좌측 사이드바에 카테고리를 넣어볼 것이다.</p>

<h2 id="1-카테고리-목록-정하기">1. 카테고리 목록 정하기</h2>
<p><code class="language-plaintext highlighter-rouge">_data/navigation.yml</code>에서 하단의 내용을 넣고 한글로 된 부분을 수정한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sidebar-category:
  - title: "타이틀"
    children:
      - title: "표시될제목"
        url: "/주소"
</code></pre></div></div>

<h2 id="2-카테고리-포스트-목록-페이지-생성">2. 카테고리 포스트 목록 페이지 생성</h2>
<p><code class="language-plaintext highlighter-rouge">_page</code>로가서 <code class="language-plaintext highlighter-rouge">catagories</code>라는 폴더를 만들고 안에 카테고리 요소당 하나씩 <code class="language-plaintext highlighter-rouge">*.md</code>파일을 생성해 준다. 그리고 아래 요소들을 수정한다.</p>
<ul>
  <li>title: 페이지 제목</li>
  <li>layout:페이지에서 사용할 layout</li>
  <li>permalink: navigation.yml에서 설정한 url</li>
  <li>탐색할카테고리: navigation.yml 설정한 category</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
title: "페이지 이름"
layout: archive
permalink: 링크
---
 {% assign posts = site.categories.탐색할카테고리 %}
{% for post in posts %}
  {% include custom-archive-single.html type=entries_layout %}
{% endfor %} 
</code></pre></div></div>

<h2 id="3포스트-수-표시">3.포스트 수 표시</h2>
<p><code class="language-plaintext highlighter-rouge">_includes/nav_list</code>에 아래 내용을 모두 덮어쓴다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{% assign navigation = site.data.navigation[include.nav] %}

&lt;nav class="nav__list"&gt;
  {% if page.sidebar.title %}&lt;h3 class="nav__title" style="padding-left: 0;"&gt;{{ page.sidebar.title }}&lt;/h3&gt;{% endif %}
  &lt;input id="ac-toc" name="accordion-toc" type="checkbox" /&gt;
  &lt;label for="ac-toc"&gt;{{ site.data.ui-text[site.locale].menu_label | default: "Toggle Menu" }}&lt;/label&gt;
  &lt;ul class="nav__items"&gt;
    {% for nav in navigation %}
      &lt;li&gt;
        {% if nav.url %}
          &lt;a href="{{ nav.url | relative_url }}"&gt;&lt;span class="nav__sub-title"&gt;{{ nav.title }}&lt;/span&gt;&lt;/a&gt;
        {% else %}
          &lt;span class="nav__sub-title"&gt;{{ nav.title }}&lt;/span&gt;
        {% endif %}

        {% if nav.children != null %}
        &lt;ul&gt;
          {% for child in nav.children %}
          {% assign post_cnt = 0 %}
          {% for category in site.categories %}
            {% if category[0] == child.category  %}
                {% assign post_cnt = category[1].size %}
            {% endif %}
          {% endfor %}

            &lt;li&gt;&lt;a href="{{ child.url | relative_url }}"{% if child.url == page.url %} class="active"{% endif %}&gt;{{ child.title }}({{ post_cnt }})&lt;/a&gt;&lt;/li&gt;
          {% endfor %}
        &lt;/ul&gt;
        {% endif %}
      &lt;/li&gt;
    {% endfor %}
  &lt;/ul&gt;
&lt;/nav&gt; 
</code></pre></div></div>

<h2 id="4모든페이지-사이드바-적용">4.모든페이지 사이드바 적용</h2>
<p>루트폴더에 있는 <code class="language-plaintext highlighter-rouge">config.yml</code>에서 sidebar 부분을 추가해준다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defaults:
  # _posts
  - scope:
      path: ""
      type: posts
    values:
      layout: single
      author_profile: true
      read_time: true
      comments: true
      share: true
      related: true
      show_date: true
      sidebar: # 추가
        nav: "sidebar-category"
</code></pre></div></div>

<h2 id="5결과">5.결과</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/12ef844b-9baa-4af1-8096-dd9c8ab1571c" alt="image" /></p>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="gitblog" /><category term="minimal-mistake" /><category term="Jekyll" /><category term="Blog" /><summary type="html"><![CDATA[좌측 사이드바에 카테고리를 넣어볼 것이다.]]></summary></entry><entry><title type="html">[Git Blog] Liquid 문법{% %}표시하기</title><link href="http://localhost:4000/gitblog/Liquid-%EB%AC%B8%EB%B2%95-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Git Blog] Liquid 문법{% %}표시하기" /><published>2024-02-02T00:00:00+09:00</published><updated>2024-02-02T00:00:00+09:00</updated><id>http://localhost:4000/gitblog/Liquid%20%EB%AC%B8%EB%B2%95%20%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/gitblog/Liquid-%EB%AC%B8%EB%B2%95-%ED%91%9C%EC%8B%9C%ED%95%98%EA%B8%B0/"><![CDATA[<h2 id="liquid">Liquid?</h2>
<p>블로그를 작성하다 보면 가끔 {% %}라고 쓰여진 텍스트를 쓸 때가 있다. 하지만 그냥 작성하면 포스트에는 보이지 않고 사라지는 경우가 있다. 이는 {% %}는 Liquid라는 템플릿 언어의 문법 중 하나로 Jekyll같은 정적 사이트에서 주로 사용된다.</p>

<p>{% %} 사이에 Liquid 문법을 넣어 템플릿을 생성하거나 조건문을 넣는데 아무 조치없이 사용하면 Jekyll 사이트는 글이 아닌 문법으로 보고 실행 되어 사라져 보였던 것이다.</p>
<h2 id="해결법">해결법</h2>
<p>raw 태그를 이용해 다음과 같이 작성하면 표시된다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{% raw %}
Liquid 문법
{% endraw %}
</code></pre></div></div>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="gitblog" /><category term="minimal-mistake" /><category term="Jekyll" /><category term="Blog" /><category term="Liquid" /><category term="template" /><category term="markdown" /><summary type="html"><![CDATA[Liquid? 블로그를 작성하다 보면 가끔 {% %}라고 쓰여진 텍스트를 쓸 때가 있다. 하지만 그냥 작성하면 포스트에는 보이지 않고 사라지는 경우가 있다. 이는 {% %}는 Liquid라는 템플릿 언어의 문법 중 하나로 Jekyll같은 정적 사이트에서 주로 사용된다.]]></summary></entry><entry><title type="html">[Hardware] GPU 인식 안되는 현상 해결</title><link href="http://localhost:4000/hardware/GPU-%EC%9D%B8%EC%8B%9D%EC%95%88%EB%90%8C-%ED%95%B4%EA%B2%B0/" rel="alternate" type="text/html" title="[Hardware] GPU 인식 안되는 현상 해결" /><published>2024-02-01T00:00:00+09:00</published><updated>2024-02-01T00:00:00+09:00</updated><id>http://localhost:4000/hardware/GPU%20%EC%9D%B8%EC%8B%9D%EC%95%88%EB%90%8C%20%ED%95%B4%EA%B2%B0</id><content type="html" xml:base="http://localhost:4000/hardware/GPU-%EC%9D%B8%EC%8B%9D%EC%95%88%EB%90%8C-%ED%95%B4%EA%B2%B0/"><![CDATA[<p>큰돈을 주고 컴퓨터를 새로 장만하고 기쁜 마음으로 언리얼엔진5를 시작했다. 그런데 이상하게도 에디터의 인식이 굉장히 느렸었다. 단순한 버그라기엔 뭔가 이상해서 CPU-Z를 이용해 그래픽카드를 확인해 봤더니…</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/8b71498c-988e-45d2-bd83-6a7b3f7d7448" alt="스크린샷 2024-02-01 192002" /></p>

<p>분명 내 GPU는 <strong>RTX 4070 SUPER</strong>인데 구매한적도 없는 GPU가 들어가 있었다. 조립업체에 맡겨서 조립후 배달로 온건데 사기를 당한건가 싶기도 했다. 확인해 보니 인식되고 있던 GPU는 <strong>CPU내장 그래픽카드</strong>로 외장 그래픽이 없을 경우 적용되는 GPU였다. 그래서 GPU가 다시 인식될 수 있도록 조치를 해야한다.</p>

<h2 id="pc-정보">PC 정보</h2>
<p><strong>CPU</strong>: AMD 라이젠9-5세대 7900X3D
<strong>메인보드</strong>: ASRock B650M PG Riptide
<strong>GPU</strong>: ZOTAC GAMING 지포스 RTX 4070 SUPER TWIN Edge OC D6X 12GB</p>

<h2 id="1-gpu-인식-확인">1. GPU 인식 확인</h2>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/52c02b95-3fbd-4556-bdc6-761469d426f7" alt="스크린샷" />
먼저 GPU가 인식이 되고 있는지 확인해봐야 한다. 
장치 관리자로 들어가서 디스플레이 어댑터를 들어가면 인식되는 GPU를 확인할 수 있다.
<img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/f4b93f52-e03c-464c-8470-6b55bfc295dc" alt="스크린샷" />
인식이 안된다면 보기/숨겨진 장치 표시를 눌러 인식되고 있지 않은 GPU를 확인해본다.</p>

<h2 id="2-그래픽-드라이버-업데이트">2. 그래픽 드라이버 업데이트</h2>
<p>그래픽카드 드라이버가 제대로 설치되지 않아 발생할 수 있다. <a href="https://www.nvidia.co.kr/Download/index.aspx?lang=kr">엔비디아 드라이버</a>설치 사이트로 가서 자신의 버전에 맞는 드라이버를 설치한다.</p>

<p>혹은 윈도우 업데이트 문제일 수 있으니 Win + I키를 누르고 Windows Update에 들어가 업데이트 해준다.</p>

<h2 id="3-gpu-장착-확인하기">3. GPU 장착 확인하기</h2>
<p>필자의 경우 이것이 문제였다. 메인보드 슬롯 부분에 GPU가 완전히 들어가지 않고 살짝 빠져와 있던 상태였다. 해체후 다시 장착하니 다행히 잘 작동되었다. 아마 조립업체에서 택배로 오던 도중 GPU가 살짝 빠져나온 것이 원인인 듯 싶다.</p>

<h2 id="4-bios-설정문제">4. BIOS 설정문제</h2>
<p>GPU팬도 잘돌아가 장착문제가 아닌것 같은면 바이오스 문제일 수도 있다. 참고로 BIOS는 <strong>메인보드의 종류에따라 화면 구성이 다르다</strong></p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/a348bf39-b279-47fe-9826-e2b712f89311" alt="image" /></p>

<p>GPU가 내장GPU로 설정되어 생긴 문제일 수도 있다. 컴퓨터 재부팅 후 F2를 눌러 바이오스로 들어가고 Advanced/AMD CBS/NBIO Options/GFX configuration로 들어가서 iGPU Configuration을 iGPU Disabled로 바꿔 내장GPU를 끌 수 있다.</p>

<p>iGPU Disabled로 했는데 계속 초기화 될 수 있다. 그럴 경우 여러가지 이유가 있다.</p>
<ol>
  <li><strong>외장GPU</strong> 고정 불량 - 필자의 경우에 이걸 간과해 자꾸 삽질했다. LED와 팬이 돌아가도 제대로 다시 확인해보자</li>
  <li><strong>메인보드 전지 수명</strong> - 메인보드 메모리는 <strong>휘발성 메모리</strong>다. 오래 된 메인보드일 경우 수은전지를 구매해 다시 장착하자.</li>
  <li><strong>조립불량</strong> - <strong>메인보드 조립</strong>이 불량하여 쇼트가 일어나는 것일 수 있다.</li>
</ol>

<h2 id="5-bios-업데이트">5. BIOS 업데이트</h2>
<p>구형 BIOS일경우 메인보드 제조사 홈페이지로 들어가 최신BIOS로 업데이트 해준다.</p>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="hardware" /><category term="GPU" /><category term="CPU" /><category term="Grapic Driver" /><category term="Bios" /><category term="Hardware" /><category term="Mainboard" /><summary type="html"><![CDATA[큰돈을 주고 컴퓨터를 새로 장만하고 기쁜 마음으로 언리얼엔진5를 시작했다. 그런데 이상하게도 에디터의 인식이 굉장히 느렸었다. 단순한 버그라기엔 뭔가 이상해서 CPU-Z를 이용해 그래픽카드를 확인해 봤더니…]]></summary></entry><entry><title type="html">[C++] 자원관리 기법 RAII</title><link href="http://localhost:4000/c++/RAII/" rel="alternate" type="text/html" title="[C++] 자원관리 기법 RAII" /><published>2024-01-30T00:00:00+09:00</published><updated>2024-01-30T00:00:00+09:00</updated><id>http://localhost:4000/c++/RAII</id><content type="html" xml:base="http://localhost:4000/c++/RAII/"><![CDATA[<h2 id="raii">RAII</h2>
<p>C++진영에서 자주 쓰이는 Idiom으로 객체가 쓰이는 Scope를 벗어나면 자원을 해제해주는 기법</p>

<p>Resource Acquisition Is Initialization 자원의 획득은 초기화라는 뜻으로 다르게 말해서 객체와 자원의 라이프 사이클을 일치 시키라는 것이다.</p>

<p>무슨 말이냐면 자원을 얻을 때 초기화(Constructor)가 되어야 하며 객체가 사라질 때는 자원을 전부 반환(Destructor)해야 하며 객체가 유효하지 않은 상태 이게 만들어. 자원 생성, 파괴, 관리를 프로그래머가 아닌 객체에 위임하는 것을 의미한다.</p>

<h3 id="raii-쓰이는-이유">RAII 쓰이는 이유</h3>
<p>C++ 같은 Unmanaged 언어들을 다룰 때엔 메모리를 사용하는 각 변수들의 유효한 스코프를 파악 해야한다.그러나 다수의 프로그래머들이 참여하면 각 객체가 어디까지 메모리를 관리하는 지  불분명하기 때문에 메모리 누수가 일어날 수 있다. 이를 방지하고자 나온게 RAII이다.</p>

<p>RAII를 사용하면 다음과 같은 효과를 얻을 수 있다.</p>
<ul>
  <li>쓰는 객체만 이용함으로 써 효과적인 메모리 관리</li>
  <li>메모리 관리를 객체 위임함으로 써 시간 효율 상승</li>
</ul>

<p>string 및 vector는 RAII따르는 표준 라이브러리 클래스로서 동적 메모리는 초기화시 획득하고, 파괴 시 자동으로 정리된다.</p>

<h3 id="raii-주의사항">RAII 주의사항</h3>
<ul>
  <li>new를 이용한 생성은 자제하자.
    <ul>
      <li>사용자에게 권한이 주어지기 때문에 RAII와 맞지않다.</li>
    </ul>
  </li>
  <li>생성 후 뒷 처리하지 말기
    <ul>
      <li>RAII는 생성 후 망각이라는 원칙이 있다. 소유권이 넘어간 객체가 처리하게 한다.</li>
    </ul>
  </li>
</ul>

<h3 id="사용-예시">사용 예시</h3>
<ul>
  <li>로깅</li>
  <li>코드블럭이 실행되는 시간 재기</li>
  <li>synchorized 영역 만들기</li>
</ul>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="c++" /><category term="C++" /><category term="RAII" /><summary type="html"><![CDATA[RAII C++진영에서 자주 쓰이는 Idiom으로 객체가 쓰이는 Scope를 벗어나면 자원을 해제해주는 기법]]></summary></entry><entry><title type="html">[Obsidian] 코드수정을 한번에 CustomJS</title><link href="http://localhost:4000/obsidian/Dataview-CustomJS-%EC%82%AC%EC%9A%A9%EB%B2%95/" rel="alternate" type="text/html" title="[Obsidian] 코드수정을 한번에 CustomJS" /><published>2024-01-29T00:00:00+09:00</published><updated>2024-01-29T00:00:00+09:00</updated><id>http://localhost:4000/obsidian/Dataview%20CustomJS%20%EC%82%AC%EC%9A%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/obsidian/Dataview-CustomJS-%EC%82%AC%EC%9A%A9%EB%B2%95/"><![CDATA[<h2 id="what-is-customjs">What is CustomJS</h2>
<p>CustomJS란 dataview에 Javascript로 작성한 함수를 적용할 수 있게 해주는 플러그인이다.</p>

<h2 id="why-use-customjs">Why use CustomJS</h2>
<p>옵시디언에서 Dataview가 적힌 템플릿 노드들을 여러개 생성하다 보면 어느순간 Dataview 코드를 수정하고 싶을때가 있다. 하지만 수정하기엔 이미 너무나도 많이 생겨버려 수정할 엄두도 나지 않는다. 이를 방지할 수 있도록 코드를 함수로 작성해 <strong>간결</strong>하고,<strong>유지보수</strong> 효율을 높여줄 수 있게 해준다.</p>

<h2 id="how-to-use">How to use</h2>
<h5 id="1-customjs-다운">1. CustomJs 다운</h5>
<p>community plugin에 들어가 <strong>CustomJS</strong>를 다운한다.</p>

<h5 id="2-폴더-지정">2. 폴더 지정</h5>
<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/1313b76b-c6de-493c-aa75-3b7fdb766b6e" alt="image" />
CustomJS 플러그인 설정에 가서 js 파일들 위치 폴더를 지정해준다.
<br /></p>

<h5 id="3-함수작성">3. 함수작성</h5>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ShowTasks {
ShowNotComplitedTasksInFile(dv, pg) {
	let tasks = pg.file.tasks.where(p =&gt; !p.Completed);
	if (tasks.length == 0) {
		return;
	}

	dv.header(2, pg.file.link);
	for (let group of tasks.groupBy(t =&gt; t.section)) {
		dv.taskList(group.rows, false);
	}
}

	ShowNotComplitedTasksInPath(dv, path) {
		const { ShowTasks } = customJS;
	for (let page of dv.pages(`"${path}"`)) {
		ShowTasks.ShowNotComplitedTasksInFile(dv, page);
	}
}
}
</code></pre></div></div>
<p>*.js확장자 파일을 만들고 class와 함수를 작성해준다.
위 코드는 특정 위치에 있는 노드들의 완료되지 않은 Task를 보여주는 코드 함수다.
<br /></p>

<h5 id="4-사용법">4. 사용법</h5>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dataviewjs
const {ShowTasks} = customJS;
const {ShowNotComplitedTasksInFile} = customJS;
const current = dv.current();
ShowTasks.ShowNotComplitedTasksInPath(dv,current.file.folder);
</code></pre></div></div>
<p>옵시디언에서 위와같이 js파일안에 클래스와 함수를 불러와주면 된다.</p>

<p><img src="https://github.com/mohitto55/mohitto55.github.io/assets/154340583/24e1274b-75e9-4679-aa3b-f82d09eb1d6c" alt="image" /></p>

<p>이제 단 한번의 수정으로 코드를 관리할 수 있게되었다.</p>]]></content><author><name>Mohitto55</name><email>mohitto55@gmail.com</email></author><category term="obsidian" /><category term="Obsidian" /><category term="DataviewJS" /><category term="CustomJS" /><summary type="html"><![CDATA[What is CustomJS CustomJS란 dataview에 Javascript로 작성한 함수를 적용할 수 있게 해주는 플러그인이다.]]></summary></entry></feed>