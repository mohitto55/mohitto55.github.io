<h2 id="통신을-위한-규칙-프로토콜">통신을 위한 규칙, 프로토콜</h2>
<ul>
  <li>Packet을 처리하려면 규칙이 필요하다</li>
  <li>프로토콜 덕에 회사가 달라도 패킷 처리가 가능하다</li>
  <li>Https도 프로토콜이다.</li>
</ul>

<h3 id="프로토콜에-결정되어-있는-것">프로토콜에 결정되어 있는 것</h3>
<ul>
  <li>LAN케이블 소재나 핀도 프로토콜이 있다.</li>
  <li>Packet와 Header에도 어느 영역이 어떤 정보인지 프로토콜이 있다.</li>
</ul>

<h3 id="프로토콜은-계층으로-정리한다">프로토콜은 계층으로 정리한다.</h3>
<ul>
  <li>데이터 송신할 땐 위 계층에서 아래 계층으로</li>
  <li>데이터 수신할 땐 아래 계층에서 위 계층으로</li>
  <li>송수신 할 때 같은 계층에서 일처리한다.
    <h3 id="두가지-계층구조-모델">두가지 계층구조 모델</h3>
    <h4 id="tcpip-45계층">TCP/IP 4,5계층</h4>
    <p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/ba6486b7-2af9-40f1-bc00-d72910333b8d" alt="image" /></p>
  </li>
  <li>문서마다 4계층 혹은 5계층으로 나뉜다
    <ul>
      <li>5계층으로 생각하는 것이 좋을 듯하다</li>
    </ul>
  </li>
  <li>실질적으로 OSI보다 이 구조를 많이 사용한다.</li>
</ul>

<h4 id="osi-7계층">OSI 7계층</h4>
<p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/a4426d89-74fb-4b5c-a4f4-c19fb5f006ec" alt="image" />
국제표준기구에서 만든 컴퓨터 프로토콜 계층으로 각 계층은 다른 계층에 의존할 필요 없어 캡슐화와 은닉이 용이하다.</p>

<p>OSI를 다 지켜서 하는 프로토콜은 없다고 한다. 이유는 너무 복잡하기 때문이다.</p>

<h3 id="ip-주소ip-address">IP 주소(IP Address)</h3>
<p>인터넷에 연결된 컴퓨터들의 주소로 Ipv4 버전을 사용한다. 32bit로 구성되며 192.168.212.153 과 같이 표기한다. 네트워크 계층에서 쓰이는 값이다.</p>

<h3 id="mac-주소">MAC 주소</h3>
<p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/8e1257f2-702b-44d4-be35-3455a39dda5b" alt="image" />
MAC주소는 6바이트로 구성되며, ‘00-0c-29-43-5e-be’ 혹은 ‘00:0c:29:43:5e:be’ 처럼 16진수로 표현된다.</p>

<ul>
  <li>물리 <em>Appliance</em>의 경우 물리 <em>NIC</em>가 만들어 질때 <em>ROM</em>에 기록한다.</li>
  <li>가상 <em>Appliance</em>의 경우 기본적으로 하이퍼바이저에서 가상 <em>NIC</em>에 할당된다.</li>
</ul>

<p>MAC 주소 맨 앞자리 3개는 벤더코드로 OUI라고 불리고 단말의 NIC를 어디서 제조했는지 알 수 있음. 뒤자리 3개는 UAA라고 벤더에서 할당하거나 무작위로 정해진 값이다.</p>

<p>MAC주소는 <strong>고유한 값을 가지지 않는다</strong>. 그래서 MAC주소가 같은 기기가 여러 대가 같은 이더넷을 쓸 경우 주소를 바꿔줘야 한다.</p>

<p>※ Appliance - 특정 목적에 최적화된 성능 내도록 만들어진 하드웨어, OS, 어플리케이션
※ NIC - **Network Interface Controller의 약자로 인터넷에 연결하기 위한 하드웨어 장치
※ ROM - 한번 기록 시 다시 기록 못하지만 빨라서 바이오스를 저장하는 용도의 저장장치</p>

<h3 id="mac주소와-ip-주소-모두-필요한-이유">Mac주소와 IP 주소 모두 필요한 이유</h3>
<ul>
  <li>MAC Address는 NIC에 할당 된 <strong>물리적</strong> 주소 - 어떤 기기에 프레임 전달하지?</li>
  <li>IP주소는 OS에 할당된 <strong>논리적</strong> 주소 - 어디에 패킷 전달하지?</li>
  <li>이 두 주소를 연결하는 다리가 ARP
    <ul>
      <li>네트워크 계층과 데이터 링크 계층 연결</li>
    </ul>
  </li>
  <li>데이터 링크 계층 - 이더넷</li>
  <li>네트워크 계층 - IP 이기 때문에 양쪽 주소가 필요함</li>
  <li>데이터링크 계층에서 PPP사용하면 MAC은 필요없음</li>
</ul>

<p>※ ppp - 점대점 프로토콜로 연결 양끝 노드간에 일대일(point-to-point)직렬 링크를 구성하여 데이터 전달한다</p>

<p>출처 : 그림으로 배우는 TCPIP구조
http://www.ktword.co.kr/test/view/view.php?m_temp1=1074&amp;id=429</p>

<h3 id="ipaddress-클래스">IPAddress 클래스</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">IPAddress</span> <span class="p">:</span> <span class="n">IParsable</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Net</span><span class="p">.</span><span class="n">IPAddress</span><span class="p">&gt;,</span> <span class="n">ISpanFormattable</span><span class="p">,</span> <span class="n">ISpanParsable</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Net</span><span class="p">.</span><span class="n">IPAddress</span><span class="p">&gt;,</span> <span class="n">IUtf8SpanFormattable</span>
</code></pre></div></div>
<p>.NET에서는 IP 주소를 표기하기위해 IPAddress 클래스를 사용한다.
IPAddress를 초기화 하는 데는 여러 방법이 있다.</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IPAddress</span> <span class="n">ip1</span> <span class="p">=</span> <span class="n">IPAddress</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="s">"192.168.1.13"</span><span class="p">);</span>
<span class="n">IPAddress</span> <span class="n">ip2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">IPAddress</span><span class="p">(</span><span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="m">192</span><span class="p">,</span> <span class="m">168</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">13</span> <span class="p">});</span>
<span class="n">IPAddress</span> <span class="n">ip3</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">IPAddress</span><span class="p">(</span><span class="m">218212544</span><span class="p">);</span>
</code></pre></div></div>

<p>https://www.csharpstudy.com/net/article/3-IP-%EC%A3%BC%EC%86%8C%EC%99%80-%ED%98%B8%EC%8A%A4%ED%8A%B8</p>

<p>https://www.csharpstudy.com/net/article/9-Socket-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8</p>

<p>https://learn.microsoft.com/ko-kr/dotnet/api/system.net.sockets.socket?view=net-8.0</p>

<h3 id="socket-class">Socket class</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Socket</span> <span class="p">:</span> <span class="n">IDisposable</span>
</code></pre></div></div>
<p>Socket은 .NET Framework에서 가장 Low 레벨 클래스로 TcpClient, TcpListener, UDPClient들 모두 Socket을 바탕으로 만들어 졌다. Socket은 AppleTalk, IPX, Netbios 등 다양한 네트워크 통신에서 사용할 수 있다.</p>

<h3 id="ipendpoint">IPEndPoint</h3>
<p>https://learn.microsoft.com/ko-kr/dotnet/api/system.net.ipendpoint?view=net-7.0</p>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">IPEndPoint</span> <span class="p">:</span> <span class="n">System</span><span class="p">.</span><span class="n">Net</span><span class="p">.</span><span class="n">EndPoint</span>
</code></pre></div></div>
<blockquote>
  <p>네트워크 엔드포인트를 IP주소와 포트 번호로 나타낸다.</p>
</blockquote>

<h3 id="socket-클라이언트">Socket 클라이언트</h3>
<p>Socket 클래스는 클라이언트와 서버에서 공히 사용 할 수 있다.</p>

<ul>
  <li>Stream - 데이터 복제와 경계 보존 없이 연결기반 byte 스트림을 지원한다.
    <h3 id="encoding">Encoding</h3>
    <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Encoding</span> <span class="p">:</span> <span class="n">ICloneable</span>
</code></pre></div>    </div>
    <p>우리가 문자를 패킷으로 보낼 땐 문자를 0101같은 컴퓨터 언어(byte)로 변경해야 한다. 이러한 과정을 <strong>인코딩</strong>이라고 부르며 ASCII, Unicode, UTF8 과 같은 다양한 방식으로 인코딩 할 수 있다. C#에서는 이런 인코딩 과정을 도와주는 Encoding 클래스가 있다.</p>
  </li>
</ul>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="n">s1</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">Unicode</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">uniBytes</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">s2</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">utf8bytes</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">s3</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">defBytes</span><span class="p">);</span>
</code></pre></div></div>
<blockquote>
  <p>이런 방식으로 byte를 다시 사람이 읽을 수 있는 문자로 바꿀 수 있다.</p>
</blockquote>

<p>https://www.csharpstudy.com/Tip/Tip-string-encoding.aspx</p>

<h3 id="addressfamily">AddressFamily</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">AddressFamily</span>
</code></pre></div></div>
<p>네트워크 유형을 뜻한다. 일반 네트워크 IP 통신에선 언제나 AddressFamily.Internetwork를 사용한다. 필드 값으로 AppleTalk, Atm, FireFox, Max 등이 있는데 사용할 경우는 적어보인다.</p>

<h3 id="sockettype">SocketType</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">SocketType</span>
</code></pre></div></div>

<h3 id="socketflags">SocketFlags</h3>
<p>주로 Socket.Send(), Socket.Receive() 메서드와 함께 사용되며 데이터 전송 및 수신 동작을 제어할 수 있다. Field를 몇가지 살펴보자면</p>
<ul>
  <li>None - 기본 동작 소켓 수행</li>
  <li>Peek - 들어오는 메시지를 미리 확인</li>
  <li>OutOfBand - 대역 외 데이터 처리</li>
  <li>DontRoute - 라우팅 테이블 사용하지 않고 보내기</li>
  <li>Truncated - 메시지가 너무 커 지정된 버퍼에 맞지 않아 자른다.
https://learn.microsoft.com/ko-kr/dotnet/api/system.net.sockets.socketflags?view=netcore-3.1</li>
</ul>

<h2 id="소켓-함수">소켓 함수</h2>
<h3 id="bind">Bind</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Socket</span><span class="p">.</span><span class="nf">Bind</span><span class="p">();</span>
</code></pre></div></div>
<p><img src="https://github.com/mohitto55/Blog_Images/assets/154340583/984b5482-906d-4683-b012-344b8ddc24be" alt="image" />
응용 프로그램 자신(Local)주소와 소켓번호를 연결하는 작업</p>

<p>서버에서 Bind를 해야하는 이유는 임의의 클라이언트가 서버 프로그램이 만든 소켓과 통신 하려면 그 소켓을 찾을 수 있어야 하며 따라서 서버는 소켓번호와 클라이언트가 알고 있을 서버의 IP주소 및 포트번호(서버의 소켓주소)를 미리 연결 시켜두는 것이 필요하다</p>

<p>간단히 말해 클라이언트가 서버 소켓과 위치를 알기위해 줄로 연결한 작업이다.</p>

<h3 id="accept">Accept</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Socket</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
</code></pre></div></div>
<p>소켓에서 들어오는 연결 시도를 허용하는 함수
소켓과의 연결함
https://learn.microsoft.com/ko-kr/windows/win32/api/winsock2/nf-winsock2-accept</p>

<h3 id="connect">Connect</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Socket</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
</code></pre></div></div>
<p>원격 호스트에 대한 연결 설정.
호스트는 hostname과 port number로 지정된다.</p>

<p>※ 호스트(host) : 네트워크/인터넷에서 호스트는 네트워크/인터넷을 통해 다른 컴퓨터들과 쌍방향 통신이 가능한 컴퓨터</p>

<h3 id="accept와-connect-차이점">Accept와 Connect 차이점</h3>
<ul>
  <li>Accept
    <ul>
      <li>서버 소켓에서 호출</li>
      <li>소켓에서의 연결 시도 허용</li>
    </ul>
  </li>
  <li>Connect
    <ul>
      <li>클라이언트 소켓에서 호출</li>
      <li>서버에 연결하기 위해 호출한다</li>
      <li>서버에서 Accept를 하면 양방향 통신 시작한다</li>
    </ul>
  </li>
</ul>

<h2 id="쓰레드-함수">쓰레드 함수</h2>
<h3 id="join">Join</h3>
<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Thread</span><span class="p">.</span><span class="nf">Join</span><span class="p">()</span>
</code></pre></div></div>
<p>이 인스턴스가 나타내는 스레드가 종료될 때까지 호출 스레드를 차단
현재 스레드 객체의 작업이 완료되거나 종료 될 때까지 기본 스레드의 실행을 대기 하도록 한다.
이 스레드가 끝날 때까지 메인 프로그램은 종료되지 않는다.</p>

<div class="Reference">
<div class="callout-header"> </div>
<p>
<a href=""></a>
</p>
</div>
